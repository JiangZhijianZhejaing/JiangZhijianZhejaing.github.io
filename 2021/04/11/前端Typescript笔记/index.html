<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="AI Jiang"><meta name="copyright" content="AI Jiang"><meta name="generator" content="Hexo 5.4.0"><meta name="theme" content="hexo-theme-yun"><title>前端Typescript笔记 | Hexo</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.24/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_ed8vp4atwoj.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link rel="shortcut icon" type="image/svg+xml" href="/imgaes/avatar.jpg"><link rel="mask-icon" href="/imgaes/avatar.jpg" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"example.com","root":"/","title":"AI.Jiang的笔记","version":"1.5.1","mode":"auto","copycode":true,"page":{"isPost":true},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml"><meta name="description" content="1.基础 笔记来自B站技术胖  1.1建立项目目录和编译 TS 文件 在E盘(当然你可以在你喜欢的任何一个地方安装)，新建一个目录，我这里起的目录名字叫做TypeScriptDemo，然后把这个文件在 VSCode 中打开。 我在视频里用了命令行的形式建立，直接使用ctrl+r打开运行，然后在运行的文本框里输入cmd，回车后，打开命令行工具，在命令行中输入下面的命令。 12e:mkdir Typ">
<meta property="og:type" content="article">
<meta property="og:title" content="前端Typescript笔记">
<meta property="og:url" content="http://example.com/2021/04/11/%E5%89%8D%E7%AB%AFTypescript%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1.基础 笔记来自B站技术胖  1.1建立项目目录和编译 TS 文件 在E盘(当然你可以在你喜欢的任何一个地方安装)，新建一个目录，我这里起的目录名字叫做TypeScriptDemo，然后把这个文件在 VSCode 中打开。 我在视频里用了命令行的形式建立，直接使用ctrl+r打开运行，然后在运行的文本框里输入cmd，回车后，打开命令行工具，在命令行中输入下面的命令。 12e:mkdir Typ">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-04-11T03:05:37.000Z">
<meta property="article:modified_time" content="2021-04-23T13:39:55.231Z">
<meta property="article:author" content="AI Jiang">
<meta property="article:tag" content="前端开发">
<meta name="twitter:card" content="summary"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="AI Jiang"><img width="96" loading="lazy" src="/Yun.png" alt="AI Jiang"></a><div class="site-author-name"><a href="/about/">AI Jiang</a></div><a class="site-name" href="/about/site.html">Hexo</a><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">19</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">7</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">7</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://qm.qq.com/cgi-bin/qm/qr?k=epvxdq1sknJe9JMj6J1LsBw4a6cI_2ln&amp;jump_from=webapi" title="QQ 群 389401003" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/JiangZhijianZhejaing" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://weibo.com/jizhideyunyoujun" title="微博" target="_blank" style="color:#E6162D"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-weibo-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.douban.com/people/yunyoujun/" title="豆瓣" target="_blank" style="color:#007722"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-douban-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=247102977" title="网易云音乐" target="_blank" style="color:#C20C0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.zhihu.com/people/yunyoujun/" title="知乎" target="_blank" style="color:#0084FF"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-zhihu-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/1579790" title="哔哩哔哩" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://twitter.com/YunYouJun" title="Twitter" target="_blank" style="color:#1da1f2"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-twitter-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://t.me/elpsycn" title="Telegram Channel" target="_blank" style="color:#0088CC"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-telegram-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:me@yunyoujun.cn" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://travellings.now.sh/" title="Travelling" target="_blank" style="color:var(--hty-text-color)"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-send-plane-2-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text"> 1.基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E5%BB%BA%E7%AB%8B%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E5%92%8C%E7%BC%96%E8%AF%91-ts-%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.</span> <span class="toc-text"> 1.1建立项目目录和编译 TS 文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12ts-node-%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.</span> <span class="toc-text"> 1.2ts-node 的安装和使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E8%AF%AD%E8%A8%80%E7%89%B9%E7%82%B9"><span class="toc-number">1.3.</span> <span class="toc-text"> 1.3语言特点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text"> 2.基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text"> 2.1静态类型定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#211%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.1.</span> <span class="toc-text"> 2.1.1定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#212%E8%87%AA%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.2.</span> <span class="toc-text"> 2.1.2自定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E5%88%86%E7%B1%BB"><span class="toc-number">2.2.</span> <span class="toc-text"> 2.2分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#221%E5%9F%BA%E7%A1%80%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.1.</span> <span class="toc-text"> 2.2.1基础静态类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#222%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.2.</span> <span class="toc-text"> 2.2.2对象类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.2.1.</span> <span class="toc-text"> 函数类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.2.1.1.</span> <span class="toc-text"> 箭头函数:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#223typescript-%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%B3%A8%E9%87%8A%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-number">2.2.3.</span> <span class="toc-text"> 2.2.3TypeScript 中的类型注释和类型推断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#type-inferrence-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-number">2.2.3.1.</span> <span class="toc-text"> type inferrence 类型推断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E6%BD%9C%E8%A7%84%E5%88%99"><span class="toc-number">2.2.3.2.</span> <span class="toc-text"> 工作使用问题（潜规则）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23typescript-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="toc-number">2.3.</span> <span class="toc-text"> 2.3.TypeScript 函数参数和返回类型定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#231%E5%87%BD%E6%95%B0%E6%97%A0%E8%BF%94%E5%9B%9E%E5%80%BC%E6%97%B6%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.1.</span> <span class="toc-text"> 2.3.1函数无返回值时定义方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#232never-%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.2.</span> <span class="toc-text"> 2.3.2never 返回值类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#233%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%B8%BA%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84"><span class="toc-number">2.3.3.</span> <span class="toc-text"> 2.3.3函数参数为对象(解构)？？？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B-2"><span class="toc-number">2.3.4.</span> <span class="toc-text"> 函数类型：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">2.3.4.1.</span> <span class="toc-text"> 定义：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24typescript-%E4%B8%AD%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.4.</span> <span class="toc-text"> 2.4.TypeScript 中数组类型的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#241%E4%B8%80%E8%88%AC%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.4.1.</span> <span class="toc-text"> 2.4.1一般数组类型的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#242%E5%A4%9A%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84"><span class="toc-number">2.4.2.</span> <span class="toc-text"> 2.4.2多类型数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#243%E6%95%B0%E7%BB%84%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.4.3.</span> <span class="toc-text"> 2.4.3数组中对象类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2431%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">2.4.3.1.</span> <span class="toc-text"> 2.4.3.1类型别名</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25%E5%85%83%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E7%B1%BB%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-number">2.5.</span> <span class="toc-text"> 2.5元组的使用和类型约束</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#251%E5%85%83%E7%BB%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8"><span class="toc-number">2.5.1.</span> <span class="toc-text"> 2.5.1元组的基本应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#252%E5%85%83%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.5.2.</span> <span class="toc-text"> 2.5.2元组的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26typescript-%E7%9A%84-interface-%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.6.</span> <span class="toc-text"> 2.6TypeScript 的 interface 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#261%E6%8E%A5%E5%8F%A3interface"><span class="toc-number">2.6.1.</span> <span class="toc-text"> 2.6.1接口（Interface）.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#262%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.6.2.</span> <span class="toc-text"> 2.6.2接口和类型别名的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#263%E6%8E%A5%E5%8F%A3%E9%9D%9E%E5%BF%85%E9%80%89%E5%80%BC%E5%BE%97%E5%AE%9A%E4%B9%89"><span class="toc-number">2.6.3.</span> <span class="toc-text"> 2.6.3接口非必选值得定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#264%E5%85%81%E8%AE%B8%E5%8A%A0%E5%85%A5%E4%BB%BB%E6%84%8F%E5%80%BC"><span class="toc-number">2.6.4.</span> <span class="toc-text"> 2.6.4允许加入任意值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#265%E6%8E%A5%E5%8F%A3%E9%87%8C%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.6.5.</span> <span class="toc-text"> 2.6.5接口里的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#266%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB%E7%9A%84%E7%BA%A6%E6%9D%9F"><span class="toc-number">2.6.6.</span> <span class="toc-text"> 2.6.6接口和类的约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#267%E6%8E%A5%E5%8F%A3%E9%97%B4%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">2.6.7.</span> <span class="toc-text"> 2.6.7接口间的继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27typescript-%E4%B8%AD%E7%B1%BB%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">2.7.</span> <span class="toc-text"> 2.7TypeScript 中类的概念和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#271%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">2.7.1.</span> <span class="toc-text"> 2.7.1类的基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#272%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">2.7.2.</span> <span class="toc-text"> 2.7.2类的继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#273%E7%B1%BB%E7%9A%84%E9%87%8D%E5%86%99"><span class="toc-number">2.7.3.</span> <span class="toc-text"> 2.7.3类的重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#274super-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.7.4.</span> <span class="toc-text"> 2.7.4super 关键字的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#275typescript-%E4%B8%AD%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.7.5.</span> <span class="toc-text"> 2.7.5TypeScript 中类的访问类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2public%E8%AE%BF%E9%97%AE%E5%B1%9E%E6%80%A7-%E5%A4%96%E9%83%A8%E4%BD%BF%E7%94%A8"><span class="toc-number">2.7.5.1.</span> <span class="toc-text"> 2.public访问属性。(外部使用)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3private-%E8%AE%BF%E9%97%AE%E5%B1%9E%E6%80%A7%E5%86%85%E9%83%A8%E4%BD%BF%E7%94%A8%E7%BB%A7%E6%89%BF%E4%B8%8D%E8%A1%8C"><span class="toc-number">2.7.5.2.</span> <span class="toc-text"> 3.private 访问属性（内部使用继承不行）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4protected-%E8%AE%BF%E9%97%AE%E5%B1%9E%E6%80%A7%E7%BB%A7%E6%89%BF%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8"><span class="toc-number">2.7.5.3.</span> <span class="toc-text"> 4.protected 访问属性（继承无法使用）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#276typescript-%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.7.6.</span> <span class="toc-text"> 2.7.6TypeScript 类的构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2761%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.7.6.1.</span> <span class="toc-text"> 2.7.6.1类的构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2762%E7%B1%BB%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">2.7.6.2.</span> <span class="toc-text"> 2.7.6.2类继承中的构造器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28%E7%B1%BB%E7%AC%AC%E4%BA%8C%E6%AD%A5"><span class="toc-number">2.8.</span> <span class="toc-text"> 2.8类第二步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#281%E7%B1%BB%E7%9A%84getter-setter-%E5%92%8C-static"><span class="toc-number">2.8.1.</span> <span class="toc-text"> 2.8.1类的Getter、Setter 和 static</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2811%E7%B1%BB%E7%9A%84-getter-%E5%92%8C-setter"><span class="toc-number">2.8.1.1.</span> <span class="toc-text"> 2.8.1.1类的 Getter 和 Setter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2812%E7%B1%BB%E4%B8%AD%E7%9A%84-static"><span class="toc-number">2.8.1.2.</span> <span class="toc-text"> 2.8.1.2类中的 static</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#282%E7%B1%BB%E7%9A%84%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">2.8.2.</span> <span class="toc-text"> 2.8.2类的只读属性和抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2822%E7%B1%BB%E9%87%8C%E7%9A%84%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7-readonly"><span class="toc-number">2.8.2.1.</span> <span class="toc-text"> 2.8.2.2类里的只读属性 readonly</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2823%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.8.2.2.</span> <span class="toc-text"> 2.8.2.3抽象类的使用</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3tsconfigjson%E6%96%87%E4%BB%B6"><span class="toc-number">3.</span> <span class="toc-text"> 3.tsconfig.json文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#31%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E5%88%9D%E8%AF%86-tsconfigjson"><span class="toc-number">3.1.</span> <span class="toc-text"> 3.1配置文件-初识 tsconfig.json</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#311%E7%94%9F%E6%88%90-tsconfigjson-%E6%96%87%E4%BB%B6"><span class="toc-number">3.1.1.</span> <span class="toc-text"> 3.1.1生成 tsconfig.json 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#312%E8%AE%A9-tsconfigjson-%E6%96%87%E4%BB%B6%E7%94%9F%E6%95%88"><span class="toc-number">3.1.2.</span> <span class="toc-text"> 3.1.2让 tsconfig.json 文件生效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#313include-exclude-%E5%92%8C-files%E8%A7%A3%E5%86%B3%E5%8D%95%E4%B8%AA%E7%BC%96%E8%AF%91%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.3.</span> <span class="toc-text"> 3.1.3include 、exclude 和 files解决单个编译的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%BD%BF%E7%94%A8-include-%E9%85%8D%E7%BD%AE"><span class="toc-number">3.1.3.1.</span> <span class="toc-text"> 一：使用 include 配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E4%BD%BF%E7%94%A8-exclude-%E9%85%8D%E7%BD%AE"><span class="toc-number">3.1.3.2.</span> <span class="toc-text"> 二：使用 exclude 配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E4%BD%BF%E7%94%A8-files-%E9%85%8D%E7%BD%AE"><span class="toc-number">3.1.3.3.</span> <span class="toc-text"> 三：使用 files 配置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E5%88%9D%E8%AF%86%E9%85%8D%E7%BD%AE%E9%A1%B9"><span class="toc-number">3.2.</span> <span class="toc-text"> 3.2配置文件-初识配置项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#321removecomments"><span class="toc-number">3.2.1.</span> <span class="toc-text"> 3.2.1removeComments</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#322strict-%E5%B1%9E%E6%80%A7"><span class="toc-number">3.2.2.</span> <span class="toc-text"> 3.2.2strict 属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#323noimplicitany-%E5%B1%9E%E6%80%A7"><span class="toc-number">3.2.3.</span> <span class="toc-text"> 3.2.3noImplicitAny 属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#324strictnullchecks-%E5%B1%9E%E6%80%A7"><span class="toc-number">3.2.4.</span> <span class="toc-text"> 3.2.4strictNullChecks 属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#325ts-node-%E9%81%B5%E5%BE%AA-tsconfigjs-%E6%96%87%E4%BB%B6"><span class="toc-number">3.2.5.</span> <span class="toc-text"> 3.2.5ts-node 遵循 tsconfig.js 文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33compileroptions-%E9%85%8D%E7%BD%AE%E5%86%85%E5%AE%B9%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.3.</span> <span class="toc-text"> 3.3compilerOptions 配置内容详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#331rootdir-%E5%92%8C-outdir"><span class="toc-number">3.3.1.</span> <span class="toc-text"> 3.3.1rootDir 和 outDir</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#332%E7%BC%96%E8%AF%91-es6-%E8%AF%AD%E6%B3%95%E5%88%B0-es5-%E8%AF%AD%E6%B3%95-allowjs"><span class="toc-number">3.3.2.</span> <span class="toc-text"> 3.3.2编译 ES6 语法到 ES5 语法-allowJs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#333sourcemap-%E5%B1%9E%E6%80%A7%E6%98%A0%E5%B0%84"><span class="toc-number">3.3.3.</span> <span class="toc-text"> 3.3.3sourceMap 属性映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#334nounusedlocals-%E5%92%8C-nounusedparameters"><span class="toc-number">3.3.4.</span> <span class="toc-text"> 3.3.4noUnusedLocals 和 noUnusedParameters</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34%E6%96%87%E6%A1%A3"><span class="toc-number">3.4.</span> <span class="toc-text"> 3.4文档</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4"><span class="toc-number">4.</span> <span class="toc-text"> 4.联合类型和类型保护</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#41%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%E5%B1%95%E7%A4%BA18"><span class="toc-number">4.1.</span> <span class="toc-text"> 4.1联合类型展示18</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-number">4.2.</span> <span class="toc-text"> 4.2类型保护-类型断言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#421%E6%96%AD%E8%A8%80animal-as-teacher"><span class="toc-number">4.2.1.</span> <span class="toc-text"> 4.2.1断言animal as Teacher</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#422%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4-in-%E8%AF%AD%E6%B3%95"><span class="toc-number">4.2.2.</span> <span class="toc-text"> 4.2.2类型保护-in 语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#423%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4-typeof-%E8%AF%AD%E6%B3%95"><span class="toc-number">4.2.3.</span> <span class="toc-text"> 4.2.3类型保护-typeof 语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#typescript%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.3.1.</span> <span class="toc-text"> typescript使用${}字符串拼接方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#424%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4-instanceof-%E8%AF%AD%E6%B3%95"><span class="toc-number">4.2.4.</span> <span class="toc-text"> 4.2.4类型保护-instanceof 语法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5enum-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text"> 5.Enum 枚举类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#51%E6%80%9D%E8%80%83"><span class="toc-number">5.1.</span> <span class="toc-text"> 5.1.思考</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E7%BA%A7%E7%A8%8B%E5%BA%8F%E5%91%98%E5%86%99%E6%B3%95"><span class="toc-number">5.1.1.</span> <span class="toc-text"> 初级程序员写法:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E7%BA%A7%E7%A8%8B%E5%BA%8F%E5%91%98%E5%86%99%E6%B3%95"><span class="toc-number">5.1.2.</span> <span class="toc-text"> 中级程序员写法:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E5%91%98%E5%86%99%E6%B3%95"><span class="toc-number">5.1.3.</span> <span class="toc-text"> 高级程序员写法:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AF%B9%E5%BA%94%E5%80%BC"><span class="toc-number">5.2.</span> <span class="toc-text"> 5.2枚举类型的对应值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53%E6%9E%9A%E4%B8%BE%E9%80%9A%E8%BF%87%E4%B8%8B%E6%A0%87%E5%8F%8D%E6%9F%A5"><span class="toc-number">5.3.</span> <span class="toc-text"> 5.3枚举通过下标反查</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-typescript%E8%BF%9B%E9%98%B6"><span class="toc-number">6.</span> <span class="toc-text"> 6. Typescript进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#61typescript-%E5%87%BD%E6%95%B0%E6%B3%9B%E5%9E%8B-%E9%9A%BE%E7%82%B9"><span class="toc-number">6.1.</span> <span class="toc-text"> 6.1TypeScript 函数泛型-难点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#611%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B-demo"><span class="toc-number">6.1.1.</span> <span class="toc-text"> 6.1.1编写一个联合类型 Demo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#612%E5%88%9D%E5%A7%8B%E6%B3%9B%E5%9E%8B%E6%A6%82%E5%BF%B5-generic"><span class="toc-number">6.1.2.</span> <span class="toc-text"> 6.1.2初始泛型概念-generic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#613%E6%B3%9B%E5%9E%8B%E4%B8%AD%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">6.1.3.</span> <span class="toc-text"> 6.1.3泛型中数组的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#614%E5%A4%9A%E4%B8%AA%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">6.1.4.</span> <span class="toc-text"> 6.1.4多个泛型的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#615%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD%E4%BA%86%E8%A7%A3"><span class="toc-number">6.1.5.</span> <span class="toc-text"> 6.1.5泛型的类型推断了解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62typescript-%E7%B1%BB%E4%B8%AD%E6%B3%9B%E5%9E%8B"><span class="toc-number">6.2.</span> <span class="toc-text"> 6.2TypeScript 类中泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#621%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%B1%BB"><span class="toc-number">6.2.1.</span> <span class="toc-text"> 6.2.1编写一个基本类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#622%E5%88%9D%E5%A7%8B%E7%B1%BB%E7%9A%84%E6%B3%9B%E5%9E%8B"><span class="toc-number">6.2.2.</span> <span class="toc-text"> 6.2.2初始类的泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#623%E6%B3%9B%E5%9E%8B%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">6.2.3.</span> <span class="toc-text"> 6.2.3泛型中的继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#624%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-number">6.2.4.</span> <span class="toc-text"> 6.2.4泛型约束</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63%E5%88%9D%E8%AF%86%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-namespace"><span class="toc-number">6.3.</span> <span class="toc-text"> 6.3初识命名空间-Namespace</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#631%E6%90%AD%E5%BB%BA%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%AD%A5%E9%AA%A4"><span class="toc-number">6.3.1.</span> <span class="toc-text"> 6.3.1搭建浏览器开发环境步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#632%E6%B2%A1%E6%9C%89%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">6.3.2.</span> <span class="toc-text"> 6.3.2没有命名空间时的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#634%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">6.3.3.</span> <span class="toc-text"> 6.3.4命名空间的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64%E6%B7%B1%E5%85%A5%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">6.4.</span> <span class="toc-text"> 6.4深入命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#641%E7%94%A8%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E5%8C%96"><span class="toc-number">6.4.1.</span> <span class="toc-text"> 6.4.1用命名空间实现组件化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#642%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91%E6%88%90%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6"><span class="toc-number">6.4.2.</span> <span class="toc-text"> 6.4.2多文件编译成一个文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#643%E5%AD%90%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">6.4.3.</span> <span class="toc-text"> 6.4.3子命名空间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#65typescript-%E4%BD%BF%E7%94%A8-import-%E8%AF%AD%E6%B3%95"><span class="toc-number">6.5.</span> <span class="toc-text"> 6.5TypeScript 使用 import 语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#651%E4%BF%AE%E6%94%B9-componentsts-%E6%96%87%E4%BB%B6"><span class="toc-number">6.5.1.</span> <span class="toc-text"> 6.5.1修改 components.ts 文件</span></a></li></ol></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://example.com/2021/04/11/%E5%89%8D%E7%AB%AFTypescript%E7%AC%94%E8%AE%B0/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="AI Jiang"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="Hexo"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">前端Typescript笔记</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2021-04-11 11:05:37" itemprop="dateCreated datePublished" datetime="2021-04-11T11:05:37+08:00">2021-04-11</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="修改时间：2021-04-23 21:39:55" itemprop="dateModified" datetime="2021-04-23T21:39:55+08:00">2021-04-23</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category" href="/categories/%E5%89%8D%E7%AB%AF/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">前端</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">前端开发</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><h1 id="1基础"><a class="markdownIt-Anchor" href="#1基础"></a> 1.基础</h1>
<p>笔记来自B站技术胖</p>
<h2 id="11建立项目目录和编译-ts-文件"><a class="markdownIt-Anchor" href="#11建立项目目录和编译-ts-文件"></a> 1.1建立项目目录和编译 TS 文件</h2>
<p>在<code>E盘</code>(当然你可以在你喜欢的任何一个地方安装)，新建一个目录，我这里起的目录名字叫做<code>TypeScriptDemo</code>，然后把这个文件在 VSCode 中打开。 我在视频里用了命令行的形式建立，直接使用<code>ctrl+r</code>打开运行，然后在运行的文本框里输入<code>cmd</code>，回车后，打开命令行工具，在命令行中输入下面的命令。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e:</span><br><span class="line">mkdir TypeScriptDemo</span><br></pre></td></tr></table></figure>
<p>完成后，打开 E 盘，打开 VSCode，把新建立的<strong>文件夹拖入到 VSCode 当中</strong>，新建一个<code>Demo1.ts</code>文件，写入下面代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function jspang() &#123;</span><br><span class="line">  let web: string &#x3D; &quot;Hello World&quot;;</span><br><span class="line">  console.log(web);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jspang();</span><br></pre></td></tr></table></figure>
<p>这时候你使用<code>node Demo1.ts</code>是执行不成功的，因为 Node 不能直接运行<code>TypeScript</code>文件，需要用<code>tsc Demo1.ts</code>转换一下，转换完成后<code>typeScript</code>代码被编译成了<code>javaScript</code>代码,新生成一个<code>demo1.js</code>的文件，这时候你在命令行输入<code>node Demo1.js</code>,在终端里就可以顺利的输出<code>jspang</code>的字符了。</p>
<h2 id="12ts-node-的安装和使用"><a class="markdownIt-Anchor" href="#12ts-node-的安装和使用"></a> 1.2ts-node 的安装和使用</h2>
<p>使用<code>npm</code>命令来全局安装，直接在命令行输入下面的命令：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g ts-node</span><br></pre></td></tr></table></figure>
<p>安装完成后，就可以在命令中直接输入如下命令，来查看结果了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ts-node Demo1.ts</span><br></pre></td></tr></table></figure>
<h2 id="13语言特点"><a class="markdownIt-Anchor" href="#13语言特点"></a> 1.3语言特点</h2>
<ul>
<li>分号可选，句尾最好带上分号，同一行则一定需要使用分号来分隔，否则报错</li>
<li><strong>单行注释 ( // )</strong> <strong>多行注释 (/* */)</strong></li>
<li>面向对象编程</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Site</span> </span>&#123; </span><br><span class="line">   name():<span class="built_in">void</span> &#123; </span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Runoob&quot;</span>) </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Site(); </span><br><span class="line">obj.name();</span><br></pre></td></tr></table></figure>
<p>编译后生成的 JavaScript 代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Site = <span class="comment">/** <span class="doctag">@class </span>*/</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Site</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    Site.prototype.name = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> Site;</span><br><span class="line">&#125;());</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Site();</span><br><span class="line">obj.name();</span><br></pre></td></tr></table></figure>
<h1 id="2基本语法"><a class="markdownIt-Anchor" href="#2基本语法"></a> 2.基本语法</h1>
<h2 id="21静态类型定义"><a class="markdownIt-Anchor" href="#21静态类型定义"></a> 2.1静态类型定义</h2>
<h3 id="211定义"><a class="markdownIt-Anchor" href="#211定义"></a> 2.1.1定义</h3>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count: number = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>这就是最简单的**定义一个数字类型的<code>count</code>的变量，这里的<code>: number</code>就是定义了一个静态类型。**这样定义后<code>count</code>这个变量在程序中就永远都是数字类型了，不可以改变了。比如我们这时候给<code>count</code>复制一个字符串，它就报错了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误代码</span></span><br><span class="line"><span class="keyword">const</span> count: number = <span class="number">1</span>;</span><br><span class="line">count = <span class="string">&quot;jspang&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>但这只是最简单的理解，再往深一层次理解，你会发现这时候的<code>count</code>变量,可以使用**<code>number</code>类型上所有的属性和方法。**我们可以通过在<code>count</code>后边打上一个<code>.</code>看出这个特性，并且编辑器会给你非常好的提示。这也是为什么我喜欢用<code>VScode</code>编辑器的一个原因。</p>
<h3 id="212自定义"><a class="markdownIt-Anchor" href="#212自定义"></a> 2.1.2自定义</h3>
<p>你还可以自己去定义一个静态类型，比如现在你定义一个<code>小姐姐</code>的类型，然后在声明变量的时候，就可以使用这个静态类型了，看下面的代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface XiaoJieJie &#123;</span><br><span class="line">  uname: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> xiaohong: XiaoJieJie = &#123;</span><br><span class="line">  uname: <span class="string">&quot;小红&quot;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这时候你如果声明变量，**跟自定义不一样，<code>VSCode</code>直接就会报错。**需要注意的是，这时候<code>xiaohong</code>变量也具有<code>uname</code>和<code>age</code>属性了。</p>
<p>使用了静态类型，不仅意味着变量的类型不可以改变，还意味着类型的属性和方法也跟着确定了。这个特点就大大<strong>提高了程序的健壮性</strong>，并且编辑器这时候也会给你很好的语法提示，加快了你的开发效率。</p>
<h2 id="22分类"><a class="markdownIt-Anchor" href="#22分类"></a> 2.2分类</h2>
<p>在 TypeScript 静态类型分为两种，一种是<strong>基础静态类型，一种是对象类型</strong></p>
<h3 id="221基础静态类型"><a class="markdownIt-Anchor" href="#221基础静态类型"></a> 2.2.1基础静态类型</h3>
<p>基础静态类型非常简单，<strong>只要在声明变量的后边加一个<code>:</code>号，然后加上对应的类型</strong>。比如下面的代码，就是声明了一个数字类型的变量，叫做<code>count</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count : number = <span class="number">918</span>;</span><br><span class="line"><span class="keyword">const</span> myName :string = <span class="string">&#x27;jspang&#x27;</span></span><br></pre></td></tr></table></figure>
<p><code>null</code>,<code>undefinde</code>,<code>symbol</code>,<code>boolean</code>,<code>void</code>这些都是最常用的基础数据类型</p>
<h3 id="222对象类型"><a class="markdownIt-Anchor" href="#222对象类型"></a> 2.2.2对象类型</h3>
<p>新建一个文件<code>demo3.ts</code>,然后写下如下代码。</p>
<p>这就是一个经典的对象类型，也是<strong>最简单的对象类型</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xiaoJieJie: &#123;</span><br><span class="line">  name: string,</span><br><span class="line">  age: number,</span><br><span class="line">&#125; = &#123;</span><br><span class="line">  name: <span class="string">&quot;大脚&quot;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(xiaoJieJie.name);</span><br></pre></td></tr></table></figure>
<p>变量<code>xiaoJieJies</code>必须是一个数组，数组里的内容必须是字符串</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xiaoJieJies: <span class="built_in">String</span>[] = [<span class="string">&quot;谢大脚&quot;</span>, <span class="string">&quot;刘英&quot;</span>, <span class="string">&quot;小红&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> xiaoJieJies: <span class="built_in">String</span>[] = [<span class="string">&quot;谢大脚&quot;</span>, <span class="string">&quot;刘英&quot;</span>, <span class="number">123</span>];<span class="comment">//把字符串改为数字直接给我们报错</span></span><br></pre></td></tr></table></figure>
<p>现在都讲究面向对象编程,用类的形式，来定义变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> dajiao: Person = <span class="keyword">new</span> Person();<span class="comment">//这个意思就是`dajiao`必须是一个`Person`类对应的对象才可以。</span></span><br></pre></td></tr></table></figure>
<h4 id="函数类型"><a class="markdownIt-Anchor" href="#函数类型"></a> 函数类型</h4>
<p>我们还可以定义一个，并确定返回值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jianXiaoJieJie: <span class="function">() =&gt;</span> string = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;大脚&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="箭头函数"><a class="markdownIt-Anchor" href="#箭头函数"></a> 箭头函数:</h5>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">x =&gt; x * x 相当于 <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> x*x&#125;</span><br><span class="line"><span class="comment">// 两个参数返回后面的值</span></span><br><span class="line">(x, y) =&gt;x*y + y*y</span><br><span class="line"><span class="comment">//没有参数</span></span><br><span class="line">() =&gt; <span class="number">999</span></span><br><span class="line"><span class="comment">//单个参数 () 是可选的：</span></span><br><span class="line"><span class="keyword">var</span> display =（）=&gt;<span class="keyword">void</span>= <span class="function"><span class="params">x</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;output is&quot;</span>+<span class="number">2</span>)；</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可变参数</span></span><br><span class="line">(x, y, ...rest) =&gt;&#123;</span><br><span class="line">    <span class="keyword">var</span> i,sum = x+y;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;rest.length;i++)&#123;</span><br><span class="line">        sum += rest[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那我们现在总结一下对象类型可以有几种形式：</p>
<ul>
<li>对象类型</li>
<li>数组类型</li>
<li>类类型</li>
<li>函数类型</li>
</ul>
<p>这几种形式我们在<code>TypeScript</code>里叫做对象类型。</p>
<h3 id="223typescript-中的类型注释和类型推断"><a class="markdownIt-Anchor" href="#223typescript-中的类型注释和类型推断"></a> 2.2.3TypeScript 中的类型注释和类型推断</h3>
<p><code>类型注解</code>和<code>类型推断</code>，这两个概念在我们编写 TypeScript 代码时会一直使用(重点)</p>
<p>新建一个文件<code>demo4.ts</code> ,然后看代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> count: number;</span><br><span class="line">count = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>这段代码就是类型注解，显示的告诉代码，我们的**<code>count</code>变量就是一个数字类型，这就叫做<code>类型注解</code>。**</p>
<h4 id="type-inferrence-类型推断"><a class="markdownIt-Anchor" href="#type-inferrence-类型推断"></a> type inferrence 类型推断</h4>
<p>当你明白了<code>类型注解</code>的概念之后，再学类型推断就更简单了，先来看一段代码。还是在<code>Demo4.ts</code>文件中写入下面的代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> countInference = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>这时候我并没有显示的告诉你变量<code>countInference</code>是一个数字类型，<strong>但是如果你把鼠标放到变量上时，你会发现 TypeScript 自动把变量注释为了<code>number</code>（数字）类型，也就是说它是有某种推断能力的</strong>，通过你的代码 TS 会自动的去尝试分析变量的类型。这个就彷佛是人的情商比较高，还没等女生表白那，你就已经看出她的心思。</p>
<h4 id="工作使用问题潜规则"><a class="markdownIt-Anchor" href="#工作使用问题潜规则"></a> <a target="_blank" rel="noopener" href="http://www.jspang.com/detailed?id=63#toc314">工作使用问题（潜规则）</a></h4>
<ul>
<li><strong>如果 <code>TS</code> 能够自动分析变量类型， 我们就什么也不需要做了</strong></li>
<li><strong>如果 <code>TS</code> 无法分析变量类型的话， 我们就需要使用类型注解</strong></li>
</ul>
<p>一个不用写类型注解的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> one = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> two = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> three = one + two;</span><br></pre></td></tr></table></figure>
<p>一个用写类型注解的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTotal</span>(<span class="params">one, two</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> one + two;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> total = getTotal(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>这种形式，就需要用到类型注释了，<code>one</code>和<code>two</code>会显示为<code>any</code>类型。<strong>这时候如果你传字符串，你的业务逻辑就是错误的</strong>，所以你必须加一个<code>类型注解</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTotal</span>(<span class="params">one: number, two: number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> one + two;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> total = getTotal(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>这里有的一个问题是，为什么<code>total</code>这个变量不需要加类型注解，因为当<code>one</code>和<code>two</code>两个变量加上注解后，TypeScript 就可以自动通过类型推断，分析出变量的类型。</p>
<p>当然 TypeScript 也可以<strong>推断出对象中属性的类型</strong>，比如现在写一个小姐姐的对象，然后里边有两个属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> XiaoJieJie = &#123;</span><br><span class="line">  name: <span class="string">&quot;刘英&quot;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>写完后你把鼠标放在<code>XiaoJieJie</code>对象上面，就会提示出他里边的属性，这表明 TypeScript 也分析出了对象的属性的类型。</p>
<p>在写 TypeScript 代码的一个重要宗旨就是每个变量，每个对象的属性类型都应该是固定的，如果你推断就让它推断，推断不出来的时候你要进行注释。</p>
<h2 id="23typescript-函数参数和返回类型定义"><a class="markdownIt-Anchor" href="#23typescript-函数参数和返回类型定义"></a> 2.3.TypeScript 函数参数和返回类型定义</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTotal</span>(<span class="params">one: number, two: number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> one + two;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> total = getTotal(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p><strong>虽然<code>TypeScript</code>可以自己推断出返回值是<code>number</code>类型。</strong> 合适的做法是给函数的返回值加上类型注解，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTotal</span>(<span class="params">one: number, two: number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> one + two;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> total = getTotal(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>这段代码就比较严谨了，所以小伙伴们在写代码时，尽量让自己的代码更加严谨。</p>
<h3 id="231函数无返回值时定义方法"><a class="markdownIt-Anchor" href="#231函数无返回值时定义方法"></a> 2.3.1函数无返回值时定义方法</h3>
<p>这就是没有返回值的函数，我们就可以给他一个类型注解<code>void</code>，代表没有任何返回值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果这样定义后，你再加入任何返回值，程序都会报错。</p>
<h3 id="232never-返回值类型"><a class="markdownIt-Anchor" href="#232never-返回值类型"></a> 2.3.2never 返回值类型</h3>
<p>如果一个函数是<strong>永远也执行不完的</strong>，就可以定义返回值为<code>never</code>，<strong>抛出了异常</strong>，这时候就无法执行完了)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">errorFuntion</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一种是一直循环，也是<strong>我们常说的死循环</strong>，这样也运行不完，比如下面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forNever</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hello JSPang&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="233函数参数为对象解构"><a class="markdownIt-Anchor" href="#233函数参数为对象解构"></a> 2.3.3函数参数为对象(解构)？？？</h3>
<p>当一个函数的参数是对象时，我们如何定义参数对象的属性类型。我先写个一般**<code>javaScript</code>的写法**。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">&#123; one, two &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> one + two;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> total = add(&#123; <span class="attr">one</span>: <span class="number">1</span>, <span class="attr">two</span>: <span class="number">2</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>在浏览器中你会看到直接报错了，意思是<code>total</code>有可能会是任何类型，那我们要如何给这样的参数加<code>类型注解</code>那？最初你可能会这样写。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">&#123; one: number, two: number &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> one + two;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> total = add(&#123; <span class="attr">one</span>: <span class="number">1</span>, <span class="attr">two</span>: <span class="number">2</span> &#125;);<span class="comment">//one为any类型</span></span><br></pre></td></tr></table></figure>
<p>那<strong>正确的写法应该是这样的。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">&#123; one, two &#125;: &#123; one: number, two: number &#125;</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> one + two;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> three = add(&#123; <span class="attr">one</span>: <span class="number">1</span>, <span class="attr">two</span>: <span class="number">2</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>如果参数是对象，并且里边只有一个属性时，我们更容易写错。 错误代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNumber</span>(<span class="params">&#123; one &#125;: number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> one;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = getNumber(&#123; <span class="attr">one</span>: <span class="number">1</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>看着好像没什么问题，但实际这是有问题的，正确的代码应该时这样的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNumber</span>(<span class="params">&#123; one &#125;: &#123; one: number &#125;</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> one;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> one = getNumber(&#123; <span class="attr">one</span>: <span class="number">1</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>这样写才是正确的写法，小伙伴们赶快动手练习一下吧，刚开始学你可能会觉的很麻烦，但是你写的时间长了，你就会发现有规矩还是好的。人向往自由，缺鲜有人能屈驾自由。</p>
<h3 id="函数类型-2"><a class="markdownIt-Anchor" href="#函数类型-2"></a> 函数类型：</h3>
<h4 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义：</h4>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fname</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fname</span>(<span class="params"></span>) :<span class="title">return_type</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x:<span class="built_in">number</span>,y:<span class="built_in">number</span></span>):<span class="title">number</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"><span class="comment">//可选参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstname:<span class="built_in">string</span>,lastname?:<span class="built_in">string</span></span>)[:<span class="title">string</span>]</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lastname)<span class="keyword">return</span> firstname+<span class="string">&#x27; &#x27;</span>+lastname;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> firstname;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result1=buildName(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> result2=buildName(<span class="string">&quot;Bob&quot;</span>,<span class="string">&quot;Adams&quot;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result1)</span><br><span class="line"><span class="built_in">console</span>.log(result2)</span><br><span class="line"><span class="comment">//默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculate</span>(<span class="params">price:<span class="built_in">number</span>,rate:<span class="built_in">number</span>=<span class="number">0.5</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> discount=price*rate;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;结果&quot;</span>,discount);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//剩余参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName:sring,...restofNmae:<span class="built_in">string</span>[]</span>)//不知道有多少个参数</span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">addNumber</span>(<span class="params">...nums:<span class="built_in">number</span>[]</span>)</span>&#123;</span></span><br><span class="line"><span class="function">    <span class="title">var</span> <span class="title">i</span></span>;</span><br><span class="line">    <span class="keyword">var</span> sum:<span class="built_in">number</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匿名函数</span></span><br><span class="line"><span class="keyword">var</span> res=<span class="function"><span class="keyword">function</span>(<span class="params">[<span class="built_in">arguments</span>]</span>)</span>&#123;....&#125;</span><br><span class="line"><span class="comment">/*匿名函数是一个没有函数名的函数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">匿名函数在程序运行时动态声明，除了没有函数名外，其他的与标准函数一样。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">我们可以将匿名函数赋值给一个变量，这种表达式就成为函数表达式。*/</span></span><br><span class="line"><span class="keyword">var</span> msg = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(msg())</span><br><span class="line"><span class="keyword">var</span> res = <span class="function"><span class="keyword">function</span>(<span class="params">a:<span class="built_in">number</span>,b:<span class="built_in">number</span></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> a*b;  </span><br><span class="line">&#125;; </span><br><span class="line"><span class="built_in">console</span>.log(res(<span class="number">12</span>,<span class="number">2</span>))</span><br><span class="line"><span class="comment">//构造函数TypeScript 也支持使用 JavaScript 内置的构造函数 Function() 来定义函数：</span></span><br><span class="line"><span class="keyword">var</span> myFunction = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;return a * b&quot;</span>); </span><br><span class="line"><span class="keyword">var</span> x = myFunction(<span class="number">4</span>, <span class="number">3</span>); </span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"><span class="comment">//Lambda 函数 箭头函数</span></span><br><span class="line">( [param1, parma2,…param n] )=&gt;statement;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="function">(<span class="params">x:<span class="built_in">number</span></span>)=&gt;</span><span class="number">10</span> + x </span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">100</span>))      <span class="comment">//输出结果为 110</span></span><br></pre></td></tr></table></figure>
<h2 id="24typescript-中数组类型的定义"><a class="markdownIt-Anchor" href="#24typescript-中数组类型的定义"></a> 2.4.TypeScript 中数组类型的定义</h2>
<h3 id="241一般数组类型的定义"><a class="markdownIt-Anchor" href="#241一般数组类型的定义"></a> 2.4.1一般数组类型的定义</h3>
<p>定义一个最简单的数组类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numberArr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p>这时候你把鼠标放在<code>numberArr</code>上面可以看出，这个数组的类型就是 number 类型。这是 TypeScript 通过<code>类型推断</code>自己推断出来的。 如果你要显示的注解，也非常简单，可以写成下面的形式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numberArr: number[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> undefinedArr:<span class="literal">undefined</span>[]=[<span class="literal">undefined</span>,<span class="literal">undefined</span>]</span><br><span class="line"><span class="keyword">const</span> stringArr: string[] = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>];</span><br></pre></td></tr></table></figure>
<h3 id="242多类型数组"><a class="markdownIt-Anchor" href="#242多类型数组"></a> 2.4.2多类型数组</h3>
<p>只要加个<code>()</code>，然后在里边加上<code>|</code>就可以了，具体</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr: (number | string)[] = [<span class="number">1</span>, <span class="string">&quot;string&quot;</span>, <span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<h3 id="243数组中对象类型"><a class="markdownIt-Anchor" href="#243数组中对象类型"></a> 2.4.3数组中对象类型</h3>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xiaoJieJies: &#123; <span class="attr">name</span>: string, <span class="attr">age</span>: <span class="built_in">Number</span> &#125;[] = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;刘英&quot;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;谢大脚&quot;</span>, <span class="attr">age</span>: <span class="number">28</span> &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>这种形式看起来比较麻烦，而且如果有同样类型的数组，写代码也比较麻烦，TypeScript 为我们准备了一个概念，叫做**<code>类型别名</code>(type alias)。**</p>
<h4 id="2431类型别名"><a class="markdownIt-Anchor" href="#2431类型别名"></a> 2.4.3.1类型别名</h4>
<p><strong>以<code>type</code>关键字开始。现在定义一个<code>Lady</code>的别名。</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Lady = &#123; <span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">age</span>: <span class="built_in">Number</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> xiaoJieJies: Lady[] = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;刘英&quot;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;谢大脚&quot;</span>, <span class="attr">age</span>: <span class="number">28</span> &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>这时候有的小伙伴就会问了，我用类进行定义可以吗？答案是可以的，比如我们定义一个<code>Madam</code>的类,然后用这个类来限制数组的类型也是可以的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Madam</span> </span>&#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> xiaoJieJies: Madam[] = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;刘英&quot;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;谢大脚&quot;</span>, <span class="attr">age</span>: <span class="number">28</span> &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<h2 id="25元组的使用和类型约束"><a class="markdownIt-Anchor" href="#25元组的使用和类型约束"></a> 2.5元组的使用和类型约束</h2>
<p>TypeScript 中提供了<code>元组</code>的概念，这个概念是<code>JavaScript</code>中没有的。但是不要慌张，其实元组在开发中并不常用。一般只在**数据源是<code>CVS</code>这种文件的时候，会使用元组。**其实你可以把元组看成数组的一个加强，它可以更好的控制或者说规范里边的类型。</p>
<h3 id="251元组的基本应用"><a class="markdownIt-Anchor" href="#251元组的基本应用"></a> 2.5.1元组的基本应用</h3>
<p>我们先来看一个数组和这个数组注解的缺点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xiaojiejie = [<span class="string">&quot;dajiao&quot;</span>, <span class="string">&quot;teacher&quot;</span>, <span class="number">28</span>];</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xiaojiejie: (string | number)[] = [<span class="string">&quot;dajiao&quot;</span>, <span class="number">28</span>, <span class="string">&quot;teacher&quot;</span>];</span><br></pre></td></tr></table></figure>
<p>**简单的把数组中的位置调换了一下，但是<code>TypeScript</code>并不能发现问题，**这时候我们需要一个更强大的类型，来解决这个问题，这就是元组。</p>
<p>元组和数组类似，但是类型注解时会不一样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xiaojiejie: [string, string, number] = [<span class="string">&quot;dajiao&quot;</span>, <span class="string">&quot;teacher&quot;</span>, <span class="number">28</span>];</span><br></pre></td></tr></table></figure>
<p>这时候我们就把数组中的<strong>每个元素类型的位置给固定住了，这就叫做元组。</strong></p>
<h3 id="252元组的使用"><a class="markdownIt-Anchor" href="#252元组的使用"></a> 2.5.2元组的使用</h3>
<p>目前我的工作中不经常使用元组，因为如果要使用元组，完全可以使用对象的形式来代替，**但是如果你维护老系统，你会发现有一种数据源时<code>CSV</code>,这种文件提供的就是用逗号隔开的，如果要严谨的编程就需要用到元组了。**例如我们有这样一组由<code>CSV</code>提供的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;dajiao&quot;, &quot;teacher&quot;, 28;</span><br><span class="line">&quot;liuying&quot;, &quot;teacher&quot;, 18;</span><br><span class="line">&quot;cuihua&quot;, &quot;teacher&quot;, 25;</span><br></pre></td></tr></table></figure>
<p>如果数据源得到的数据时这样的，你就可以使用元组了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xiaojiejies: [string, string, number][] = [</span><br><span class="line">  [<span class="string">&quot;dajiao&quot;</span>, <span class="string">&quot;teacher&quot;</span>, <span class="number">28</span>],</span><br><span class="line">  [<span class="string">&quot;liuying&quot;</span>, <span class="string">&quot;teacher&quot;</span>, <span class="number">18</span>],</span><br><span class="line">  [<span class="string">&quot;cuihua&quot;</span>, <span class="string">&quot;teacher&quot;</span>, <span class="number">25</span>],</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<h2 id="26typescript-的-interface-接口"><a class="markdownIt-Anchor" href="#26typescript-的-interface-接口"></a> 2.6TypeScript 的 interface 接口</h2>
<p>就是不符合要求的会直接被筛选掉，那最好的解决方法就是写一个接口。TypeScript 中的接口，就是用来规范类型的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> screenResume = <span class="function">(<span class="params">name: string, age: number, bust: number</span>) =&gt;</span> &#123;</span><br><span class="line">  age &lt; <span class="number">24</span> &amp;&amp; bust &gt;= <span class="number">90</span> &amp;&amp; <span class="built_in">console</span>.log(name + <span class="string">&quot;进入面试&quot;</span>);</span><br><span class="line">  age &gt; <span class="number">24</span> || (bust &lt; <span class="number">90</span> &amp;&amp; <span class="built_in">console</span>.log(name + <span class="string">&quot;你被淘汰&quot;</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">screenResume(<span class="string">&quot;大脚&quot;</span>, <span class="number">18</span>, <span class="number">94</span>);</span><br><span class="line"><span class="keyword">const</span> getResume = <span class="function">(<span class="params">name: string, age: number, bust: number</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name + <span class="string">&quot;年龄是：&quot;</span> + age);</span><br><span class="line">  <span class="built_in">console</span>.log(name + <span class="string">&quot;胸围是：&quot;</span> + bust);</span><br><span class="line">&#125;;</span><br><span class="line">getResume(<span class="string">&quot;大脚&quot;</span>, <span class="number">18</span>, <span class="number">94</span>);</span><br></pre></td></tr></table></figure>
<p>写好后，好像我们的程序写的不错，可以在终端中使用<code>ts-node demo8.ts</code>进行查看。这时候老板又增加了需求，说我必须能看到这些女孩的简历。于是你又写了这样一个方法。</p>
<p>这时候问题来了，<strong>程序开发中一直强调“代码重用”</strong>，两个方法用的类型注解一样，需要作个统一的约束。大上节课我们学了一个<code>类型别名</code>的知识可以解决代码重复的问题，这节课我们就学习一个更常用的语法</p>
<h3 id="261接口interface"><a class="markdownIt-Anchor" href="#261接口interface"></a> 2.6.1<code>接口</code>（Interface）.</h3>
<p>我们**可以把这两个重复的类型注解，定义成统一的接口。**代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface Girl &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">  bust: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了接口后，我们的程序也要作一些修改，需要写成下面的样子。这样就更像是面向对象编程了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> screenResume = <span class="function">(<span class="params">girl: Girl</span>) =&gt;</span> &#123;</span><br><span class="line">  girl.age &lt; <span class="number">24</span> &amp;&amp; girl.bust &gt;= <span class="number">90</span> &amp;&amp; <span class="built_in">console</span>.log(girl.name + <span class="string">&quot;进入面试&quot;</span>);</span><br><span class="line">  girl.age &gt; <span class="number">24</span> || (girl.bust &lt; <span class="number">90</span> &amp;&amp; <span class="built_in">console</span>.log(girl.name + <span class="string">&quot;你被淘汰&quot;</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getResume = <span class="function">(<span class="params">girl: Girl</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(girl.name + <span class="string">&quot;年龄是：&quot;</span> + girl.age);</span><br><span class="line">  <span class="built_in">console</span>.log(girl.name + <span class="string">&quot;胸围是：&quot;</span> + girl.bust);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> girl = &#123;</span><br><span class="line">  name: <span class="string">&quot;大脚&quot;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  bust: <span class="number">94</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">screenResume(girl);</span><br><span class="line">getResume(girl);</span><br></pre></td></tr></table></figure>
<p>这时候我们代码就显得专业了很多，以后再用到同样的接口也不怕了，直接使用<code>girl</code>就可以了。</p>
<h3 id="262接口和类型别名的区别"><a class="markdownIt-Anchor" href="#262接口和类型别名的区别"></a> 2.6.2接口和类型别名的区别</h3>
<p>现在我们学了<code>接口</code>，也学过了<code>类型别名</code>，这两个语法用起来基本一样，但是也有少许的不同。</p>
<blockquote>
<p>类型别名可以直接给类型，比如<code>string</code>，而接口必须代表对象。</p>
</blockquote>
<p>比如我们的<code>类型别名</code>可以写出下面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Girl1 = stirng;</span><br></pre></td></tr></table></figure>
<p>但是接口就不能这样写，<strong>它必须代表的是一个对象，也就是</strong>说，你初始化<code>girl</code>的时候，必须写出下面的形式.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> girl = &#123;</span><br><span class="line">  name: <span class="string">&quot;大脚&quot;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  bust: <span class="number">94</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="263接口非必选值得定义"><a class="markdownIt-Anchor" href="#263接口非必选值得定义"></a> 2.6.3接口非必选值得定义</h3>
<p>这节课我们多学一点，因为接口这里的知识点还是挺多的。比如这时候增加可选项，那接口如何定义那？其实<code>typeScript</code>已经为我们准备好了相应的办法，就是在<code>:</code>号前加一个<code>?</code></p>
<p>比如把<code>Girl</code>的接口写成这样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Girl &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">  bust: number;</span><br><span class="line">  waistline?: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们再修改一下<code>getResume</code>方法，写成这样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getResume = <span class="function">(<span class="params">girl: Girl</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(girl.name + <span class="string">&quot;年龄是：&quot;</span> + girl.age);</span><br><span class="line">  <span class="built_in">console</span>.log(girl.name + <span class="string">&quot;胸围是：&quot;</span> + girl.bust);</span><br><span class="line">  girl.waistline &amp;&amp; <span class="built_in">console</span>.log(girl.name + <span class="string">&quot;腰围是：&quot;</span> + girl.waistline);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这时候在定义<code>girl</code>对象的时候，就可以写<code>saistline</code>（腰围），也可以不写了。</p>
<h3 id="264允许加入任意值"><a class="markdownIt-Anchor" href="#264允许加入任意值"></a> 2.6.4允许加入任意值</h3>
<p>简历一般是有自由发挥的空间的，所以这时候需要一些任意值，就是自己愿意写什么就写什么。这时候<code>interface</code>接口也是支持的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Girl &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">  bust: number;</span><br><span class="line">  waistline?: number;</span><br><span class="line">  [propname: string]: any;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个的意思是，属性的名字是字符串类型，属性的值可以是任何类型。</p>
<p>这时候我们在对象里给一个性别,代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> girl = &#123;</span><br><span class="line">  name: <span class="string">&quot;大脚&quot;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  bust: <span class="number">94</span>,</span><br><span class="line">  waistline: <span class="number">21</span>,</span><br><span class="line">  sex: <span class="string">&quot;女&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>再修改一下代码，这首就没有错误了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getResume = <span class="function">(<span class="params">girl: Girl</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(girl.name + <span class="string">&quot;年龄是：&quot;</span> + girl.age);</span><br><span class="line">  <span class="built_in">console</span>.log(girl.name + <span class="string">&quot;胸围是：&quot;</span> + girl.bust);</span><br><span class="line">  girl.waistline &amp;&amp; <span class="built_in">console</span>.log(girl.name + <span class="string">&quot;腰围是：&quot;</span> + girl.waistline);</span><br><span class="line">  girl.sex &amp;&amp; <span class="built_in">console</span>.log(girl.name + <span class="string">&quot;性别是：&quot;</span> + girl.sex);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这时候我们的程序是不报错的，但是如果我们去掉刚才的设置，就会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[propname:string]:any;  <span class="comment">//去掉</span></span><br></pre></td></tr></table></figure>
<h3 id="265接口里的方法"><a class="markdownIt-Anchor" href="#265接口里的方法"></a> 2.6.5接口里的方法</h3>
<p>接口里不仅可以存属性，还可以存方法，比如这时候有个<code>say()</code>方法，返回值是<code>string</code>类型。这时候你就不要再想成简历了，你需要更面向对象化的编程，想象成一个人。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Girl &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">  bust: number;</span><br><span class="line">  waistline?: number;</span><br><span class="line">  [propname: string]: any;</span><br><span class="line">  say(): string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加上这个<code>say()</code>方法后，程序马上就会报错，因为我们对象里没有 say 方法。那我们就要给对象一个 say 方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> girl = &#123;</span><br><span class="line">  name: <span class="string">&quot;大脚&quot;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  bust: <span class="number">94</span>,</span><br><span class="line">  waistline: <span class="number">21</span>,</span><br><span class="line">  sex: <span class="string">&quot;女&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;欢迎光临 ，红浪漫洗浴！！&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="266接口和类的约束"><a class="markdownIt-Anchor" href="#266接口和类的约束"></a> 2.6.6接口和类的约束</h3>
<p>我们都知道 JavaScript 从<code>ES6</code>里是有类这个概念的，<strong>类可以和接口很好的结合</strong>，我们先来看一个例子。下面的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaoJieJie</span> <span class="title">implements</span> <span class="title">Girl</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这时候类会直接报错，所以我们需要把这个类写的完全点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaoJieJie</span> <span class="title">implements</span> <span class="title">Girl</span> </span>&#123;</span><br><span class="line">  name = <span class="string">&quot;刘英&quot;</span>;</span><br><span class="line">  age = <span class="number">18</span>;</span><br><span class="line">  bust = <span class="number">90</span>;</span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;欢迎光临 ，红浪漫洗浴！！&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="267接口间的继承"><a class="markdownIt-Anchor" href="#267接口间的继承"></a> 2.6.7接口间的继承</h3>
<p>接口也可以用于继承的，比如你新写一个<code>Teacher</code>接口，继承于<code>Person</code>接口。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Teacher <span class="keyword">extends</span> Girl &#123;</span><br><span class="line">  teach(): string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如这时候老板说了，只看 Teacher 级别的简历，那我们需要修改<code>getResume()</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getResume = <span class="function">(<span class="params">girl: Teacher</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(girl.name + <span class="string">&quot;年龄是：&quot;</span> + girl.age);</span><br><span class="line">  <span class="built_in">console</span>.log(girl.name + <span class="string">&quot;胸围是：&quot;</span> + girl.bust);</span><br><span class="line">  girl.waistline &amp;&amp; <span class="built_in">console</span>.log(girl.name + <span class="string">&quot;腰围是：&quot;</span> + girl.waistline);</span><br><span class="line">  girl.sex &amp;&amp; <span class="built_in">console</span>.log(girl.name + <span class="string">&quot;性别是：&quot;</span> + girl.sex);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>修改后，你就会发现下面我们调用<code>getResume()</code>方法的地方报错了,因为这时候传的值必须有<code>Teach</code>方法，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getResume(girl);</span><br></pre></td></tr></table></figure>
<p>修改<code>girle</code>对象，增加<code>teach（）</code>方法，这时候就不会报错了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> girl = &#123;</span><br><span class="line">  name: <span class="string">&quot;大脚&quot;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  bust: <span class="number">94</span>,</span><br><span class="line">  waistline: <span class="number">21</span>,</span><br><span class="line">  sex: <span class="string">&quot;女&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;欢迎光临 ，红浪漫洗浴！！&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">teach</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;我是一个老师&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>关于接口的知识就讲到这里吧，这基本包含了接口 80%的知识，还有些基本不用的语法，我就不讲了。如果课程中遇到，我们再讲。学会了接口，你还需要明白一件事，<strong>就是接口只是对我们开发的约束，在生产环境中并没有体现。</strong></p>
<h2 id="27typescript-中类的概念和使用"><a class="markdownIt-Anchor" href="#27typescript-中类的概念和使用"></a> 2.7TypeScript 中类的概念和使用</h2>
<p>TypeScript 中类的概念和 ES6 中原生类的概念大部分相同，但是也额外增加了一些新的特性。</p>
<h3 id="271类的基本使用"><a class="markdownIt-Anchor" href="#271类的基本使用"></a> 2.7.1类的基本使用</h3>
<p>新建一个文件，叫做**<code>demo10.ts</code>,**然后定义一个最简单的<code>Lady</code>类,这里要使用关键字<code>class</code>,类里边有姓名属性和一个得到姓名的方法，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lady</span> </span>&#123;</span><br><span class="line">  content = <span class="string">&quot;Hi，帅哥&quot;</span>;</span><br><span class="line">  <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.content;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> goddess = <span class="keyword">new</span> Lady();</span><br><span class="line"><span class="built_in">console</span>.log(goddess.sayHello());</span><br></pre></td></tr></table></figure>
<p>这是一个最简单的类了，如果你有些编程经验，对这个一定很熟悉，工作中几乎每天都会用到。</p>
<h3 id="272类的继承"><a class="markdownIt-Anchor" href="#272类的继承"></a> 2.7.2类的继承</h3>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lady</span> </span>&#123;</span><br><span class="line">  content = <span class="string">&quot;Hi，帅哥&quot;</span>;</span><br><span class="line">  <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.content;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaoJieJie</span> <span class="keyword">extends</span> <span class="title">Lady</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">sayLove</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;I love you&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> goddess = <span class="keyword">new</span> XiaoJieJie();</span><br><span class="line"><span class="built_in">console</span>.log(goddess.sayHello());</span><br><span class="line"><span class="built_in">console</span>.log(goddess.sayLove());</span><br></pre></td></tr></table></figure>
<p>类写好以后，我们声明的对象是<code>XiaoJieJie</code>这个类，我们同时执行<code>sayHello()</code>和<code>sayLove()</code>都是可以执行到的，这说明继承起作用了。</p>
<h3 id="273类的重写"><a class="markdownIt-Anchor" href="#273类的重写"></a> 2.7.3类的重写</h3>
<p>讲了继承，那就必须继续讲讲<code>重写</code>，重写就是子类可以重新编写父类里边的代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaoJieJie</span> <span class="keyword">extends</span> <span class="title">Lady</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">sayLove</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;I love you!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hi , honey!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们再次运行<code>ts-node demo10.ts</code>来查看结果。</p>
<h3 id="274super-关键字的使用"><a class="markdownIt-Anchor" href="#274super-关键字的使用"></a> 2.7.4super 关键字的使用</h3>
<p>我们再多讲一点，就是<code>super</code>关键字的使用，比如我们还是想使用<code>Lady</code>类中说的话，但是在后面，加上<code>你好</code>两个字就可以了。这时候就可以使用<code>super</code>关键字，它代表父类中的方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaoJieJie</span> <span class="keyword">extends</span> <span class="title">Lady</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">sayLove</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;I love you!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.sayHello() + <span class="string">&quot;。你好！&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="275typescript-中类的访问类型"><a class="markdownIt-Anchor" href="#275typescript-中类的访问类型"></a> 2.7.5TypeScript 中类的访问类型</h3>
<p>其实类的访问类型就是基于三个关键词<code>private</code>、<code>protected</code>和<code>public</code>,也是三种访问类型</p>
<p>1.先写一个简单的类</p>
<p>我们新建一个<code>Demo11.ts</code>文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  name: string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.name = <span class="string">&quot;jspang.com&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name);</span><br></pre></td></tr></table></figure>
<p>结果会打印出<code>jspang.com</code>。因为我们如果不在类里对<code>name</code>的访问属性进行定义，那么它就会默认是</p>
<h4 id="2public访问属性-外部使用"><a class="markdownIt-Anchor" href="#2public访问属性-外部使用"></a> 2.<code>public</code>访问属性。(外部使用)</h4>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    public name:string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    public name:string;</span><br><span class="line">    public <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;say Hello&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-------以下属于类的外部--------</span></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person()</span><br><span class="line">person.name = <span class="string">&#x27;jspang.com&#x27;</span> <span class="comment">//没有赋值默认是undefined</span></span><br><span class="line">person.sayHello()</span><br><span class="line"><span class="built_in">console</span>.log(person.name)</span><br></pre></td></tr></table></figure>
<h4 id="3private-访问属性内部使用继承不行"><a class="markdownIt-Anchor" href="#3private-访问属性内部使用继承不行"></a> 3.private 访问属性（内部使用继承不行）</h4>
<blockquote>
<p>private 访问属性的意思是，只允许再类的内部被调用，外部不允许调用</p>
</blockquote>
<p>比如现在我们把 name 属性改成<code>private</code>,这时候在类的内部使用不会提示错误，而外部使用<code>VSCode</code>直接会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    private name:string;</span><br><span class="line">    public <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;say Hello&#x27;</span>)  <span class="comment">//此处不报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-------以下属于类的外部--------</span></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person()</span><br><span class="line">person.name = <span class="string">&#x27;jspang.com&#x27;</span>    <span class="comment">//此处报错</span></span><br><span class="line">person.sayHello()</span><br><span class="line"><span class="built_in">console</span>.log(person.name)  <span class="comment">//此处报错</span></span><br></pre></td></tr></table></figure>
<h4 id="4protected-访问属性继承无法使用"><a class="markdownIt-Anchor" href="#4protected-访问属性继承无法使用"></a> 4.protected 访问属性（继承无法使用）</h4>
<blockquote>
<p>protected 允许在类内及继承的子类中使用</p>
</blockquote>
<p>做一个例子，把<code>name</code>的访问属性换成<code>protected</code>,<strong>这时候外部调用<code>name</code>的代码会报错，内部的不会报错</strong>，和<code>private</code>一样。这时候我们再写一个<code>Teacher</code>类，继承于<code>Person</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    protected name:string;</span><br><span class="line">    public <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;say Hello&#x27;</span>)  <span class="comment">//此处不报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    public <span class="function"><span class="title">sayBye</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候在子类中使用<code>this.name</code>是不报错的。</p>
<h3 id="276typescript-类的构造函数"><a class="markdownIt-Anchor" href="#276typescript-类的构造函数"></a> 2.7.6TypeScript 类的构造函数</h3>
<p>构造函数就是在类被初始化的时候，自动执行的一个方法。我们通过这个构造方法经常作很多需要提前完成的工作，比如显示页面前我们要从后台得到数据。直接看例子。</p>
<h4 id="2761类的构造函数"><a class="markdownIt-Anchor" href="#2761类的构造函数"></a> 2.7.6.1类的构造函数</h4>
<p>新建立一个页面<code>Demo12.ts</code>,然后在页面里新建一个 Person 类，类的里边定义一个<code>name</code>，但是<code>name</code>我们并不给他值,然后我们希望在<code>new</code>出对象的时候，直接通过传递参数的形式，给<code>name</code>赋值，并打印出来。这时候我们就需要用到构造函数了，构造函数的关键字是<code>constructor</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    public name :string ;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name:string</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person= <span class="keyword">new</span> Person(<span class="string">&#x27;jspang&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.name)</span><br></pre></td></tr></table></figure>
<p>这是最常规和好理解的写法，那有没有更简单的写法那?当然有。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">public name:string</span>)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person= <span class="keyword">new</span> Person(<span class="string">&#x27;jspang&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.name)</span><br></pre></td></tr></table></figure>
<p>这种写法就相当于**你定义了一个<code>name</code>,然后在构造函数里进行了赋值，**这是一种简化的语法.</p>
<h4 id="2762类继承中的构造器"><a class="markdownIt-Anchor" href="#2762类继承中的构造器"></a> 2.7.6.2类继承中的构造器</h4>
<p>普通类的构造器我们已经会了，在子类中使用构造函数需要<strong>用<code>super()</code>调用父类的构造函数。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">public name:string</span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">public age:number</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&#x27;jspang&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> teacher = <span class="keyword">new</span> Teacher(<span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(teacher.age)</span><br><span class="line"><span class="built_in">console</span>.log(teacher.name)</span><br></pre></td></tr></table></figure>
<p>这就是子类继承父类并有构造函数的原则，就是在子类里写构造函数时，必须<strong>用<code>super()</code>调用父类的构造函数，第一句</strong>如果需要传值，也必须进行传值操作。就是是父类没有构造函数，子类也要使用<code>super()</code>进行调用，否则就会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">public age:number</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> teacher = <span class="keyword">new</span> Teacher(<span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(teacher.age)</span><br></pre></td></tr></table></figure>
<p>好了，这就是这节课我们所学的内容了，主要讲的就是类中的构造函数（也有叫构造器的）</p>
<h2 id="28类第二步"><a class="markdownIt-Anchor" href="#28类第二步"></a> 2.8类第二步</h2>
<h3 id="281类的getter-setter-和-static"><a class="markdownIt-Anchor" href="#281类的getter-setter-和-static"></a> 2.8.1类的Getter、Setter 和 static</h3>
<p>通过 Getter 和 Setter 的形式来访问和修改private属性。</p>
<h4 id="2811类的-getter-和-setter"><a class="markdownIt-Anchor" href="#2811类的-getter-和-setter"></a> 2.8.1.1类的 Getter 和 Setter</h4>
<p>我们新建一个文件<code>Demo13.ts</code>，然后声明一个<code>XiaoJieJie</code>（小姐姐）类，都知道小姐姐的年龄是不能随便告诉人，所以使用了<code>private</code>,这样别人就都不知道她的真实年龄，而只有她自己知道。</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Xiaojiejie</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">private _age:number</span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>就必须通过<code>getter</code>属性知道,注意我这里用的是属性，对他就是一个属性。<code>getter</code>属性的关键字是<code>get</code></strong>,后边跟着类似方法的东西,但是你要注意，它并不是方法，归根到底还是属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Xiaojiejie</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">private _age:number</span>)</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">age</span>()&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>._age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dajiao = <span class="keyword">new</span> Xiaojiejie(<span class="number">28</span>)</span><br><span class="line"><span class="built_in">console</span>.log(dajiao.getAge)</span><br></pre></td></tr></table></figure>
<p>比如别人问的时候我们就偷摸的减少 10 岁。代码可以写成这样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Xiaojiejie</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">private _age:number</span>)</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">age</span>()&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>._age-<span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候大脚的年龄就编程了迷人的 18 岁，是不是通过这个小例子，一下子就明白了<code>private</code>和<code>getter</code>的用处。 <code>_age</code>是私有的，那类的外部就没办法改变，所以这时候可以用<code>setter</code>属性进行改变，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Xiaojiejie</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">private _age:number</span>)</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">age</span>()&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>._age-<span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">age</span>(<span class="params">age:number</span>)&#123;</span><br><span class="line">    <span class="built_in">this</span>._age=age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dajiao = <span class="keyword">new</span> Xiaojiejie(<span class="number">28</span>)</span><br><span class="line">dajiao.age=<span class="number">25</span></span><br><span class="line"><span class="built_in">console</span>.log(dajiao.age)</span><br></pre></td></tr></table></figure>
<p>其实<code>setter</code>也是可以保护私有变量的，现在大脚的年龄输出是 15 岁，这肯定不行，不符合法律哦，这样是我们在<code>setter</code>里给他加上个 3 岁，就可以了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="title">age</span>(<span class="params">age:number</span>)&#123;</span><br><span class="line">   <span class="built_in">this</span>._age=age+<span class="number">3</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2812类中的-static"><a class="markdownIt-Anchor" href="#2812类中的-static"></a> 2.8.1.2类中的 static</h4>
<p>学习类，都知道要想使用这个类的实例，就要先<code>New</code>出来（），但有时候人们就是喜欢走捷径，有没有方法？肯定是有方法的。</p>
<p>比如我们先写一下最常规的写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Girl</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">sayLove</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;I Love you&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> girl = <span class="keyword">new</span> Girl();</span><br><span class="line"><span class="built_in">console</span>.log(girl.sayLove());</span><br></pre></td></tr></table></figure>
<p>但是现在你<strong>不想<code>new</code>出对象，而直接使用这个方法，那</strong><code>TypeScript</code>为你提供了快捷的方式，用<code>static</code>声明的属性和方法，不需要进行声明对象，就可以直接使用，代码如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Girl</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">sayLove</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;I Love you&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Girl.sayLove());</span><br></pre></td></tr></table></figure>
<h3 id="282类的只读属性和抽象类"><a class="markdownIt-Anchor" href="#282类的只读属性和抽象类"></a> 2.8.2类的只读属性和抽象类</h3>
<p>这节主要讲一下类里的一个概念就是抽象类，抽象类很父类很像，都需要继承，但是抽象类里一般都有抽象方法。继承抽象类的类必须实现抽象方法才可以。那就是类里的只读属性<code>readonly</code>.</p>
<h4 id="2822类里的只读属性-readonly"><a class="markdownIt-Anchor" href="#2822类里的只读属性-readonly"></a> 2.8.2.2类里的只读属性 readonly</h4>
<p>新建一个文件<code>Demo14.ts</code>,然后写下面一个类，并进行实例化和赋值操作，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">public name:string </span>)</span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">&#x27;jspang&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.name)</span><br></pre></td></tr></table></figure>
<p>写完后我们可以在终端(Terminal)中看一下结果,结果就应该是<code>jspang</code>。</p>
<p>就是在<strong>实例化对象时赋予的名字，以后不能再更改了</strong>，也就是我们常说的<strong>只读</strong>属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">public name:string </span>)</span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">&#x27;jspang&#x27;</span>)</span><br><span class="line">person.name= <span class="string">&#x27;谢广坤&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name)</span><br></pre></td></tr></table></figure>
<p>这时候就可以用一个关键词<code>readonly</code>,也就是**只读的意思，**来修改<code>Person</code>类代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    public readonly _name :string;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name:string </span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>._name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">&#x27;jspang&#x27;</span>)</span><br><span class="line">person._name= <span class="string">&#x27;谢广坤&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(person._name)</span><br></pre></td></tr></table></figure>
<p>这样写完后，<code>VSCode</code>就回直接给我们报错，告诉我们<code>_name</code>属性是只读属性，不能修改。</p>
<h4 id="2823抽象类的使用"><a class="markdownIt-Anchor" href="#2823抽象类的使用"></a> 2.8.2.3抽象类的使用</h4>
<p>什么是抽象类那？服务员，有初级技师，高级技师，每一个岗位我都写成一个类，那代码就是这样的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waiter</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseTeacher</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">seniorTeacher</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>每个职位的技能有不同，这时候就可以用抽象类来解决问题。抽象类的关键词是<code>abstract</code>,里边的抽象方法也是<code>abstract</code>开头的，现在我们就写一个<code>Girl</code>的抽象类。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">Girl</span></span>&#123;</span><br><span class="line">    abstract skill()  </span><br><span class="line">    <span class="comment">//因为没有具体的方法，所以我们这里不写括号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了这个抽象类，三个类就可以继承这个类，然后会要求必须实现<code>skill()</code>方法，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">Girl</span></span>&#123;</span><br><span class="line">    abstract skill()  <span class="comment">//因为没有具体的方法，所以我们这里不写括号</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waiter</span> <span class="keyword">extends</span> <span class="title">Girl</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">skill</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;大爷，请喝水！&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseTeacher</span> <span class="keyword">extends</span> <span class="title">Girl</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">skill</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;大爷，来个泰式按摩吧！&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">seniorTeacher</span> <span class="keyword">extends</span> <span class="title">Girl</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">skill</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;大爷，来个SPA全身按摩吧！&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我希望通过这个例子，你能对抽象类和抽象方法有一个比较深的认识。</p>
<h1 id="3tsconfigjson文件"><a class="markdownIt-Anchor" href="#3tsconfigjson文件"></a> 3.<code>tsconfig.json</code>文件</h1>
<h2 id="31配置文件-初识-tsconfigjson"><a class="markdownIt-Anchor" href="#31配置文件-初识-tsconfigjson"></a> 3.1配置文件-初识 tsconfig.json</h2>
<p>有人在 QQ 群里留言问我<code>tsconfig.json</code>是作什么的，我才意识到，我是应该详细的讲一下这个文件了，这个是 TypeScript 的文件。</p>
<h3 id="311生成-tsconfigjson-文件"><a class="markdownIt-Anchor" href="#311生成-tsconfigjson-文件"></a> 3.1.1生成 tsconfig.json 文件</h3>
<p><strong>打开终端<code>Terminal</code>,输入<code>tsc --init</code>。</strong></p>
<p>输入完成后，就会出现<code>tsconfig.json</code>文件，你可以打开简单的看一下，不过此时你可能看不懂。</p>
<p>其实它就是用来配置如何对<code>ts</code>文件进行编译的，我们都叫它 typescript 的编译配置文件。</p>
<h3 id="312让-tsconfigjson-文件生效"><a class="markdownIt-Anchor" href="#312让-tsconfigjson-文件生效"></a> 3.1.2让 tsconfig.json 文件生效</h3>
<p>你现在可以在文件夹跟目录建立一个<code>demo.ts</code>文件，然后编写一些最简单的代码，代码如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person: string = <span class="string">&quot;jspang&quot;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>用<code>tsc demo.ts</code>进行编译</strong>，编译后会得到<code>demo.js</code>文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="string">&quot;jspang&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>这时候好像一切都是正常的，但是我要告诉你的真相是<code>tsconfig.json</code>这个编译配置文件并没有生效。</p>
<p>此时我们打开<code>tsconfig.json</code>文件，找到<code>complilerOptions</code>属性下的<code>removeComments:true</code>选项，把注释去掉。</p>
<p>这个配置项的意思是，编译时不显示注释，也就是<strong>编译出来的<code>js</code>文件不显示注释内容。</strong></p>
<p>现在你在文件中加入一些注释，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// I love jspang</span></span><br><span class="line"><span class="keyword">const</span> person: string = <span class="string">&quot;jspang&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>这时候再运行编译代码<code>tsc demo.ts</code>，编译后打开<code>demo.js</code>文件，你会发现注释依然存在，<strong>说明<code>tsconfig.json</code>文件没有起作用。</strong></p>
<p><strong>如果要想编译配置文件起作用，我们可以直接运行<code>tsc</code>命令，这时候<code>tsconfig.json</code>才起作用，可以看到生成的<code>js</code>文件已经不带注释了。</strong></p>
<h3 id="313include-exclude-和-files解决单个编译的问题"><a class="markdownIt-Anchor" href="#313include-exclude-和-files解决单个编译的问题"></a> 3.1.3include 、exclude 和 files解决单个编译的问题</h3>
<p><strong>多个<code>ts</code>文件，我们却只想编译其中的一个文件时，</strong></p>
<p>我们在项目根目录，新建一个文件<code>demo2.ts</code>文件，然后也写一段最简单的 ts 代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person2: string = <span class="string">&quot;jspang.com&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>如果这时候我们在终端里运行<code>tsc</code>,虽然<code>tsconfig.json</code>生效了，但是两个文件都被我们编译了。这不是你想要的结果，我们可以用三种办法解决这个问题。</p>
<h4 id="一使用-include-配置"><a class="markdownIt-Anchor" href="#一使用-include-配置"></a> 一：使用 include 配置</h4>
<p><code>include</code>属性是用来指定要编译的文件的，</p>
<p>写配置文件时有个坑需要注意，就是配置文件<strong>不支持单引号，所以里边都要使用双引号。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;include&quot;</span>:[<span class="string">&quot;demo.ts&quot;</span>],</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">      <span class="comment">//any something</span></span><br><span class="line">      <span class="comment">//........</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候再编译，就只编译<code>demo.ts</code>文件了。</p>
<h4 id="二使用-exclude-配置"><a class="markdownIt-Anchor" href="#二使用-exclude-配置"></a> 二：使用 exclude 配置</h4>
<p><code>include</code>是包含的意思，<code>exclude</code>是<strong>不包含</strong>，除什么文件之外，**意思是写再这个属性之外的而文件才进行编译。**比如你还是要编译<code>demo.ts</code>文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;exclude&quot;</span>:[<span class="string">&quot;demo2.ts&quot;</span>],</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">      <span class="comment">//any something</span></span><br><span class="line">      <span class="comment">//........</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样写依然只有<code>demo.ts</code>被编译成了<code>js</code>文件。</p>
<h4 id="三使用-files-配置"><a class="markdownIt-Anchor" href="#三使用-files-配置"></a> 三：使用 files 配置</h4>
<p><code>files</code>的配置效果和<code>include</code>几乎一样</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;files&quot;</span>:[<span class="string">&quot;demo.ts&quot;</span>],</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">      <span class="comment">//any something</span></span><br><span class="line">      <span class="comment">//........</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果是依然只有<code>demo.ts</code>文件被编译。这节课我们就学到这里，目的只是让大家初步了解一下<code>tsconfig.js</code>文件和它的使用方法，文件里边还有很多配置项，这些我们都会逐步讲到。</p>
<h2 id="32配置文件-初识配置项"><a class="markdownIt-Anchor" href="#32配置文件-初识配置项"></a> 3.2配置文件-初识配置项</h2>
<p>这节我们主要学习一下**<code>compilerOptions</code>配置项，**它是告诉<code>TypeScript</code>具体如何编译成<code>js</code>文件的，里边的配置项非常多，这节我们先来讲几个简单的配置项，目的是让你熟悉<code>compilerOptions</code>的使用方法。</p>
<h3 id="321removecomments"><a class="markdownIt-Anchor" href="#321removecomments"></a> 3.2.1removeComments</h3>
<p>**<code>removeComments</code>是<code>complerOptions</code>里的一个子属性，它的用处是告诉<code>TypeScript</code>对编译出来的<code>js</code>文件是否显示注释（注解）。**比如我们现在把<code>removeComments</code>的值设置为<code>true</code>，就是在<code>js</code>中不显示注释。</p>
<p>如果我们把<code>removeComments</code>的值，设置为<code>false</code>,这时候<code>demo.js</code>里就会有注释内容了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="comment">// I‘m JSPang</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="string">&quot;jspang&quot;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="322strict-属性"><a class="markdownIt-Anchor" href="#322strict-属性"></a> 3.2.2strict 属性</h3>
<p><code>strict</code>属性如果设置为<code>true</code>,就代表我们的<strong>编译和书写规范，要按照<code>TypeScript</code>最严格的规范来写</strong>，</p>
<p>如果我们把这个设置为<code>false</code>或者注释掉，意思是我们可以对设置一些不严格的写法。</p>
<p>strict为true:下面的项都为true</p>
<h3 id="323noimplicitany-属性"><a class="markdownIt-Anchor" href="#323noimplicitany-属性"></a> 3.2.3noImplicitAny 属性</h3>
<p><code>noImplicitAny</code>属性的作用**<code>允许你的注解类型any不用特意表明</code>,**</p>
<p>为了更好的说明，我们举个例子,在<code>demo.ts</code>里，删除刚才的代码，然后写一个方法，方法的参数我们设置成任意类型(any)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jspang</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候我们的<code>TypeScript</code>是进行报错的，我们用<code>tsc</code>编译也是报错的。这就是因为我们开启了<code>strict:true</code>,我们先注释掉，然后把<code>noImplicitAny</code>的值设置为<code>false</code>,就不再报错了。</p>
<p>如果设置为<code>noImplicitAny:true</code>,<strong>意思就是值就算是 any（任意值），你也要进行类型注释。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jspang</span>(<span class="params">name: any</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以简单的理解为，设置为 true，就是必须<strong>明确置顶 any 类型的值。</strong></p>
<h3 id="324strictnullchecks-属性"><a class="markdownIt-Anchor" href="#324strictnullchecks-属性"></a> 3.2.4strictNullChecks 属性</h3>
<p>我们先把<code>strictNullChecks</code>设置为<code>false</code>,它的意思就是，**不强制检查 NULL 类型。**我们举个例子，让你能一下子就明白，还是删除<code>demo.ts</code>里的代码，然后编写代码.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jspang: string = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>代码写完后，你会发现这段代码是不报错的，如果是以前，一定是报错的，这就是我们配置了“不强制检验 null 类型”。如果你设成<code>strictNullChecks:true</code>，这时候就报错了。</p>
<h3 id="325ts-node-遵循-tsconfigjs-文件"><a class="markdownIt-Anchor" href="#325ts-node-遵循-tsconfigjs-文件"></a> 3.2.5ts-node 遵循 tsconfig.js 文件</h3>
<p><code>ts-node</code>是遵循的，感兴趣的可以自行试一下。</p>
<p>这节课我们就是简单的认识一下<code>compilerOptions</code>属性的配置，其实这些你<strong>只要掌握方法，并不需要记忆</strong>，我也是记不住每一项是干嘛的，用的时候<strong>会查 API 就可以了。</strong></p>
<h2 id="33compileroptions-配置内容详解"><a class="markdownIt-Anchor" href="#33compileroptions-配置内容详解"></a> 3.3compilerOptions 配置内容详解</h2>
<p>这节我们继续讲<code>complierOptions</code>里的配置项，里边的内容很多，我只能选几个重要的给大家讲讲，然后在这节最后，我会给出大家自己查询的方法。需要再次说明的是，这些配置项没必要记，因为他们真的不是每天都需要用到，所以你只要知道如何配置和重要的几项，学会在自己需要时如何查询就可以了。</p>
<h3 id="331rootdir-和-outdir"><a class="markdownIt-Anchor" href="#331rootdir-和-outdir"></a> 3.3.1rootDir 和 outDir</h3>
<p><strong>工作中我们希望打包的<code>js</code>都生成在特定的一个文件夹里,比如<code>build</code>。</strong></p>
<p>这时候你就可以通过配置<code>outDir</code>来配置，当然你也可以通过**<code>rootDir</code>来指定<code>ts</code>文件的位置**，比如我们把所有的 ts 文件都<strong>放到 src 下</strong>。那配置文件就应该这样写。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;outDir&quot;</span>: <span class="string">&quot;./build&quot;</span> ,</span><br><span class="line">    <span class="string">&quot;rootDir&quot;</span>: <span class="string">&quot;./src&quot;</span> ,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候你再在<code>Terminal</code>中输入<code>tsc</code>,就会有不同的效果了。</p>
<h3 id="332编译-es6-语法到-es5-语法-allowjs"><a class="markdownIt-Anchor" href="#332编译-es6-语法到-es5-语法-allowjs"></a> 3.3.2编译 ES6 语法到 ES5 语法-allowJs</h3>
<p>现在你在<code>src</code>目录下用<code>ES6</code>的语法写了一个<code>demo2.js</code>文件，代码如下。<strong>允许编译javascript文件。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&quot;jspang&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>如果你不做任何配置，这时候试用<code>tsc</code>是没有效果的。你需要到<code>tsconfig.js</code>文件里进行修改，修改的地方有两个。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;target&quot;</span>:<span class="string">&#x27;es5&#x27;</span> ,  <span class="comment">// 这一项默认是开启的，你必须要保证它的开启，才能转换成功</span></span><br><span class="line"><span class="string">&quot;allowJs&quot;</span>:<span class="literal">true</span>,   <span class="comment">// 这个配置项的意思是联通</span></span><br></pre></td></tr></table></figure>
<p>这两项都开启后，在使用<code>tsc</code>编译时，就会编译<code>js</code>文件了。</p>
<h3 id="333sourcemap-属性映射"><a class="markdownIt-Anchor" href="#333sourcemap-属性映射"></a> 3.3.3sourceMap 属性映射</h3>
<p>如果把<code>sourceMap</code>的注释去掉，在打包的过程中就会给我们生成<code>sourceMap</code>文件.</p>
<blockquote>
<p>sourceMap 简单说，Source map 就是一个<strong>信息文件，里面储存着位置信息</strong>。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。有了它，出错的时候，除错工具将直接显示原始代码，而不是转换后的代码。这无疑给开发者带来了很大方便。</p>
</blockquote>
<h3 id="334nounusedlocals-和-nounusedparameters"><a class="markdownIt-Anchor" href="#334nounusedlocals-和-nounusedparameters"></a> 3.3.4noUnusedLocals 和 noUnusedParameters</h3>
<p>比如现在我们修改<code>demo.ts</code>文件的代码，改为下面的样子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jspang: string = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&quot;jspang&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>这时候你会发现<code>jspang</code>这个变量没有任何地方使用，我们编译的话，它依然会被编译出来，这就是<strong>一种资源的浪费。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译后的文件</span></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="built_in">exports</span>.__esModule = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">exports</span>.name = <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> jspang = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">exports</span>.name = <span class="string">&quot;jspang&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>这时候我们可以开启<code>noUnusedLocals：true</code>，开启后我们的程序会直接给我们提**示不能这样编写代码，**有没有使用的变量。</p>
<p><code>noUnusedParameters</code>是针对于名优使用的函数的，方法和<code>noUnusedLocals：true</code>一样，小伙伴们自己尝试吧。</p>
<p>我们讲了几个最常用的方法，如果你需要全面的了解，可以查看这个网址：</p>
<h2 id="34文档"><a class="markdownIt-Anchor" href="#34文档"></a> 3.4文档</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.tslang.cn/docs/handbook/compiler-options.html">https://www.tslang.cn/docs/handbook/compiler-options.html</a> (编译选项详解)</p>
</blockquote>
<p>自己进行查看就可以了。</p>
<h1 id="4联合类型和类型保护"><a class="markdownIt-Anchor" href="#4联合类型和类型保护"></a> 4.联合类型和类型保护</h1>
<p>这节视频将学习一下联合类型和相关的类型保护知识，需要注意的是，只有联合类型存在的情况下，才需要类型保护。<strong>普通的类型注解</strong>，并不需要我们这种特殊操作。那先来看一下什么是联合类型。</p>
<h2 id="41联合类型展示18"><a class="markdownIt-Anchor" href="#41联合类型展示18"></a> 4.1联合类型展示18</h2>
<p>所谓联合类型，可以认为**一个变量可能有两种或两种以上的类型。<strong>用代码举个例子，声明两个接口<code>Waiter</code>(服务员)接口和<code>Teacher</code>(技师)接口，然后在写一个<code>judgeWho</code>(判断是谁)的方法，里边</strong>传入一个<code>animal</code>(任意值)，这时候可以能是<code>Waiter</code>,也可能是<code>Teacher</code>。**所以我们使用了联合类型，<strong>关键符号是<code>|</code>(竖线)。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface Waiter &#123;</span><br><span class="line">  anjiao: boolean;</span><br><span class="line">  say: <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Teacher &#123;</span><br><span class="line">  anjiao: boolean;</span><br><span class="line">  skill: <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">judgeWho</span>(<span class="params">animal: Waiter | Teacher</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>通过这个简单的例子，你应该知道什么是联合类型了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">judgeWho</span>(<span class="params">animal: Waiter | Teacher</span>) </span>&#123;</span><br><span class="line">  animal.say();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这时候问题来了，如果我直接写一个这样的方法，就会报错，因为**<code>judgeWho</code>不能准确的判断联合类型具体的实例是什么。**</p>
<p>这时候就需要再引出一个概念叫做**<code>类型保护</code>**，类型保护有很多种方法，这节讲几个最常使用的。</p>
<h2 id="42类型保护-类型断言"><a class="markdownIt-Anchor" href="#42类型保护-类型断言"></a> 4.2类型保护-类型断言</h2>
<h3 id="421断言animal-as-teacher"><a class="markdownIt-Anchor" href="#421断言animal-as-teacher"></a> 4.2.1断言animal as Teacher</h3>
<p>类型断言就是通过断言的方式确定传递过来的准确值，比如上面的程序，如果会**<code>anjiao</code>（按脚），说明他就是技师，<strong>这时候就可以</strong>通过断言<code>animal as Teacher</code>,**然后直接调用<code>skill</code>方法,程序就不再报错了。同样如果不会按脚，说明就是不同的服务员，这时候调用<code>say()</code>方法，就不会报错了。这就是通过断言的方式进行类型保护。也是最常见的一种类型保护形式。具体看代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Waiter &#123;</span><br><span class="line">  anjiao: boolean;</span><br><span class="line">  say: <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Teacher &#123;</span><br><span class="line">  anjiao: boolean;</span><br><span class="line">  skill: <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">judgeWho</span>(<span class="params">animal: Waiter | Teacher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (animal.anjiao) &#123;</span><br><span class="line">    (animal <span class="keyword">as</span> Teacher).skill();</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    (animal <span class="keyword">as</span> Waiter).say();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="422类型保护-in-语法"><a class="markdownIt-Anchor" href="#422类型保护-in-语法"></a> 4.2.2类型保护-in 语法</h3>
<p>我们还经常使用**<code>in</code>语法来作类型保护，比如用<code>if</code>来判断<code>animal</code>里有没有<code>skill()</code>方法。**</p>
<p>这里你可以赋值上面的<code>judgeWho()</code>方法，然后改一下名字，我这里改成了<code>judgeWhoTwo()</code>方法，具体程序如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">judgeWhoTwo</span>(<span class="params">animal: Waiter | Teacher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;skill&quot;</span> <span class="keyword">in</span> animal) &#123;</span><br><span class="line">    animal.skill();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    animal.say();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>else</code>部分能够自动判断，得益于<code>TypeScript</code>的自动判断。</p>
<h3 id="423类型保护-typeof-语法"><a class="markdownIt-Anchor" href="#423类型保护-typeof-语法"></a> 4.2.3类型保护-typeof 语法</h3>
<p>先来写一个新的<code>add</code>方法，方法接收两个参数，这两个参数可以是数字<code>number</code>也可以是字符串<code>string</code>,**如果我们不做任何的类型保护，只是相加，这时候就会报错。**代码如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first: string | number, second: string | number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决这个问题，就可以<strong>直接使用<code>typeof</code>来进行解决。</strong></p>
<p>===号：比较两个运算元的值和类型是否都相等，如果都相等则结果为 true</p>
<p>例子：</p>
<p>B=10;</p>
<p>(A == B)为 false，A == ‘10’ 为 true</p>
<p>(A === B)为 false，A === ‘10’ 为 false</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first: string | number, second: string | number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> first === <span class="string">&quot;string&quot;</span> || <span class="keyword">typeof</span> second === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;first&#125;</span><span class="subst">$&#123;second&#125;</span>`</span>;<span class="comment">//字符串拼接</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像上面这样写，就不报错了。这样就可以进行继续开心的编写程序了。</p>
<h4 id="typescript使用字符串拼接方法"><a class="markdownIt-Anchor" href="#typescript使用字符串拼接方法"></a> typescript使用${}字符串拼接方法</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v0:string=<span class="string">&#x27;这个是电压&#x27;</span></span><br><span class="line"><span class="keyword">let</span> v1:number=<span class="number">220.35</span>;</span><br><span class="line"><span class="keyword">let</span> str=<span class="string">`这个是格式化字符串(<span class="subst">$&#123;v0&#125;</span>:<span class="subst">$&#123;v1&#125;</span>V)`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str)</span><br></pre></td></tr></table></figure>
<h3 id="424类型保护-instanceof-语法"><a class="markdownIt-Anchor" href="#424类型保护-instanceof-语法"></a> 4.2.4类型保护-instanceof 语法</h3>
<p>比如现在要作**类型保护的是一个对象，**这时候就可以使用<code>instanceof</code>语法来作。现在先写一个<code>NumberObj</code>的类，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberObj</span> </span>&#123;</span><br><span class="line">  count: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们再写一个<code>addObj</code>的方法，这时候传递过来的参数，可以是任意的<code>object</code>,也可以是<code>NumberObj</code>的实例，然后我们返回相加值，当然不进行类型保护，这段代码一定是错误的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addObj</span>(<span class="params">first: object | NumberObj, second: object | NumberObj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> first.count + second.count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>报错不要紧，直接<strong>使用<code>instanceof</code>语法进行判断一下，就</strong>可以解决问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addObj</span>(<span class="params">first: object | NumberObj, second: object | NumberObj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (first <span class="keyword">instanceof</span> NumberObj &amp;&amp; second <span class="keyword">instanceof</span> NumberObj) &#123;</span><br><span class="line">    <span class="keyword">return</span> first.count + second.count;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外要说的是，instanceof 只能用在类上。这节课我介绍四种类型保护的方式，每种方式都在不同场景中使用(还有一些不太常用的类型保护方式，我就不讲了)，你需要自己深刻理解，多练习，在开发时才能灵活使用。</p>
<h1 id="5enum-枚举类型"><a class="markdownIt-Anchor" href="#5enum-枚举类型"></a> 5.Enum 枚举类型</h1>
<p>这节主要学一下 TypeScript 中枚举(<code>enum</code>)类型的使用，你如果在程序中能灵活的使用枚举(<code>enum</code>),会让程序有更好的可读性。</p>
<h2 id="51思考"><a class="markdownIt-Anchor" href="#51思考"></a> 5.1.思考</h2>
<p>通过掷色子随机选择一项服务，进行程序化模拟。这里我先用 JavaScript 的写法来编写。</p>
<h3 id="初级程序员写法"><a class="markdownIt-Anchor" href="#初级程序员写法"></a> 初级程序员写法:</h3>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getServe</span>(<span class="params">status: number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (status === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;massage&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;SPA&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;dabaojian&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = getServe(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`我要去<span class="subst">$&#123;result&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>
<h3 id="中级程序员写法"><a class="markdownIt-Anchor" href="#中级程序员写法"></a> 中级程序员写法:</h3>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Status = &#123;</span><br><span class="line">  MASSAGE: <span class="number">0</span>,</span><br><span class="line">  SPA: <span class="number">1</span>,</span><br><span class="line">  DABAOJIAN: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getServe</span>(<span class="params">status: any</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (status === Status.MASSAGE) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;massage&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status === Status.SPA) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;spa&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status === Status.DABAOJIAN) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;dabaojian&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = getServe(Status.SPA);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`我要去<span class="subst">$&#123;result&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>
<h3 id="高级程序员写法"><a class="markdownIt-Anchor" href="#高级程序员写法"></a> 高级程序员写法:</h3>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">enum Status &#123;</span><br><span class="line">  MASSAGE,</span><br><span class="line">  SPA,</span><br><span class="line">  DABAOJIAN,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getServe</span>(<span class="params">status: any</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (status === Status.MASSAGE) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;massage&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status === Status.SPA) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;spa&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status === Status.DABAOJIAN) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;dabaojian&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = getServe(Status.SPA);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`我要去<span class="subst">$&#123;result&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>
<p>这时候我们就引出了今天的主角<code>枚举Enum</code>。</p>
<h2 id="52枚举类型的对应值"><a class="markdownIt-Anchor" href="#52枚举类型的对应值"></a> 5.2枚举类型的对应值</h2>
<p><strong>你调用时传一个<code>1</code>,也会输出<code>我要去spa</code>。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = getServe(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>这看起来很神奇，这是因为枚举类型是有对应的数字值的，默认是从 0 开始的。我们直接用<code>console.log()</code>就可以看出来了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Status.MASSAGE);</span><br><span class="line"><span class="built_in">console</span>.log(Status.SPA);</span><br><span class="line"><span class="built_in">console</span>.log(Status.DABAOJIAN);</span><br></pre></td></tr></table></figure>
<p>可以<strong>看出结果就是<code>0,1,2</code></strong>。那这时候不想默认从 0 开始，而是想从 1 开始。可以这样写。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum Status &#123;</span><br><span class="line">  MASSAGE = <span class="number">1</span>,</span><br><span class="line">  SPA,</span><br><span class="line">  DABAOJIAN,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="53枚举通过下标反查"><a class="markdownIt-Anchor" href="#53枚举通过下标反查"></a> 5.3枚举通过下标反查</h2>
<p>我们这里能打印出枚举的值(也有叫下标的)，那如果我们知道下标后，也可以通过反差的方法，得到枚举的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Status.MASSAGE, Status[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<p>这样就进行了反查。</p>
<h1 id="6-typescript进阶"><a class="markdownIt-Anchor" href="#6-typescript进阶"></a> 6. Typescript进阶</h1>
<p>泛型我个人认为是 TypeScript 利的一个难点，我第一次学完后根本不能完全理解，所以从这节课开始，我们应该算是一个进阶教程了，难度也开始上来了，如果你一遍听不太明白，可以反复听几次，然后多做练习。</p>
<h2 id="61typescript-函数泛型-难点"><a class="markdownIt-Anchor" href="#61typescript-函数泛型-难点"></a> 6.1TypeScript 函数泛型-难点</h2>
<h3 id="611编写一个联合类型-demo"><a class="markdownIt-Anchor" href="#611编写一个联合类型-demo"></a> 6.1.1编写一个联合类型 Demo</h3>
<p>现在跟着我作一个简单的<code>join</code>方法，方法接受两个参数<code>first</code>和<code>second</code>,参数有可能是字符串类型，也有可能是数字类型。方法里为了保证都可以使用，所以我们只作了字符串的基本拼接。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">join</span>(<span class="params">first: string | number, second: string | number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;first&#125;</span><span class="subst">$&#123;second&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line">join(<span class="string">&quot;jspang&quot;</span>, <span class="string">&quot;.com&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这个方法现在没有任何问题，但现在有这样一个需求，就是<code>first</code>参数如果<strong>传的是字符串类型，要求<code>second</code>也传字符串类型.同理，如果是<code>number</code>类型，就都是<code>number</code>类型。</strong></p>
<p>那现在<strong>所学的知识就完成不了啦，所以需要学习<code>泛型</code>来解决这个问题。</strong></p>
<h3 id="612初始泛型概念-generic"><a class="markdownIt-Anchor" href="#612初始泛型概念-generic"></a> 6.1.2初始泛型概念-generic</h3>
<blockquote>
<p>泛型：[generic - 通用、泛指的意思],那最简单的理解，泛型就是<strong>泛指的类型。</strong></p>
</blockquote>
<p>泛型的定义<strong>使用<code>&lt;&gt;</code>（尖角号）进行定义的</strong>，比如现在给<code>join</code>方法一个泛型，名字就叫做<code>JSPang</code>(<strong>起这个名字的意思，就是你可以随便起一个名字，但工作中要进行语义化。</strong>),后边的参数，这时候他也使用刚定义的泛型名称。然后在正式调用这个方法时，就需要具体指明泛型的类型啦。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">join</span>&lt;<span class="title">JSPang</span>&gt;(<span class="params">first: JSPang, second: JSPang</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;first&#125;</span><span class="subst">$&#123;second&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line">join &lt; string &gt; (<span class="string">&quot;jspang&quot;</span>, <span class="string">&quot;.com&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>如果要是<code>number</code>类型，就直接在<strong>调用方法的时候进行更改就可以了。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">join &lt; number &gt; (<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h3 id="613泛型中数组的使用"><a class="markdownIt-Anchor" href="#613泛型中数组的使用"></a> 6.1.3泛型中数组的使用</h3>
<p>如果传递过来的值要求是数字，如何用泛型进行定义那?两种方法，第一种是直接使用<code>[]</code>，第二种是使用<code>Array&lt;泛型&gt;</code>。形式不一样，其他的都一样。</p>
<p>第一种写法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>&lt;<span class="title">ANY</span>&gt;(<span class="params">params: ANY[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> params;</span><br><span class="line">&#125;</span><br><span class="line">myFun &lt; string &gt; ([<span class="string">&quot;123&quot;</span>, <span class="string">&quot;456&quot;</span>]);</span><br></pre></td></tr></table></figure>
<p>第二种写法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>&lt;<span class="title">ANY</span>&gt;(<span class="params">params: <span class="built_in">Array</span>&lt;ANY&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> params;</span><br><span class="line">&#125;</span><br><span class="line">myFun &lt; string &gt; ([<span class="string">&quot;123&quot;</span>, <span class="string">&quot;456&quot;</span>]);</span><br></pre></td></tr></table></figure>
<p>在工作中，我们经常使用**<code>&lt;T&gt;</code>**<strong>来作泛型的表示</strong></p>
<h3 id="614多个泛型的定义"><a class="markdownIt-Anchor" href="#614多个泛型的定义"></a> 6.1.4多个泛型的定义</h3>
<p>一个函数只能定义一个泛型吗?当然不是，是可以定义多个的，这里还是拿<code>join</code>方法举例，定义多个泛型，比如第一个泛型用<code>T</code>,第二个用<code>P</code>代表。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">join</span>&lt;<span class="title">T</span>, <span class="title">P</span>&gt;(<span class="params">first: T, second: P</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;first&#125;</span><span class="subst">$&#123;second&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line">join &lt; number, string &gt; (<span class="number">1</span>, <span class="string">&quot;2&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>会了两种，你也就会了三种以上，泛型在造轮子的时候经常使用，因为造轮子很多东西都需要灵活性。泛型给了我们很好的灵活性。需要注意的是，如果函数定义了多个泛型，使用时要对应的定义出具体的类型。</p>
<h3 id="615泛型的类型推断了解"><a class="markdownIt-Anchor" href="#615泛型的类型推断了解"></a> 6.1.5泛型的类型推断了解</h3>
<p>泛型也是支持类型推断的，比如下面的代码并没有报错，这就是<code>类型推断</code>的功劳。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">join</span>&lt;<span class="title">T</span>, <span class="title">P</span>&gt;(<span class="params">first: T, second: P</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;first&#125;</span><span class="subst">$&#123;second&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line">join(<span class="number">1</span>, <span class="string">&quot;2&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>但个人不建议大量使用类型推断，这会让你的代码易读和健壮性都会下降，所以这个知识点，大家做一个了解就可以了。</p>
<h2 id="62typescript-类中泛型"><a class="markdownIt-Anchor" href="#62typescript-类中泛型"></a> 6.2TypeScript 类中泛型</h2>
<p>这节课在看看类中泛型的使用方法。</p>
<h3 id="621编写一个基本类"><a class="markdownIt-Anchor" href="#621编写一个基本类"></a> 6.2.1编写一个基本类</h3>
<p>为了下面的教学演示，所以我先编写一个基本的类<code>SelectGirl</code>,在类的构造函数中(constructor)需要传递一组女孩的名称，然后再通过下边展现女孩的名称，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelectGirl</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">private girls: string[]</span>)</span> &#123;&#125;</span><br><span class="line">  getGirl(index: number): string &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.girls[index];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> selectGirl = <span class="keyword">new</span> SelectGirl([<span class="string">&quot;大脚&quot;</span>, <span class="string">&quot;刘英&quot;</span>, <span class="string">&quot;晓红&quot;</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(selectGirl.getGirl(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>写完后，我们可以在终端中使用<code>ts-node Demo.ts</code>进行预览，可以看到控制台中输出了<code>刘英</code>的名字。学到现在你写这样的一个类应该是非常容易的了。</p>
<p>现在问题来了，比如现在更好的保护小姐姐，这些小姐姐使用编号啦，那我们程序要如何修改。需要写成下面的样子，这时候我们代码看起来就没有那么优雅了,在 TypeScript 中，编写复杂代码的时候，会经常使用泛型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelectGirl</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">private girls: string[] | number[]</span>)</span> &#123;&#125;</span><br><span class="line">  getGirl(index: number): string | number &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.girls[index];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="622初始类的泛型"><a class="markdownIt-Anchor" href="#622初始类的泛型"></a> 6.2.2初始类的泛型</h3>
<p>这时候我们要用泛型重构代码，要如何作那？有了上节课的基础，应该很好理解，就是用<code>&lt;&gt;</code>编写，我们把代码修改成了这个样子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelectGirl</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">private girls: T[]</span>)</span> &#123;&#125;</span><br><span class="line">  getGirl(index: number): T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.girls[index];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> selectGirl = <span class="keyword">new</span> SelectGirl([<span class="string">&quot;大脚&quot;</span>, <span class="string">&quot;刘英&quot;</span>, <span class="string">&quot;晓红&quot;</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(selectGirl.getGirl(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>这时候代码并不报错，也使用了泛型，但是在实例化对象的时候，**TypeScript 是通过类型推断出来的。<strong>需要</strong>在实例化对象的时候，对泛型的值进行确定，**比如是<code>string</code>类型，就这样写。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> selectGirl = <span class="keyword">new</span> SelectGirl() &lt; string &gt; [<span class="string">&quot;大脚&quot;</span>, <span class="string">&quot;刘英&quot;</span>, <span class="string">&quot;晓红&quot;</span>];</span><br></pre></td></tr></table></figure>
<h3 id="623泛型中的继承"><a class="markdownIt-Anchor" href="#623泛型中的继承"></a> 6.2.3泛型中的继承</h3>
<p>现在需求又变了，要求返回是一个对象中的<code>name</code>,也就是下面的代码要改成这个样子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.girls[index].name;</span><br></pre></td></tr></table></figure>
<p>现在的代码一定时报错的，但是这时候还要求我们这么做，意思就是说传递过来的值必须是一个对象类型的，里边还要有<code>name</code>属性。这时候就要用到继承了，我用接口的方式来实现。写一个<code>Girl</code>的接口，每个接口里都要有 name 属性。代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Girl &#123;</span><br><span class="line">  name: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了接口后用<code>extends</code>关键字实现泛型继承，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelectGirl</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Girl</span>&gt; </span>&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这句代码的意思是泛型里必须有一个<code>name</code>属性，因为它继承了<code>Girl</code>接口。</p>
<p>现在程序还是报错的，因为我们<code>getGirl</code>方法的返回类型还不对，这时**候应该是一个<code>string</code>类型才对，**所以代码应该改为下面的样子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Girl &#123;</span><br><span class="line">  name: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelectGirl</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Girl</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">private girls: T[]</span>)</span> &#123;&#125;</span><br><span class="line">  getGirl(index: number): string &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.girls[index].name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> selectGirl = <span class="keyword">new</span> SelectGirl([</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;大脚&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;刘英&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;晓红&quot;</span> &#125;,</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">console</span>.log(selectGirl.getGirl(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>我们回过头来看一下这段代码的意思，就是我们在<code>SelectGirl</code>类中使用了泛型，意思是我不知道我以后要用什么类型，但是我有一个约束条件，这个类型，必须要有一个<code>name</code>属性。这个在工作中经常使用，所以必须要好好理解这的知识。 初学泛型肯定会很难理解，我当时看书也是看的一脸懵，经过反复的实验和看别人的源代码，才对泛型有了比较深的理解。</p>
<h3 id="624泛型约束"><a class="markdownIt-Anchor" href="#624泛型约束"></a> 6.2.4泛型约束</h3>
<p>现在的泛型可以是任意类型，可以是对象、字符串、布尔、数字都是可以的。但你现在要求这个泛型必须是<code>string</code>或者<code>number</code>类型。我们还是拿上面的例子，不过把代码改为最初的样子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelectGirl</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">private girls: T[]</span>)</span> &#123;&#125;</span><br><span class="line">  getGirl(index: number): T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.girls[index];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> selectGirl = <span class="keyword">new</span> SelectGirl&lt;string&gt;([<span class="string">&quot;大脚&quot;</span>, <span class="string">&quot;刘英&quot;</span>, <span class="string">&quot;晓红&quot;</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(selectGirl.getGirl(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>然后进行约束，这时候还是可以<strong>使用关键字<code>extends</code>来进行约束，把代码改成下面的样子。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelectGirl</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">number</span> | <span class="title">string</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作为教学泛型讲这些就可以了，但是**在实际工作中，泛型的应用更广泛和复杂，**这些需要在实际项目中不断精进和加深理解，有句话说的非常好，师傅领进门，修行在个人了。</p>
<h2 id="63初识命名空间-namespace"><a class="markdownIt-Anchor" href="#63初识命名空间-namespace"></a> 6.3初识命名空间-Namespace</h2>
<p>这节课为了有更好的演示效果，我们要在浏览器中运行代码。这就要求我们重新创建一个项目，<strong>直接在桌面上建立一个文件夹<code>TSWeb</code>。</strong></p>
<h3 id="631搭建浏览器开发环境步骤"><a class="markdownIt-Anchor" href="#631搭建浏览器开发环境步骤"></a> 6.3.1搭建浏览器开发环境步骤</h3>
<p>如何搭建一个最基础的 TS 开发环境了。正好这节课也需要，我们就从新搭建一下。如果你已经很熟悉这部分内容可以跳过。</p>
<ol>
<li>建立好文件夹后，打开 VSCode，把文件夹拉到编辑器当中，然后打开终端，运行<code>npm init -y</code>,创建<code>package.json</code>文件。</li>
<li>生成文件后，我们接着在终端中运行<code>tsc -init</code>,生成<code>tsconfig.json</code>文件。</li>
<li>新建<code>src</code>和<code>build</code>文件夹，再建一个<code>index.html</code>文件。</li>
<li>在<code>src</code>目录下，<strong>新建一个<code>page.ts</code>文件</strong>，这就是我们要编写的<code>ts</code>文件了。</li>
<li>配置<code>tsconfig.json</code>文件，设置<code>outDir</code>和<code>rootDir</code>(在 15 行左右)，也就是设置需要编译的文件目录，和编译好的文件目录。</li>
<li>然后编写<code>index.html</code>，引入<code>&lt;script src=&quot;./build/page.js&quot;&gt;&lt;/script&gt;</code>,当让我们现在还没有<code>page.js</code>文件。</li>
<li>编写<code>page.ts</code>文件，加入一句输出<code>console.log('jspang.com')</code>,再在控制台输入<code>tsc</code>,就会生成<code>page.js</code>文件</li>
<li>再到浏览器中查看<code>index.html</code>文件，如果按<code>F12</code>可以看到<code>jspang.com</code>，说明我们的搭建正常了。</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./build/page.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这就是你开发最基础的前端项目时需要作的环境配置。我觉的学习这东西，学会了就要用，如果不用你很快就会忘记。所以以后你在做项目，请尽量使用<code>TypeScript</code>来进行编写。</p>
<h3 id="632没有命名空间时的问题"><a class="markdownIt-Anchor" href="#632没有命名空间时的问题"></a> 6.3.2没有命名空间时的问题</h3>
<p>为了你更好的理解，先写一下这样代码，用类的形式在<code>index.html</code>中实现<code>header</code>,<code>content</code>和<code>Footer</code>部分，类似我们常说的模板。</p>
<p>在<code>page.ts</code>文件里，写出下面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Header</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> elem = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">    elem.innerText = <span class="string">&quot;This is Header&quot;</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(elem);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Content</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> elem = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">    elem.innerText = <span class="string">&quot;This is Content&quot;</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(elem);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Footer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> elem = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">    elem.innerText = <span class="string">&quot;This is Footer&quot;</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(elem);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Page</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> Header();</span><br><span class="line">    <span class="keyword">new</span> Content();</span><br><span class="line">    <span class="keyword">new</span> Footer();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写完后我们用<code>tsc</code>进行编译一次，然后修改<code>index.html</code>文件，在<code>&lt;body&gt;</code>标签里引入<code>&lt;script&gt;</code>标签，并实例化<code>Page</code>，代码如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script&gt;<span class="keyword">new</span> Page();&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>这时候再到浏览器进行预览，看起来没有什么问题，但是有经验的程序员就会发现，这样写全部都是<strong>全局变量</strong>（通过查看<code>./build/page.js</code>文件可以看出全部都是<code>var</code>声明的变量）。<strong>过多的全局变量会让我们代码变的不可维护。</strong></p>
<p>这时候你在浏览器的控制台(<code>Console</code>)中，分别输入<code>Header</code>、<code>Content</code>、<code>Footer</code>和<code>Page</code>都时可以拿到对应的变量的,说明他们全都是全局变量。</p>
<p>其实你理想的是，只要有<code>Page</code>这个全局变量就足够了，剩下的可以模块化封装起来，不暴露到全局。</p>
<h3 id="634命名空间的使用"><a class="markdownIt-Anchor" href="#634命名空间的使用"></a> 6.3.4命名空间的使用</h3>
<p>**<code>命名空间</code>这个语法，很类似编程中常说的模块化思想，**比如<code>webpack</code>打包时，**每个模块有自己的环境，不会污染其他模块,不会有全局变量产生。**命名空间就跟这个很类似，注意这里是类似，而不是相同。</p>
<p>命名空间声明的关键词是<code>namespace</code> **比如声明一个<code>namespace Home</code>,需要暴露出去的类，可以使用<code>export</code>关键词，这样只有暴漏出去的类是全局的，**其他的不会再生成全局污染了。修改后的代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">namespace Home &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Header</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> elem = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">      elem.innerText = <span class="string">&quot;This is Header&quot;</span>;</span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(elem);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Content</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> elem = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">      elem.innerText = <span class="string">&quot;This is Content&quot;</span>;</span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(elem);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Footer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> elem = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">      elem.innerText = <span class="string">&quot;This is Footer&quot;</span>;</span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(elem);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Page</span> </span>&#123;<span class="comment">//暴露出来</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> Header();</span><br><span class="line">      <span class="keyword">new</span> Content();</span><br><span class="line">      <span class="keyword">new</span> Footer();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TS 代码写完后，再到<code>index.html</code>文件中进行修改，用命名空间的形式进行调用，就可以正常了。 写完后，记得用<code>tsc</code>编译一下，当然你也可以使用<code>tsc -w</code>进行监视了，只要有改变就会进行重新编译。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Home.Page();</span><br></pre></td></tr></table></figure>
<p>现在再到浏览器中进行查看，可以看到现在就只有<code>Home.Page</code>是在控制台可以得到的，其他的<code>Home.Header</code>…这些都是得不到的，说明<strong>只有<code>Home.Page</code>是全局的，其他的都是模块化私有的。</strong></p>
<p>这就是 **TypeScript 给我们提供的类似模块化开发的语法，**它的好处就是让全局变量减少了很多，**实现了基本的封装，**减少了全局变量的污染。</p>
<h2 id="64深入命名空间"><a class="markdownIt-Anchor" href="#64深入命名空间"></a> 6.4深入命名空间</h2>
<h3 id="641用命名空间实现组件化"><a class="markdownIt-Anchor" href="#641用命名空间实现组件化"></a> 6.4.1用命名空间实现组件化</h3>
<p>上节课的代码虽实现了模块化和全局变量的污染，但是我们工作中分的要更细致一些，会单独写一个<code>components</code>的文件，然后进行组件化。</p>
<p>在<code>src</code>目录下新建一个文件<code>components.ts</code>，编写代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">namespace Components &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Header</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> elem = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">      elem.innerText = <span class="string">&quot;This is Header&quot;</span>;</span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(elem);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Content</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> elem = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">      elem.innerText = <span class="string">&quot;This is Content&quot;</span>;</span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(elem);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Footer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> elem = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">      elem.innerText = <span class="string">&quot;This is Footer&quot;</span>;</span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(elem);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，我每个类(<code>class</code>)都使用了<code>export</code>导出，导出后就可以在<code>page.ts</code>中使用这些组件了。比如这样使用-代码如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">namespace Home &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Page</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> Components.Header();</span><br><span class="line">      <span class="keyword">new</span> Components.Content();</span><br><span class="line">      <span class="keyword">new</span> Components.Footer();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候你可以使用<code>tsc</code>进行重新编译，但在预览时，你会发现还是会报错，找不到<code>Components</code>,想解决这个问题，我们必须要在<code>index.html</code>里进行引入<code>components.js</code>文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;./build/page.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;./build/components.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>这样才可以正常的出现效果。但这样引入太麻烦了，可不可以像<code>webpack</code>一样，只生成一个文件那？那答案是肯定的。</p>
<h3 id="642多文件编译成一个文件"><a class="markdownIt-Anchor" href="#642多文件编译成一个文件"></a> 6.4.2多文件编译成一个文件</h3>
<p>直接打开<code>tsconfig.json</code>文件，然后找到<code>outFile</code>配置项，这个就是用来生成一个文件的设置，但是如果设置了它，就不再支持<code>&quot;module&quot;:&quot;commonjs&quot;</code>设置了，我们需要把它改成<code>&quot;module&quot;:&quot;amd&quot;</code>,然后在去掉对应的<code>outFile</code>注释，设置成下面的样子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;module&quot;</span>:<span class="string">&quot;amd&quot;</span>，</span><br><span class="line">  <span class="string">&quot;outFile&quot;</span>: <span class="string">&quot;./build/page.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置好后，删除掉<code>build</code>下的<code>js</code>文件，然后用<code>tsc</code>进行再次编译。</p>
<p>然后删掉<code>index.html</code>文件中的<code>component.js</code>,在浏览器里还是可以正常运行的。</p>
<h3 id="643子命名空间"><a class="markdownIt-Anchor" href="#643子命名空间"></a> 6.4.3子命名空间</h3>
<p>也就是说在命名空间里，再写一个命名空间,比如在<code>Components.ts</code>文件下修改代码如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">namespace Components &#123;</span><br><span class="line">  <span class="keyword">export</span> namespace SubComponents &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//someting ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写完后在控制台再次编辑<code>tsc</code>，然后你在浏览器中也是可以查到这个命名空间的<code>Components.SubComponents.Test</code>(需要刷新页面后才会显示)。</p>
<p>通过两节课的时间，基本讲完了命名空间的内容，在工作中如果遇到，这些知识已经完全够用，所以这部分内容就先到这里了。</p>
<h2 id="65typescript-使用-import-语法"><a class="markdownIt-Anchor" href="#65typescript-使用-import-语法"></a> 6.5TypeScript 使用 import 语法</h2>
<p>那这节我们就把上节的代码改成<code>import</code>引入。</p>
<h3 id="651修改-componentsts-文件"><a class="markdownIt-Anchor" href="#651修改-componentsts-文件"></a> 6.5.1修改 components.ts 文件</h3>
<p>现在去掉<code>components.ts</code>里的<code>namespace</code>命名空间代码，写成 <code>ES6</code> 的 <code>export</code> 导出模式。代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Header</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> elem = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">    elem.innerText = <span class="string">&quot;This is Header&quot;</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(elem);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Content</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> elem = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">    elem.innerText = <span class="string">&quot;This is Content&quot;</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(elem);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Footer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> elem = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">    elem.innerText = <span class="string">&quot;This is Footer&quot;</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(elem);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在三个类就都已经用<code>export</code>导出了，也就是说可以实现用<code>import</code>进行引入了。</p>
<p>修改 page.ts 文件</p>
<p>来到<code>page.ts</code>文件，去掉<code>namespace</code>命名空间对应的代码，然后使用 <code>import</code> 语法进行导入<code>Header</code>、<code>Content</code>和<code>Footer</code>,代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Header, Content, Footer &#125; <span class="keyword">from</span> <span class="string">&quot;./components&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Page</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> Header();</span><br><span class="line">    <span class="keyword">new</span> Content();</span><br><span class="line">    <span class="keyword">new</span> Footer();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在看起来确实和工作中写的代码非常类似了。这时候可以使用<code>tsc</code>进行编译。然后可以看到编译好的代码都是<code>define</code>开头的(这是 amd 规范的代码，不能直接在浏览器中运行，可以在 Node 中直接运行)，这种代码在浏览器中是没办法被直接运行的，需要其他库(<code>require.js</code>)的支持。</p>
<p><a target="_blank" rel="noopener" href="http://www.jspang.com/detailed?id=63#toc3101">引入 require.js</a></p>
<p>我这里使用了一个现成的 CDN 的<code>require.js</code>,地址你可以直接复制，然后用<code>&lt;script&gt;</code>标签进行引入。</p>
<blockquote>
<p>Require.js 的 CDN 地址： <a target="_blank" rel="noopener" href="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.js">https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.js</a></p>
</blockquote>
<p>复制好 URL 地址后，记得使用<code>&lt;script&gt;</code>标签进行引入，代码如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>这时候就可以解析<code>define</code>这样的语法了。然后把<code>page.ts</code>中加入<code>default</code>关键字，如果不加是没办法直接引用到的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Header, Content, Footer &#125; <span class="keyword">from</span> <span class="string">&quot;./components&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Page</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> Header();</span><br><span class="line">    <span class="keyword">new</span> Content();</span><br><span class="line">    <span class="keyword">new</span> Footer();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候再用<code>tsc</code>进行编译一下，你会发现还是又问题。因为使用<code>export default</code>这种形式的语法，需要在<code>html</code>里用<code>require</code>来进行引入。</p>
<p><a target="_blank" rel="noopener" href="http://www.jspang.com/detailed?id=63#toc3102">require 方式引入</a></p>
<p>因为你已经加入了<code>require.js</code>这个库，所以现在可以直接在代码中使用<code>require</code>了。具体代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="built_in">require</span>([<span class="string">&quot;page&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">page</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">new</span> page.default();</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>写完这部，刷新页面，可以看到正常显示出来了，虽然用起来比较麻烦，但是我们还是实现了用<code>import</code>来进行引入，当我们又了<code>webpack</code>和<code>Parcel</code>的时候就不会这么麻烦，这些都交给打包工具来处理就好了。</p>
<p><a target="_blank" rel="noopener" href="http://www.jspang.com/detailed?id=63#toc2103">25. 用 Parcel 打包 TypeScript 代码</a></p>
<p>上节课代码配置起来非常麻烦，步骤也很多。工作中一定是有更好的解决方案的。其实最通用的有两种解决方案<code>Webpack</code>和<code>Parcel</code>。<code>webpack</code>不用多说，只要是前端基本都会，这几年<code>Parcel</code>也开始崛起，用的人也越来越多。所以这节课就讲一下，如何使用<code>Parcel</code>来打包<code>TypeScript</code>代码。</p>
<p><a target="_blank" rel="noopener" href="http://www.jspang.com/detailed?id=63#toc3104">建立一个新项目</a></p>
<p>这里给出新建项目的步骤，如果你已经熟悉此过程，可以跳过。</p>
<ol>
<li>教学需要，这里我们重新建立一个项目<code>TSTest</code>,在桌面新建立一个文件夹，然后在<code>VSCode</code>中打开。</li>
<li>打开终端，输入<code>npm init -y</code>,创建<code>package.json</code>文件</li>
<li>在终端中输入<code>tsc --init</code>,创建<code>tsconfig.json</code>文件</li>
<li>修改<code>tsconfig.json</code>配置<code>rootDir</code>和<code>outDir</code>.</li>
<li>新建<code>src</code>文件夹，在里边建立<code>index.html</code>,<code>page.ts</code>文件</li>
<li>编写<code>index.html</code>文件，并引入<code>page.ts</code>文件</li>
<li>编写<code>page.ts</code>文件。</li>
</ol>
<p>index.html 文件代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br><span class="line">    &lt;script src=<span class="string">&quot;./page.ts&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>page.ts 文件代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> teacher: string = <span class="string">&quot;jspang&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(teacher);</span><br></pre></td></tr></table></figure>
<p>这时候我们并不能正常的预览出效果，我们需要<code>Parcel</code>的帮忙。</p>
<p><a target="_blank" rel="noopener" href="http://www.jspang.com/detailed?id=63#toc3105">Parcel 的安装和使用</a></p>
<p>Parcel 可以通过<code>npm</code>或者<code>yarn</code>来进行安装，我这里<code>npm</code>安装很慢，会 5 分钟左右，所以我使用<code>yarn</code>来进行安装。代码如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add --dev parcel@next</span><br></pre></td></tr></table></figure>
<p>使用 yarn 安装大概需要 1 分钟左右，这些主要看你自身的网络情况。</p>
<p>安装好以后，打开<code>package.json</code>文件，可以看到这样一段代码，我安装的版本是<code>^2.0.0-beta.1</code>,如果你学习时和这个版本不一样，操作可能会稍有不同。</p>
<p>修改<code>package.json</code>里边的代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;parcel ./src/index.html&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个意思就是使用<code>parcel</code>对<code>index.html</code>进行一个编译。</p>
<p>然后打开终端输入<code>yarn test</code>,这时候终端会给出一个地址<code>http://localhost:1234</code>,把地址放到浏览器上，可以看到浏览器的控制台会输出<code>jspang</code>。</p>
<p>这说明<code>Parcel</code>会自动对<code>index.html</code>中引入的<code>TypeScript</code>文件进行编译，然后打包好后，就可以直接使用了。</p>
<p>使用<code>Parcel</code>大大简化了我们的配置过程，如果你想详细学习<code>Parcel</code>可以自行学习，毕竟我们这个是 TypeScript 的教程，所以更多的 Parcel 知识就不作介绍了。</p>
<p><a target="_blank" rel="noopener" href="http://www.jspang.com/detailed?id=63#toc2106">26. 在 TypeScript 中使用 JQuery</a></p>
<p>这个需求也经常使用，就是在 TypeScript 的代码中使用其他类库，其实这里就涉及到一个类型文件(Type file)的问题，网上有大量别人写好的类型文件，我们只要下载使用就可以了。</p>
<p><a target="_blank" rel="noopener" href="http://www.jspang.com/detailed?id=63#toc3107">引入 JQuery 框架库</a></p>
<p>接着上节课的代码，在<code>TSTest</code>文件夹的<code>src</code>目录下，引入<code>JQuery</code>文件，这里采用<code>CDN</code>的形式进行引入。</p>
<blockquote>
<p>BootCDN 地址： <a target="_blank" rel="noopener" href="https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.js">https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.js</a></p>
</blockquote>
<p>直接在<code>index.html</code>加入<code>&lt;script&gt;</code>标签，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>有了 jquery 框架，就可以在<code>TypeScript</code>文件中进行使用<code>JQuery</code>的语法了。</p>
<p>然后在<code>page.ts</code>文件中编写如下代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> teacher: string = <span class="string">&quot;jspang&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(teacher);</span><br><span class="line"></span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;jspang&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>写完后到终端中输入<code>yarn test</code>进行编译和启动服务。然后在地址栏输入了<code>http://localhost:1234</code>,可以看到程序可以正常输出，也没有任何的报错。</p>
<p><a target="_blank" rel="noopener" href="http://www.jspang.com/detailed?id=63#toc3108">安装 types/jquery(解决方法)</a></p>
<p>第一种：就是安装别人写好的文件</p>
<p>但是在<code>vscode</code>中是会报错的，这时候就需要我们安装类型文件<code>type file</code>,直接可以用 npm 进行安装。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i @types/jquery</span><br></pre></td></tr></table></figure>
<p>这个安装的时间还是比较长的，所以视频中我就不进行展示了。</p>
<p>第二种:简单粗暴</p>
<p>还有一种简单粗暴的方法的方式就是直接在<code>page.ts</code>文件的头部加入这句代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare <span class="keyword">var</span> $: any;</span><br></pre></td></tr></table></figure>
<p>第三种：自己写一个<code>.d.ts</code>声明文件的类库，如果你用的类库很少见，就需要自己写了。这个写起来还是很麻烦的。我只是简单的学过，但在工作中从来没自己写过，所以也不推荐给大家。比如 JQuery 就有几十个接口，如果你要写，这个文件会写很长，所以原则就是有别人写好的就直接用，实在没有就用粗暴的方法，如果实在不行，再考虑写<code>.d.ts</code>声明文件。</p>
<p>TypeScrip 的视频我们就暂时告一段落，紧接着会更新 Vue3 的课程，希望下伙伴们继续跟我一期学习。</p>
</div><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">I'm so cute. Please give me money.</div><div id="qr" style="display:none;"><div style="display:inline-block"><a href="/images/donate/zhifubao.jpg"><img loading="lazy" src="/images/donate/zhifubao.jpg" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"></use></svg></span></div></div><div style="display:inline-block"><a href="/images/donate/weixin.png"><img loading="lazy" src="/images/donate/weixin.png" alt="QQ 支付" title="QQ 支付"></a><div><span style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></span></div></div><div style="display:inline-block"><a href="/images/donate/weixin.png"><img loading="lazy" src="/images/donate/weixin.png" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-pay-line"></use></svg></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>AI Jiang</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="http://example.com/2021/04/11/%E5%89%8D%E7%AB%AFTypescript%E7%AC%94%E8%AE%B0/" title="前端Typescript笔记">http://example.com/2021/04/11/%E5%89%8D%E7%AB%AFTypescript%E7%AC%94%E8%AE%B0/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"></div><div class="post-nav-item"><a class="post-nav-next" href="/2021/04/02/%E7%8B%82%E7%A5%9E%E8%AF%B4mysql/" rel="next" title="狂神说mysql"><span class="post-nav-text">狂神说mysql</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>点击按钮跳转 GitHub Issues 评论。</span><br><span>若没有本文 Issue，您可以使用 Comment 模版新建。</span><br><a class="hty-button hty-button--raised" id="github-issues" target="_blank" rel="noopener" href="https://github.com/YunYouJun/yunyoujun.github.io/issues?q=is:issue+前端Typescript笔记">GitHub Issues</a><a class="hty-button hty-button--raised" id="github-discussions" target="_blank" rel="noopener" href="https://github.com/YunYouJun/yunyoujun.github.io/discussions/new">GitHub Discussions</a></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2021 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> AI Jiang</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v5.4.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.5.1</span></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></div></body></html>