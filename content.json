{"meta":{"title":"Hexo","subtitle":"","description":"","author":"AI Jiang","url":"http://example.com"},"pages":[{"title":"�ҵķ���ҳ��","date":"2021-03-30T13:40:58.000Z","updated":"2021-03-30T13:46:21.360Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"�ҵı�ǩҳ","date":"2021-03-30T13:45:18.000Z","updated":"2021-03-30T13:48:42.231Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2021-03-30T13:47:34.000Z","updated":"2021-03-30T13:47:34.930Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"前端Typescript笔记","slug":"前端Typescript笔记","date":"2021-04-11T03:05:37.000Z","updated":"2021-04-23T13:39:55.231Z","comments":true,"path":"2021/04/11/前端Typescript笔记/","link":"","permalink":"http://example.com/2021/04/11/%E5%89%8D%E7%AB%AFTypescript%E7%AC%94%E8%AE%B0/","excerpt":"","text":"1.基础 笔记来自B站技术胖 1.1建立项目目录和编译 TS 文件 在E盘(当然你可以在你喜欢的任何一个地方安装)，新建一个目录，我这里起的目录名字叫做TypeScriptDemo，然后把这个文件在 VSCode 中打开。 我在视频里用了命令行的形式建立，直接使用ctrl+r打开运行，然后在运行的文本框里输入cmd，回车后，打开命令行工具，在命令行中输入下面的命令。 12e:mkdir TypeScriptDemo 完成后，打开 E 盘，打开 VSCode，把新建立的文件夹拖入到 VSCode 当中，新建一个Demo1.ts文件，写入下面代码： 123456function jspang() &#123; let web: string &#x3D; &quot;Hello World&quot;; console.log(web);&#125;jspang(); 这时候你使用node Demo1.ts是执行不成功的，因为 Node 不能直接运行TypeScript文件，需要用tsc Demo1.ts转换一下，转换完成后typeScript代码被编译成了javaScript代码,新生成一个demo1.js的文件，这时候你在命令行输入node Demo1.js,在终端里就可以顺利的输出jspang的字符了。 1.2ts-node 的安装和使用 使用npm命令来全局安装，直接在命令行输入下面的命令： 1npm install -g ts-node 安装完成后，就可以在命令中直接输入如下命令，来查看结果了。 1ts-node Demo1.ts 1.3语言特点 分号可选，句尾最好带上分号，同一行则一定需要使用分号来分隔，否则报错 单行注释 ( // ) 多行注释 (/* */) 面向对象编程 1234567class Site &#123; name():void &#123; console.log(&quot;Runoob&quot;) &#125; &#125; var obj = new Site(); obj.name(); 编译后生成的 JavaScript 代码如下： 12345678910var Site = /** @class */ (function () &#123; function Site() &#123; &#125; Site.prototype.name = function () &#123; console.log(&quot;Runoob&quot;); &#125;; return Site;&#125;());var obj = new Site();obj.name(); 2.基本语法 2.1静态类型定义 2.1.1定义 1const count: number = 1; 这就是最简单的**定义一个数字类型的count的变量，这里的: number就是定义了一个静态类型。**这样定义后count这个变量在程序中就永远都是数字类型了，不可以改变了。比如我们这时候给count复制一个字符串，它就报错了。 123//错误代码const count: number = 1;count = &quot;jspang&quot;; 但这只是最简单的理解，再往深一层次理解，你会发现这时候的count变量,可以使用**number类型上所有的属性和方法。**我们可以通过在count后边打上一个.看出这个特性，并且编辑器会给你非常好的提示。这也是为什么我喜欢用VScode编辑器的一个原因。 2.1.2自定义 你还可以自己去定义一个静态类型，比如现在你定义一个小姐姐的类型，然后在声明变量的时候，就可以使用这个静态类型了，看下面的代码。 12345678interface XiaoJieJie &#123; uname: string; age: number;&#125;const xiaohong: XiaoJieJie = &#123; uname: &quot;小红&quot;, age: 18,&#125;; 这时候你如果声明变量，**跟自定义不一样，VSCode直接就会报错。**需要注意的是，这时候xiaohong变量也具有uname和age属性了。 使用了静态类型，不仅意味着变量的类型不可以改变，还意味着类型的属性和方法也跟着确定了。这个特点就大大提高了程序的健壮性，并且编辑器这时候也会给你很好的语法提示，加快了你的开发效率。 2.2分类 在 TypeScript 静态类型分为两种，一种是基础静态类型，一种是对象类型 2.2.1基础静态类型 基础静态类型非常简单，只要在声明变量的后边加一个:号，然后加上对应的类型。比如下面的代码，就是声明了一个数字类型的变量，叫做count。 12const count : number = 918;const myName :string = &#x27;jspang&#x27; null,undefinde,symbol,boolean,void这些都是最常用的基础数据类型 2.2.2对象类型 新建一个文件demo3.ts,然后写下如下代码。 这就是一个经典的对象类型，也是最简单的对象类型。 12345678const xiaoJieJie: &#123; name: string, age: number,&#125; = &#123; name: &quot;大脚&quot;, age: 18,&#125;;console.log(xiaoJieJie.name); 变量xiaoJieJies必须是一个数组，数组里的内容必须是字符串 12const xiaoJieJies: String[] = [&quot;谢大脚&quot;, &quot;刘英&quot;, &quot;小红&quot;];const xiaoJieJies: String[] = [&quot;谢大脚&quot;, &quot;刘英&quot;, 123];//把字符串改为数字直接给我们报错 现在都讲究面向对象编程,用类的形式，来定义变量。 12class Person &#123;&#125;const dajiao: Person = new Person();//这个意思就是`dajiao`必须是一个`Person`类对应的对象才可以。 函数类型 我们还可以定义一个，并确定返回值。 123const jianXiaoJieJie: () =&gt; string = () =&gt; &#123; return &quot;大脚&quot;;&#125;; 箭头函数: 1234567891011121314151617x =&gt; x * x 相当于 function(x)&#123;return x*x&#125;// 两个参数返回后面的值(x, y) =&gt;x*y + y*y//没有参数() =&gt; 999//单个参数 () 是可选的：var display =（）=&gt;void= x=&gt;&#123; console.log(&quot;output is&quot;+2)；&#125;// 可变参数(x, y, ...rest) =&gt;&#123; var i,sum = x+y; for (i=0;i&lt;rest.length;i++)&#123; sum += rest[i]; &#125; return sum;&#125; 那我们现在总结一下对象类型可以有几种形式： 对象类型 数组类型 类类型 函数类型 这几种形式我们在TypeScript里叫做对象类型。 2.2.3TypeScript 中的类型注释和类型推断 类型注解和类型推断，这两个概念在我们编写 TypeScript 代码时会一直使用(重点) 新建一个文件demo4.ts ,然后看代码： 12let count: number;count = 123; 这段代码就是类型注解，显示的告诉代码，我们的**count变量就是一个数字类型，这就叫做类型注解。** type inferrence 类型推断 当你明白了类型注解的概念之后，再学类型推断就更简单了，先来看一段代码。还是在Demo4.ts文件中写入下面的代码。 1let countInference = 123; 这时候我并没有显示的告诉你变量countInference是一个数字类型，但是如果你把鼠标放到变量上时，你会发现 TypeScript 自动把变量注释为了number（数字）类型，也就是说它是有某种推断能力的，通过你的代码 TS 会自动的去尝试分析变量的类型。这个就彷佛是人的情商比较高，还没等女生表白那，你就已经看出她的心思。 工作使用问题（潜规则） 如果 TS 能够自动分析变量类型， 我们就什么也不需要做了 如果 TS 无法分析变量类型的话， 我们就需要使用类型注解 一个不用写类型注解的例子： 123const one = 1;const two = 2;const three = one + two; 一个用写类型注解的例子： 1234function getTotal(one, two) &#123; return one + two;&#125;const total = getTotal(1, 2); 这种形式，就需要用到类型注释了，one和two会显示为any类型。这时候如果你传字符串，你的业务逻辑就是错误的，所以你必须加一个类型注解 1234function getTotal(one: number, two: number) &#123; return one + two;&#125;const total = getTotal(1, 2); 这里有的一个问题是，为什么total这个变量不需要加类型注解，因为当one和two两个变量加上注解后，TypeScript 就可以自动通过类型推断，分析出变量的类型。 当然 TypeScript 也可以推断出对象中属性的类型，比如现在写一个小姐姐的对象，然后里边有两个属性。 1234const XiaoJieJie = &#123; name: &quot;刘英&quot;, age: 18,&#125;; 写完后你把鼠标放在XiaoJieJie对象上面，就会提示出他里边的属性，这表明 TypeScript 也分析出了对象的属性的类型。 在写 TypeScript 代码的一个重要宗旨就是每个变量，每个对象的属性类型都应该是固定的，如果你推断就让它推断，推断不出来的时候你要进行注释。 2.3.TypeScript 函数参数和返回类型定义 12345function getTotal(one: number, two: number) &#123; return one + two;&#125;const total = getTotal(1, 2); 虽然TypeScript可以自己推断出返回值是number类型。 合适的做法是给函数的返回值加上类型注解，代码如下： 1234function getTotal(one: number, two: number): number &#123; return one + two;&#125;const total = getTotal(1, 2); 这段代码就比较严谨了，所以小伙伴们在写代码时，尽量让自己的代码更加严谨。 2.3.1函数无返回值时定义方法 这就是没有返回值的函数，我们就可以给他一个类型注解void，代表没有任何返回值。 123function sayHello(): void &#123; console.log(&quot;hello world&quot;);&#125; 如果这样定义后，你再加入任何返回值，程序都会报错。 2.3.2never 返回值类型 如果一个函数是永远也执行不完的，就可以定义返回值为never，抛出了异常，这时候就无法执行完了)。 1234function errorFuntion(): never &#123; throw new Error(); console.log(&quot;Hello World&quot;);&#125; 还有一种是一直循环，也是我们常说的死循环，这样也运行不完，比如下面的代码： 1234function forNever(): never &#123; while (true) &#123;&#125; console.log(&quot;Hello JSPang&quot;);&#125; 2.3.3函数参数为对象(解构)？？？ 当一个函数的参数是对象时，我们如何定义参数对象的属性类型。我先写个一般**javaScript的写法**。 1234function add(&#123; one, two &#125;) &#123; return one + two;&#125;const total = add(&#123; one: 1, two: 2 &#125;); 在浏览器中你会看到直接报错了，意思是total有可能会是任何类型，那我们要如何给这样的参数加类型注解那？最初你可能会这样写。 1234function add(&#123; one: number, two: number &#125;) &#123; return one + two;&#125;const total = add(&#123; one: 1, two: 2 &#125;);//one为any类型 那正确的写法应该是这样的。 12345function add(&#123; one, two &#125;: &#123; one: number, two: number &#125;): number &#123; return one + two;&#125;const three = add(&#123; one: 1, two: 2 &#125;); 如果参数是对象，并且里边只有一个属性时，我们更容易写错。 错误代码如下： 12345function getNumber(&#123; one &#125;: number) &#123; return one;&#125;const one = getNumber(&#123; one: 1 &#125;); 看着好像没什么问题，但实际这是有问题的，正确的代码应该时这样的。 12345function getNumber(&#123; one &#125;: &#123; one: number &#125;): number &#123; return one;&#125;const one = getNumber(&#123; one: 1 &#125;); 这样写才是正确的写法，小伙伴们赶快动手练习一下吧，刚开始学你可能会觉的很麻烦，但是你写的时间长了，你就会发现有规矩还是好的。人向往自由，缺鲜有人能屈驾自由。 函数类型： 定义： 123456789101112131415161718192021222324252627282930313233function fname()&#123;&#125;function fname() :return_type&#123; return value;&#125;//参数function add(x:number,y:number):number&#123; return x+y&#125;console.log(add(1,2))//可选参数function buildName(firstname:string,lastname?:string)[:string]&#123; if(lastname)return firstname+&#x27; &#x27;+lastname; else return firstname;&#125;let result1=buildName(&quot;Bob&quot;);let result2=buildName(&quot;Bob&quot;,&quot;Adams&quot;)console.log(result1)console.log(result2)//默认参数function calculate(price:number,rate:number=0.5)&#123; var discount=price*rate; console.log(&quot;结果&quot;,discount);&#125;//剩余参数function buildName(firstName:sring,...restofNmae:string[])//不知道有多少个参数function addNumber(...nums:number[])&#123; var i; var sum:number=0; for(i=0;)&#125; 1234567891011121314151617181920212223//匿名函数var res=function([arguments])&#123;....&#125;/*匿名函数是一个没有函数名的函数。匿名函数在程序运行时动态声明，除了没有函数名外，其他的与标准函数一样。我们可以将匿名函数赋值给一个变量，这种表达式就成为函数表达式。*/var msg = function() &#123; return &quot;hello world&quot;; &#125; console.log(msg())var res = function(a:number,b:number) &#123; return a*b; &#125;; console.log(res(12,2))//构造函数TypeScript 也支持使用 JavaScript 内置的构造函数 Function() 来定义函数：var myFunction = new Function(&quot;a&quot;, &quot;b&quot;, &quot;return a * b&quot;); var x = myFunction(4, 3); console.log(x);//Lambda 函数 箭头函数( [param1, parma2,…param n] )=&gt;statement;var foo = (x:number)=&gt;10 + x console.log(foo(100)) //输出结果为 110 2.4.TypeScript 中数组类型的定义 2.4.1一般数组类型的定义 定义一个最简单的数组类型 1const numberArr = [1, 2, 3]; 这时候你把鼠标放在numberArr上面可以看出，这个数组的类型就是 number 类型。这是 TypeScript 通过类型推断自己推断出来的。 如果你要显示的注解，也非常简单，可以写成下面的形式。 123const numberArr: number[] = [1, 2, 3];const undefinedArr:undefined[]=[undefined,undefined]const stringArr: string[] = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]; 2.4.2多类型数组 只要加个()，然后在里边加上|就可以了，具体 1const arr: (number | string)[] = [1, &quot;string&quot;, 2]; 2.4.3数组中对象类型 1234const xiaoJieJies: &#123; name: string, age: Number &#125;[] = [ &#123; name: &quot;刘英&quot;, age: 18 &#125;, &#123; name: &quot;谢大脚&quot;, age: 28 &#125;,]; 这种形式看起来比较麻烦，而且如果有同样类型的数组，写代码也比较麻烦，TypeScript 为我们准备了一个概念，叫做**类型别名(type alias)。** 2.4.3.1类型别名 以type关键字开始。现在定义一个Lady的别名。 12345type Lady = &#123; name: string, age: Number &#125;;const xiaoJieJies: Lady[] = [ &#123; name: &quot;刘英&quot;, age: 18 &#125;, &#123; name: &quot;谢大脚&quot;, age: 28 &#125;,]; 这时候有的小伙伴就会问了，我用类进行定义可以吗？答案是可以的，比如我们定义一个Madam的类,然后用这个类来限制数组的类型也是可以的。 12345678class Madam &#123; name: string; age: number;&#125;const xiaoJieJies: Madam[] = [ &#123; name: &quot;刘英&quot;, age: 18 &#125;, &#123; name: &quot;谢大脚&quot;, age: 28 &#125;,]; 2.5元组的使用和类型约束 TypeScript 中提供了元组的概念，这个概念是JavaScript中没有的。但是不要慌张，其实元组在开发中并不常用。一般只在**数据源是CVS这种文件的时候，会使用元组。**其实你可以把元组看成数组的一个加强，它可以更好的控制或者说规范里边的类型。 2.5.1元组的基本应用 我们先来看一个数组和这个数组注解的缺点 1const xiaojiejie = [&quot;dajiao&quot;, &quot;teacher&quot;, 28]; 1const xiaojiejie: (string | number)[] = [&quot;dajiao&quot;, 28, &quot;teacher&quot;]; **简单的把数组中的位置调换了一下，但是TypeScript并不能发现问题，**这时候我们需要一个更强大的类型，来解决这个问题，这就是元组。 元组和数组类似，但是类型注解时会不一样。 1const xiaojiejie: [string, string, number] = [&quot;dajiao&quot;, &quot;teacher&quot;, 28]; 这时候我们就把数组中的每个元素类型的位置给固定住了，这就叫做元组。 2.5.2元组的使用 目前我的工作中不经常使用元组，因为如果要使用元组，完全可以使用对象的形式来代替，**但是如果你维护老系统，你会发现有一种数据源时CSV,这种文件提供的就是用逗号隔开的，如果要严谨的编程就需要用到元组了。**例如我们有这样一组由CSV提供的。 123&quot;dajiao&quot;, &quot;teacher&quot;, 28;&quot;liuying&quot;, &quot;teacher&quot;, 18;&quot;cuihua&quot;, &quot;teacher&quot;, 25; 如果数据源得到的数据时这样的，你就可以使用元组了。 12345const xiaojiejies: [string, string, number][] = [ [&quot;dajiao&quot;, &quot;teacher&quot;, 28], [&quot;liuying&quot;, &quot;teacher&quot;, 18], [&quot;cuihua&quot;, &quot;teacher&quot;, 25],]; 2.6TypeScript 的 interface 接口 就是不符合要求的会直接被筛选掉，那最好的解决方法就是写一个接口。TypeScript 中的接口，就是用来规范类型的。 1234567891011const screenResume = (name: string, age: number, bust: number) =&gt; &#123; age &lt; 24 &amp;&amp; bust &gt;= 90 &amp;&amp; console.log(name + &quot;进入面试&quot;); age &gt; 24 || (bust &lt; 90 &amp;&amp; console.log(name + &quot;你被淘汰&quot;));&#125;;screenResume(&quot;大脚&quot;, 18, 94);const getResume = (name: string, age: number, bust: number) =&gt; &#123; console.log(name + &quot;年龄是：&quot; + age); console.log(name + &quot;胸围是：&quot; + bust);&#125;;getResume(&quot;大脚&quot;, 18, 94); 写好后，好像我们的程序写的不错，可以在终端中使用ts-node demo8.ts进行查看。这时候老板又增加了需求，说我必须能看到这些女孩的简历。于是你又写了这样一个方法。 这时候问题来了，程序开发中一直强调“代码重用”，两个方法用的类型注解一样，需要作个统一的约束。大上节课我们学了一个类型别名的知识可以解决代码重复的问题，这节课我们就学习一个更常用的语法 2.6.1接口（Interface）. 我们**可以把这两个重复的类型注解，定义成统一的接口。**代码如下： 12345interface Girl &#123; name: string; age: number; bust: number;&#125; 有了接口后，我们的程序也要作一些修改，需要写成下面的样子。这样就更像是面向对象编程了。 1234567891011121314151617const screenResume = (girl: Girl) =&gt; &#123; girl.age &lt; 24 &amp;&amp; girl.bust &gt;= 90 &amp;&amp; console.log(girl.name + &quot;进入面试&quot;); girl.age &gt; 24 || (girl.bust &lt; 90 &amp;&amp; console.log(girl.name + &quot;你被淘汰&quot;));&#125;;const getResume = (girl: Girl) =&gt; &#123; console.log(girl.name + &quot;年龄是：&quot; + girl.age); console.log(girl.name + &quot;胸围是：&quot; + girl.bust);&#125;;const girl = &#123; name: &quot;大脚&quot;, age: 18, bust: 94,&#125;;screenResume(girl);getResume(girl); 这时候我们代码就显得专业了很多，以后再用到同样的接口也不怕了，直接使用girl就可以了。 2.6.2接口和类型别名的区别 现在我们学了接口，也学过了类型别名，这两个语法用起来基本一样，但是也有少许的不同。 类型别名可以直接给类型，比如string，而接口必须代表对象。 比如我们的类型别名可以写出下面的代码： 1type Girl1 = stirng; 但是接口就不能这样写，它必须代表的是一个对象，也就是说，你初始化girl的时候，必须写出下面的形式. 12345const girl = &#123; name: &quot;大脚&quot;, age: 18, bust: 94,&#125;; 2.6.3接口非必选值得定义 这节课我们多学一点，因为接口这里的知识点还是挺多的。比如这时候增加可选项，那接口如何定义那？其实typeScript已经为我们准备好了相应的办法，就是在:号前加一个? 比如把Girl的接口写成这样。 123456interface Girl &#123; name: string; age: number; bust: number; waistline?: number;&#125; 然后我们再修改一下getResume方法，写成这样。 12345const getResume = (girl: Girl) =&gt; &#123; console.log(girl.name + &quot;年龄是：&quot; + girl.age); console.log(girl.name + &quot;胸围是：&quot; + girl.bust); girl.waistline &amp;&amp; console.log(girl.name + &quot;腰围是：&quot; + girl.waistline);&#125;; 这时候在定义girl对象的时候，就可以写saistline（腰围），也可以不写了。 2.6.4允许加入任意值 简历一般是有自由发挥的空间的，所以这时候需要一些任意值，就是自己愿意写什么就写什么。这时候interface接口也是支持的。 1234567interface Girl &#123; name: string; age: number; bust: number; waistline?: number; [propname: string]: any;&#125; 这个的意思是，属性的名字是字符串类型，属性的值可以是任何类型。 这时候我们在对象里给一个性别,代码如下： 1234567const girl = &#123; name: &quot;大脚&quot;, age: 18, bust: 94, waistline: 21, sex: &quot;女&quot;,&#125;; 再修改一下代码，这首就没有错误了。 123456const getResume = (girl: Girl) =&gt; &#123; console.log(girl.name + &quot;年龄是：&quot; + girl.age); console.log(girl.name + &quot;胸围是：&quot; + girl.bust); girl.waistline &amp;&amp; console.log(girl.name + &quot;腰围是：&quot; + girl.waistline); girl.sex &amp;&amp; console.log(girl.name + &quot;性别是：&quot; + girl.sex);&#125;; 这时候我们的程序是不报错的，但是如果我们去掉刚才的设置，就会报错。 1[propname:string]:any; //去掉 2.6.5接口里的方法 接口里不仅可以存属性，还可以存方法，比如这时候有个say()方法，返回值是string类型。这时候你就不要再想成简历了，你需要更面向对象化的编程，想象成一个人。 12345678interface Girl &#123; name: string; age: number; bust: number; waistline?: number; [propname: string]: any; say(): string;&#125; 加上这个say()方法后，程序马上就会报错，因为我们对象里没有 say 方法。那我们就要给对象一个 say 方法 12345678910const girl = &#123; name: &quot;大脚&quot;, age: 18, bust: 94, waistline: 21, sex: &quot;女&quot;, say() &#123; return &quot;欢迎光临 ，红浪漫洗浴！！&quot;; &#125;,&#125;; 2.6.6接口和类的约束 我们都知道 JavaScript 从ES6里是有类这个概念的，类可以和接口很好的结合，我们先来看一个例子。下面的 1class XiaoJieJie implements Girl &#123;&#125; 这时候类会直接报错，所以我们需要把这个类写的完全点。 12345678class XiaoJieJie implements Girl &#123; name = &quot;刘英&quot;; age = 18; bust = 90; say() &#123; return &quot;欢迎光临 ，红浪漫洗浴！！&quot;; &#125;&#125; 2.6.7接口间的继承 接口也可以用于继承的，比如你新写一个Teacher接口，继承于Person接口。 123interface Teacher extends Girl &#123; teach(): string;&#125; 比如这时候老板说了，只看 Teacher 级别的简历，那我们需要修改getResume()方法。 123456const getResume = (girl: Teacher) =&gt; &#123; console.log(girl.name + &quot;年龄是：&quot; + girl.age); console.log(girl.name + &quot;胸围是：&quot; + girl.bust); girl.waistline &amp;&amp; console.log(girl.name + &quot;腰围是：&quot; + girl.waistline); girl.sex &amp;&amp; console.log(girl.name + &quot;性别是：&quot; + girl.sex);&#125;; 修改后，你就会发现下面我们调用getResume()方法的地方报错了,因为这时候传的值必须有Teach方法， 1getResume(girl); 修改girle对象，增加teach（）方法，这时候就不会报错了。 12345678910111213const girl = &#123; name: &quot;大脚&quot;, age: 18, bust: 94, waistline: 21, sex: &quot;女&quot;, say() &#123; return &quot;欢迎光临 ，红浪漫洗浴！！&quot;; &#125;, teach() &#123; return &quot;我是一个老师&quot;; &#125;,&#125;; 关于接口的知识就讲到这里吧，这基本包含了接口 80%的知识，还有些基本不用的语法，我就不讲了。如果课程中遇到，我们再讲。学会了接口，你还需要明白一件事，就是接口只是对我们开发的约束，在生产环境中并没有体现。 2.7TypeScript 中类的概念和使用 TypeScript 中类的概念和 ES6 中原生类的概念大部分相同，但是也额外增加了一些新的特性。 2.7.1类的基本使用 新建一个文件，叫做**demo10.ts,**然后定义一个最简单的Lady类,这里要使用关键字class,类里边有姓名属性和一个得到姓名的方法，代码如下： 12345678class Lady &#123; content = &quot;Hi，帅哥&quot;; sayHello() &#123; return this.content; &#125;&#125;const goddess = new Lady();console.log(goddess.sayHello()); 这是一个最简单的类了，如果你有些编程经验，对这个一定很熟悉，工作中几乎每天都会用到。 2.7.2类的继承 123456789101112131415class Lady &#123; content = &quot;Hi，帅哥&quot;; sayHello() &#123; return this.content; &#125;&#125;class XiaoJieJie extends Lady &#123; sayLove() &#123; return &quot;I love you&quot;; &#125;&#125;const goddess = new XiaoJieJie();console.log(goddess.sayHello());console.log(goddess.sayLove()); 类写好以后，我们声明的对象是XiaoJieJie这个类，我们同时执行sayHello()和sayLove()都是可以执行到的，这说明继承起作用了。 2.7.3类的重写 讲了继承，那就必须继续讲讲重写，重写就是子类可以重新编写父类里边的代码。 12345678class XiaoJieJie extends Lady &#123; sayLove() &#123; return &quot;I love you!&quot;; &#125; sayHello() &#123; return &quot;Hi , honey!&quot;; &#125;&#125; 然后我们再次运行ts-node demo10.ts来查看结果。 2.7.4super 关键字的使用 我们再多讲一点，就是super关键字的使用，比如我们还是想使用Lady类中说的话，但是在后面，加上你好两个字就可以了。这时候就可以使用super关键字，它代表父类中的方法。 12345678class XiaoJieJie extends Lady &#123; sayLove() &#123; return &quot;I love you!&quot;; &#125; sayHello() &#123; return super.sayHello() + &quot;。你好！&quot;; &#125;&#125; 2.7.5TypeScript 中类的访问类型 其实类的访问类型就是基于三个关键词private、protected和public,也是三种访问类型 1.先写一个简单的类 我们新建一个Demo11.ts文件 1234567class Person &#123; name: string;&#125;const person = new Person();person.name = &quot;jspang.com&quot;;console.log(person.name); 结果会打印出jspang.com。因为我们如果不在类里对name的访问属性进行定义，那么它就会默认是 2.public访问属性。(外部使用) 123class Person &#123; public name:string;&#125; 1234567891011class Person &#123; public name:string; public sayHello()&#123; console.log(this.name + &#x27;say Hello&#x27;) &#125;&#125;//-------以下属于类的外部--------const person = new Person()person.name = &#x27;jspang.com&#x27; //没有赋值默认是undefinedperson.sayHello()console.log(person.name) 3.private 访问属性（内部使用继承不行） private 访问属性的意思是，只允许再类的内部被调用，外部不允许调用 比如现在我们把 name 属性改成private,这时候在类的内部使用不会提示错误，而外部使用VSCode直接会报错。 1234567891011class Person &#123; private name:string; public sayHello()&#123; console.log(this.name + &#x27;say Hello&#x27;) //此处不报错 &#125;&#125;//-------以下属于类的外部--------const person = new Person()person.name = &#x27;jspang.com&#x27; //此处报错person.sayHello()console.log(person.name) //此处报错 4.protected 访问属性（继承无法使用） protected 允许在类内及继承的子类中使用 做一个例子，把name的访问属性换成protected,这时候外部调用name的代码会报错，内部的不会报错，和private一样。这时候我们再写一个Teacher类，继承于Person 1234567891011class Person &#123; protected name:string; public sayHello()&#123; console.log(this.name + &#x27;say Hello&#x27;) //此处不报错 &#125;&#125;class Teacher extends Person&#123; public sayBye()&#123; this.name; &#125;&#125; 这时候在子类中使用this.name是不报错的。 2.7.6TypeScript 类的构造函数 构造函数就是在类被初始化的时候，自动执行的一个方法。我们通过这个构造方法经常作很多需要提前完成的工作，比如显示页面前我们要从后台得到数据。直接看例子。 2.7.6.1类的构造函数 新建立一个页面Demo12.ts,然后在页面里新建一个 Person 类，类的里边定义一个name，但是name我们并不给他值,然后我们希望在new出对象的时候，直接通过传递参数的形式，给name赋值，并打印出来。这时候我们就需要用到构造函数了，构造函数的关键字是constructor。 123456789class Person&#123; public name :string ; constructor(name:string)&#123; this.name=name &#125;&#125;const person= new Person(&#x27;jspang&#x27;)console.log(person.name) 这是最常规和好理解的写法，那有没有更简单的写法那?当然有。 123456class Person&#123; constructor(public name:string)&#123; &#125;&#125;const person= new Person(&#x27;jspang&#x27;)console.log(person.name) 这种写法就相当于**你定义了一个name,然后在构造函数里进行了赋值，**这是一种简化的语法. 2.7.6.2类继承中的构造器 普通类的构造器我们已经会了，在子类中使用构造函数需要用super()调用父类的构造函数。 12345678910111213class Person&#123; constructor(public name:string)&#123;&#125;&#125;class Teacher extends Person&#123; constructor(public age:number)&#123; super(&#x27;jspang&#x27;) &#125;&#125;const teacher = new Teacher(18)console.log(teacher.age)console.log(teacher.name) 这就是子类继承父类并有构造函数的原则，就是在子类里写构造函数时，必须用super()调用父类的构造函数，第一句如果需要传值，也必须进行传值操作。就是是父类没有构造函数，子类也要使用super()进行调用，否则就会报错。 12345678class Person&#123;&#125;class Teacher extends Person&#123; constructor(public age:number)&#123; super() &#125;&#125;const teacher = new Teacher(18)console.log(teacher.age) 好了，这就是这节课我们所学的内容了，主要讲的就是类中的构造函数（也有叫构造器的） 2.8类第二步 2.8.1类的Getter、Setter 和 static 通过 Getter 和 Setter 的形式来访问和修改private属性。 2.8.1.1类的 Getter 和 Setter 我们新建一个文件Demo13.ts，然后声明一个XiaoJieJie（小姐姐）类，都知道小姐姐的年龄是不能随便告诉人，所以使用了private,这样别人就都不知道她的真实年龄，而只有她自己知道。 代码如下： 123class Xiaojiejie &#123; constructor(private _age:number)&#123;&#125;&#125; 就必须通过getter属性知道,注意我这里用的是属性，对他就是一个属性。getter属性的关键字是get,后边跟着类似方法的东西,但是你要注意，它并不是方法，归根到底还是属性。 12345678class Xiaojiejie &#123; constructor(private _age:number)&#123;&#125; get age()&#123; return this._age &#125;&#125;const dajiao = new Xiaojiejie(28)console.log(dajiao.getAge) 比如别人问的时候我们就偷摸的减少 10 岁。代码可以写成这样。 123456class Xiaojiejie &#123; constructor(private _age:number)&#123;&#125; get age()&#123; return this._age-10 &#125;&#125; 这时候大脚的年龄就编程了迷人的 18 岁，是不是通过这个小例子，一下子就明白了private和getter的用处。 _age是私有的，那类的外部就没办法改变，所以这时候可以用setter属性进行改变，代码如下： 123456789101112class Xiaojiejie &#123; constructor(private _age:number)&#123;&#125; get age()&#123; return this._age-10 &#125; set age(age:number)&#123; this._age=age &#125;&#125;const dajiao = new Xiaojiejie(28)dajiao.age=25console.log(dajiao.age) 其实setter也是可以保护私有变量的，现在大脚的年龄输出是 15 岁，这肯定不行，不符合法律哦，这样是我们在setter里给他加上个 3 岁，就可以了。 123set age(age:number)&#123; this._age=age+3 &#125; 2.8.1.2类中的 static 学习类，都知道要想使用这个类的实例，就要先New出来（），但有时候人们就是喜欢走捷径，有没有方法？肯定是有方法的。 比如我们先写一下最常规的写法： 12345678class Girl &#123; sayLove() &#123; return &quot;I Love you&quot;; &#125;&#125;const girl = new Girl();console.log(girl.sayLove()); 但是现在你不想new出对象，而直接使用这个方法，那TypeScript为你提供了快捷的方式，用static声明的属性和方法，不需要进行声明对象，就可以直接使用，代码如下。 123456class Girl &#123; static sayLove() &#123; return &quot;I Love you&quot;; &#125;&#125;console.log(Girl.sayLove()); 2.8.2类的只读属性和抽象类 这节主要讲一下类里的一个概念就是抽象类，抽象类很父类很像，都需要继承，但是抽象类里一般都有抽象方法。继承抽象类的类必须实现抽象方法才可以。那就是类里的只读属性readonly. 2.8.2.2类里的只读属性 readonly 新建一个文件Demo14.ts,然后写下面一个类，并进行实例化和赋值操作，代码如下： 123456class Person &#123; constructor(public name:string )&#123; &#125;&#125;const person = new Person(&#x27;jspang&#x27;)console.log(person.name) 写完后我们可以在终端(Terminal)中看一下结果,结果就应该是jspang。 就是在实例化对象时赋予的名字，以后不能再更改了，也就是我们常说的只读属性。 1234567class Person &#123; constructor(public name:string )&#123; &#125;&#125;const person = new Person(&#x27;jspang&#x27;)person.name= &#x27;谢广坤&#x27;console.log(person.name) 这时候就可以用一个关键词readonly,也就是**只读的意思，**来修改Person类代码。 12345678910class Person &#123; public readonly _name :string; constructor(name:string )&#123; this._name = name; &#125;&#125;const person = new Person(&#x27;jspang&#x27;)person._name= &#x27;谢广坤&#x27;console.log(person._name) 这样写完后，VSCode就回直接给我们报错，告诉我们_name属性是只读属性，不能修改。 2.8.2.3抽象类的使用 什么是抽象类那？服务员，有初级技师，高级技师，每一个岗位我都写成一个类，那代码就是这样的。 12345class Waiter &#123;&#125;class BaseTeacher &#123;&#125;class seniorTeacher &#123;&#125; 每个职位的技能有不同，这时候就可以用抽象类来解决问题。抽象类的关键词是abstract,里边的抽象方法也是abstract开头的，现在我们就写一个Girl的抽象类。 1234abstract class Girl&#123; abstract skill() //因为没有具体的方法，所以我们这里不写括号&#125; 有了这个抽象类，三个类就可以继承这个类，然后会要求必须实现skill()方法，代码如下： 12345678910111213141516171819202122abstract class Girl&#123; abstract skill() //因为没有具体的方法，所以我们这里不写括号&#125;class Waiter extends Girl&#123; skill()&#123; console.log(&#x27;大爷，请喝水！&#x27;) &#125;&#125;class BaseTeacher extends Girl&#123; skill()&#123; console.log(&#x27;大爷，来个泰式按摩吧！&#x27;) &#125;&#125;class seniorTeacher extends Girl&#123; skill()&#123; console.log(&#x27;大爷，来个SPA全身按摩吧！&#x27;) &#125;&#125; 我希望通过这个例子，你能对抽象类和抽象方法有一个比较深的认识。 3.tsconfig.json文件 3.1配置文件-初识 tsconfig.json 有人在 QQ 群里留言问我tsconfig.json是作什么的，我才意识到，我是应该详细的讲一下这个文件了，这个是 TypeScript 的文件。 3.1.1生成 tsconfig.json 文件 打开终端Terminal,输入tsc --init。 输入完成后，就会出现tsconfig.json文件，你可以打开简单的看一下，不过此时你可能看不懂。 其实它就是用来配置如何对ts文件进行编译的，我们都叫它 typescript 的编译配置文件。 3.1.2让 tsconfig.json 文件生效 你现在可以在文件夹跟目录建立一个demo.ts文件，然后编写一些最简单的代码，代码如下: 1const person: string = &quot;jspang&quot;; 用tsc demo.ts进行编译，编译后会得到demo.js文件。 1var person = &quot;jspang&quot;; 这时候好像一切都是正常的，但是我要告诉你的真相是tsconfig.json这个编译配置文件并没有生效。 此时我们打开tsconfig.json文件，找到complilerOptions属性下的removeComments:true选项，把注释去掉。 这个配置项的意思是，编译时不显示注释，也就是编译出来的js文件不显示注释内容。 现在你在文件中加入一些注释，比如： 12// I love jspangconst person: string = &quot;jspang&quot;; 这时候再运行编译代码tsc demo.ts，编译后打开demo.js文件，你会发现注释依然存在，说明tsconfig.json文件没有起作用。 如果要想编译配置文件起作用，我们可以直接运行tsc命令，这时候tsconfig.json才起作用，可以看到生成的js文件已经不带注释了。 3.1.3include 、exclude 和 files解决单个编译的问题 多个ts文件，我们却只想编译其中的一个文件时， 我们在项目根目录，新建一个文件demo2.ts文件，然后也写一段最简单的 ts 代码。 1const person2: string = &quot;jspang.com&quot;; 如果这时候我们在终端里运行tsc,虽然tsconfig.json生效了，但是两个文件都被我们编译了。这不是你想要的结果，我们可以用三种办法解决这个问题。 一：使用 include 配置 include属性是用来指定要编译的文件的， 写配置文件时有个坑需要注意，就是配置文件不支持单引号，所以里边都要使用双引号。 1234567&#123; &quot;include&quot;:[&quot;demo.ts&quot;], &quot;compilerOptions&quot;: &#123; //any something //........ &#125;&#125; 这时候再编译，就只编译demo.ts文件了。 二：使用 exclude 配置 include是包含的意思，exclude是不包含，除什么文件之外，**意思是写再这个属性之外的而文件才进行编译。**比如你还是要编译demo.ts文件 1234567&#123; &quot;exclude&quot;:[&quot;demo2.ts&quot;], &quot;compilerOptions&quot;: &#123; //any something //........ &#125;&#125; 这样写依然只有demo.ts被编译成了js文件。 三：使用 files 配置 files的配置效果和include几乎一样 1234567&#123; &quot;files&quot;:[&quot;demo.ts&quot;], &quot;compilerOptions&quot;: &#123; //any something //........ &#125;&#125; 结果是依然只有demo.ts文件被编译。这节课我们就学到这里，目的只是让大家初步了解一下tsconfig.js文件和它的使用方法，文件里边还有很多配置项，这些我们都会逐步讲到。 3.2配置文件-初识配置项 这节我们主要学习一下**compilerOptions配置项，**它是告诉TypeScript具体如何编译成js文件的，里边的配置项非常多，这节我们先来讲几个简单的配置项，目的是让你熟悉compilerOptions的使用方法。 3.2.1removeComments **removeComments是complerOptions里的一个子属性，它的用处是告诉TypeScript对编译出来的js文件是否显示注释（注解）。**比如我们现在把removeComments的值设置为true，就是在js中不显示注释。 如果我们把removeComments的值，设置为false,这时候demo.js里就会有注释内容了。 123&quot;use strict&quot;;// I‘m JSPangvar person = &quot;jspang&quot;; 3.2.2strict 属性 strict属性如果设置为true,就代表我们的编译和书写规范，要按照TypeScript最严格的规范来写， 如果我们把这个设置为false或者注释掉，意思是我们可以对设置一些不严格的写法。 strict为true:下面的项都为true 3.2.3noImplicitAny 属性 noImplicitAny属性的作用**允许你的注解类型any不用特意表明,** 为了更好的说明，我们举个例子,在demo.ts里，删除刚才的代码，然后写一个方法，方法的参数我们设置成任意类型(any)。 123function jspang(name) &#123; return name;&#125; 这时候我们的TypeScript是进行报错的，我们用tsc编译也是报错的。这就是因为我们开启了strict:true,我们先注释掉，然后把noImplicitAny的值设置为false,就不再报错了。 如果设置为noImplicitAny:true,意思就是值就算是 any（任意值），你也要进行类型注释。 123function jspang(name: any) &#123; return name;&#125; 你可以简单的理解为，设置为 true，就是必须明确置顶 any 类型的值。 3.2.4strictNullChecks 属性 我们先把strictNullChecks设置为false,它的意思就是，**不强制检查 NULL 类型。**我们举个例子，让你能一下子就明白，还是删除demo.ts里的代码，然后编写代码. 1const jspang: string = null; 代码写完后，你会发现这段代码是不报错的，如果是以前，一定是报错的，这就是我们配置了“不强制检验 null 类型”。如果你设成strictNullChecks:true，这时候就报错了。 3.2.5ts-node 遵循 tsconfig.js 文件 ts-node是遵循的，感兴趣的可以自行试一下。 这节课我们就是简单的认识一下compilerOptions属性的配置，其实这些你只要掌握方法，并不需要记忆，我也是记不住每一项是干嘛的，用的时候会查 API 就可以了。 3.3compilerOptions 配置内容详解 这节我们继续讲complierOptions里的配置项，里边的内容很多，我只能选几个重要的给大家讲讲，然后在这节最后，我会给出大家自己查询的方法。需要再次说明的是，这些配置项没必要记，因为他们真的不是每天都需要用到，所以你只要知道如何配置和重要的几项，学会在自己需要时如何查询就可以了。 3.3.1rootDir 和 outDir 工作中我们希望打包的js都生成在特定的一个文件夹里,比如build。 这时候你就可以通过配置outDir来配置，当然你也可以通过**rootDir来指定ts文件的位置**，比如我们把所有的 ts 文件都放到 src 下。那配置文件就应该这样写。 1234&#123; &quot;outDir&quot;: &quot;./build&quot; , &quot;rootDir&quot;: &quot;./src&quot; ,&#125; 这时候你再在Terminal中输入tsc,就会有不同的效果了。 3.3.2编译 ES6 语法到 ES5 语法-allowJs 现在你在src目录下用ES6的语法写了一个demo2.js文件，代码如下。允许编译javascript文件。 1export const name = &quot;jspang&quot;; 如果你不做任何配置，这时候试用tsc是没有效果的。你需要到tsconfig.js文件里进行修改，修改的地方有两个。 12&quot;target&quot;:&#x27;es5&#x27; , // 这一项默认是开启的，你必须要保证它的开启，才能转换成功&quot;allowJs&quot;:true, // 这个配置项的意思是联通 这两项都开启后，在使用tsc编译时，就会编译js文件了。 3.3.3sourceMap 属性映射 如果把sourceMap的注释去掉，在打包的过程中就会给我们生成sourceMap文件. sourceMap 简单说，Source map 就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。有了它，出错的时候，除错工具将直接显示原始代码，而不是转换后的代码。这无疑给开发者带来了很大方便。 3.3.4noUnusedLocals 和 noUnusedParameters 比如现在我们修改demo.ts文件的代码，改为下面的样子。 12const jspang: string = null;export const name = &quot;jspang&quot;; 这时候你会发现jspang这个变量没有任何地方使用，我们编译的话，它依然会被编译出来，这就是一种资源的浪费。 123456//编译后的文件&quot;use strict&quot;;exports.__esModule = true;exports.name = void 0;var jspang = null;exports.name = &quot;jspang&quot;; 这时候我们可以开启noUnusedLocals：true，开启后我们的程序会直接给我们提**示不能这样编写代码，**有没有使用的变量。 noUnusedParameters是针对于名优使用的函数的，方法和noUnusedLocals：true一样，小伙伴们自己尝试吧。 我们讲了几个最常用的方法，如果你需要全面的了解，可以查看这个网址： 3.4文档 https://www.tslang.cn/docs/handbook/compiler-options.html (编译选项详解) 自己进行查看就可以了。 4.联合类型和类型保护 这节视频将学习一下联合类型和相关的类型保护知识，需要注意的是，只有联合类型存在的情况下，才需要类型保护。普通的类型注解，并不需要我们这种特殊操作。那先来看一下什么是联合类型。 4.1联合类型展示18 所谓联合类型，可以认为**一个变量可能有两种或两种以上的类型。用代码举个例子，声明两个接口Waiter(服务员)接口和Teacher(技师)接口，然后在写一个judgeWho(判断是谁)的方法，里边传入一个animal(任意值)，这时候可以能是Waiter,也可能是Teacher。**所以我们使用了联合类型，关键符号是|(竖线)。 1234567891011interface Waiter &#123; anjiao: boolean; say: () =&gt; &#123;&#125;;&#125;interface Teacher &#123; anjiao: boolean; skill: () =&gt; &#123;&#125;;&#125;function judgeWho(animal: Waiter | Teacher) &#123;&#125; 通过这个简单的例子，你应该知道什么是联合类型了。 123function judgeWho(animal: Waiter | Teacher) &#123; animal.say();&#125; 但这时候问题来了，如果我直接写一个这样的方法，就会报错，因为**judgeWho不能准确的判断联合类型具体的实例是什么。** 这时候就需要再引出一个概念叫做**类型保护**，类型保护有很多种方法，这节讲几个最常使用的。 4.2类型保护-类型断言 4.2.1断言animal as Teacher 类型断言就是通过断言的方式确定传递过来的准确值，比如上面的程序，如果会**anjiao（按脚），说明他就是技师，这时候就可以通过断言animal as Teacher,**然后直接调用skill方法,程序就不再报错了。同样如果不会按脚，说明就是不同的服务员，这时候调用say()方法，就不会报错了。这就是通过断言的方式进行类型保护。也是最常见的一种类型保护形式。具体看代码: 1234567891011121314151617interface Waiter &#123; anjiao: boolean; say: () =&gt; &#123;&#125;;&#125;interface Teacher &#123; anjiao: boolean; skill: () =&gt; &#123;&#125;;&#125;function judgeWho(animal: Waiter | Teacher) &#123; if (animal.anjiao) &#123; (animal as Teacher).skill(); &#125;else&#123; (animal as Waiter).say(); &#125;&#125; 4.2.2类型保护-in 语法 我们还经常使用**in语法来作类型保护，比如用if来判断animal里有没有skill()方法。** 这里你可以赋值上面的judgeWho()方法，然后改一下名字，我这里改成了judgeWhoTwo()方法，具体程序如下: 1234567function judgeWhoTwo(animal: Waiter | Teacher) &#123; if (&quot;skill&quot; in animal) &#123; animal.skill(); &#125; else &#123; animal.say(); &#125;&#125; 这里的else部分能够自动判断，得益于TypeScript的自动判断。 4.2.3类型保护-typeof 语法 先来写一个新的add方法，方法接收两个参数，这两个参数可以是数字number也可以是字符串string,**如果我们不做任何的类型保护，只是相加，这时候就会报错。**代码如下: 123function add(first: string | number, second: string | number) &#123; return first + second;&#125; 解决这个问题，就可以直接使用typeof来进行解决。 ===号：比较两个运算元的值和类型是否都相等，如果都相等则结果为 true 例子： B=10; (A == B)为 false，A == ‘10’ 为 true (A === B)为 false，A === ‘10’ 为 false 123456function add(first: string | number, second: string | number) &#123; if (typeof first === &quot;string&quot; || typeof second === &quot;string&quot;) &#123; return `$&#123;first&#125;$&#123;second&#125;`;//字符串拼接 &#125; return first + second;&#125; 像上面这样写，就不报错了。这样就可以进行继续开心的编写程序了。 typescript使用${}字符串拼接方法 1234let v0:string=&#x27;这个是电压&#x27;let v1:number=220.35;let str=`这个是格式化字符串($&#123;v0&#125;:$&#123;v1&#125;V)`;console.log(str) 4.2.4类型保护-instanceof 语法 比如现在要作**类型保护的是一个对象，**这时候就可以使用instanceof语法来作。现在先写一个NumberObj的类，代码如下： 123class NumberObj &#123; count: number;&#125; 然后我们再写一个addObj的方法，这时候传递过来的参数，可以是任意的object,也可以是NumberObj的实例，然后我们返回相加值，当然不进行类型保护，这段代码一定是错误的。 123function addObj(first: object | NumberObj, second: object | NumberObj) &#123; return first.count + second.count;&#125; 报错不要紧，直接使用instanceof语法进行判断一下，就可以解决问题。 123456function addObj(first: object | NumberObj, second: object | NumberObj) &#123; if (first instanceof NumberObj &amp;&amp; second instanceof NumberObj) &#123; return first.count + second.count; &#125; return 0;&#125; 另外要说的是，instanceof 只能用在类上。这节课我介绍四种类型保护的方式，每种方式都在不同场景中使用(还有一些不太常用的类型保护方式，我就不讲了)，你需要自己深刻理解，多练习，在开发时才能灵活使用。 5.Enum 枚举类型 这节主要学一下 TypeScript 中枚举(enum)类型的使用，你如果在程序中能灵活的使用枚举(enum),会让程序有更好的可读性。 5.1.思考 通过掷色子随机选择一项服务，进行程序化模拟。这里我先用 JavaScript 的写法来编写。 初级程序员写法: 1234567891011function getServe(status: number) &#123; if (status === 0) &#123; return &quot;massage&quot;; &#125; else if (status === 1) &#123; return &quot;SPA&quot;; &#125; else if (status === 2) &#123; return &quot;dabaojian&quot;; &#125;&#125;const result = getServe(0);console.log(`我要去$&#123;result&#125;`); 中级程序员写法: 12345678910111213141516171819const Status = &#123; MASSAGE: 0, SPA: 1, DABAOJIAN: 2,&#125;;function getServe(status: any) &#123; if (status === Status.MASSAGE) &#123; return &quot;massage&quot;; &#125; else if (status === Status.SPA) &#123; return &quot;spa&quot;; &#125; else if (status === Status.DABAOJIAN) &#123; return &quot;dabaojian&quot;; &#125;&#125;const result = getServe(Status.SPA);console.log(`我要去$&#123;result&#125;`); 高级程序员写法: 12345678910111213141516171819enum Status &#123; MASSAGE, SPA, DABAOJIAN,&#125;function getServe(status: any) &#123; if (status === Status.MASSAGE) &#123; return &quot;massage&quot;; &#125; else if (status === Status.SPA) &#123; return &quot;spa&quot;; &#125; else if (status === Status.DABAOJIAN) &#123; return &quot;dabaojian&quot;; &#125;&#125;const result = getServe(Status.SPA);console.log(`我要去$&#123;result&#125;`); 这时候我们就引出了今天的主角枚举Enum。 5.2枚举类型的对应值 你调用时传一个1,也会输出我要去spa。 1const result = getServe(1); 这看起来很神奇，这是因为枚举类型是有对应的数字值的，默认是从 0 开始的。我们直接用console.log()就可以看出来了。 123console.log(Status.MASSAGE);console.log(Status.SPA);console.log(Status.DABAOJIAN); 可以看出结果就是0,1,2。那这时候不想默认从 0 开始，而是想从 1 开始。可以这样写。 12345enum Status &#123; MASSAGE = 1, SPA, DABAOJIAN,&#125; 5.3枚举通过下标反查 我们这里能打印出枚举的值(也有叫下标的)，那如果我们知道下标后，也可以通过反差的方法，得到枚举的值。 1console.log(Status.MASSAGE, Status[1]); 这样就进行了反查。 6. Typescript进阶 泛型我个人认为是 TypeScript 利的一个难点，我第一次学完后根本不能完全理解，所以从这节课开始，我们应该算是一个进阶教程了，难度也开始上来了，如果你一遍听不太明白，可以反复听几次，然后多做练习。 6.1TypeScript 函数泛型-难点 6.1.1编写一个联合类型 Demo 现在跟着我作一个简单的join方法，方法接受两个参数first和second,参数有可能是字符串类型，也有可能是数字类型。方法里为了保证都可以使用，所以我们只作了字符串的基本拼接。 1234function join(first: string | number, second: string | number) &#123; return `$&#123;first&#125;$&#123;second&#125;`;&#125;join(&quot;jspang&quot;, &quot;.com&quot;); 这个方法现在没有任何问题，但现在有这样一个需求，就是first参数如果传的是字符串类型，要求second也传字符串类型.同理，如果是number类型，就都是number类型。 那现在所学的知识就完成不了啦，所以需要学习泛型来解决这个问题。 6.1.2初始泛型概念-generic 泛型：[generic - 通用、泛指的意思],那最简单的理解，泛型就是泛指的类型。 泛型的定义使用&lt;&gt;（尖角号）进行定义的，比如现在给join方法一个泛型，名字就叫做JSPang(起这个名字的意思，就是你可以随便起一个名字，但工作中要进行语义化。),后边的参数，这时候他也使用刚定义的泛型名称。然后在正式调用这个方法时，就需要具体指明泛型的类型啦。 1234function join&lt;JSPang&gt;(first: JSPang, second: JSPang) &#123; return `$&#123;first&#125;$&#123;second&#125;`;&#125;join &lt; string &gt; (&quot;jspang&quot;, &quot;.com&quot;); 如果要是number类型，就直接在调用方法的时候进行更改就可以了。 1join &lt; number &gt; (1, 2); 6.1.3泛型中数组的使用 如果传递过来的值要求是数字，如何用泛型进行定义那?两种方法，第一种是直接使用[]，第二种是使用Array&lt;泛型&gt;。形式不一样，其他的都一样。 第一种写法: 1234function myFun&lt;ANY&gt;(params: ANY[]) &#123; return params;&#125;myFun &lt; string &gt; ([&quot;123&quot;, &quot;456&quot;]); 第二种写法: 1234function myFun&lt;ANY&gt;(params: Array&lt;ANY&gt;) &#123; return params;&#125;myFun &lt; string &gt; ([&quot;123&quot;, &quot;456&quot;]); 在工作中，我们经常使用**&lt;T&gt;**来作泛型的表示 6.1.4多个泛型的定义 一个函数只能定义一个泛型吗?当然不是，是可以定义多个的，这里还是拿join方法举例，定义多个泛型，比如第一个泛型用T,第二个用P代表。 1234function join&lt;T, P&gt;(first: T, second: P) &#123; return `$&#123;first&#125;$&#123;second&#125;`;&#125;join &lt; number, string &gt; (1, &quot;2&quot;); 会了两种，你也就会了三种以上，泛型在造轮子的时候经常使用，因为造轮子很多东西都需要灵活性。泛型给了我们很好的灵活性。需要注意的是，如果函数定义了多个泛型，使用时要对应的定义出具体的类型。 6.1.5泛型的类型推断了解 泛型也是支持类型推断的，比如下面的代码并没有报错，这就是类型推断的功劳。 1234function join&lt;T, P&gt;(first: T, second: P) &#123; return `$&#123;first&#125;$&#123;second&#125;`;&#125;join(1, &quot;2&quot;); 但个人不建议大量使用类型推断，这会让你的代码易读和健壮性都会下降，所以这个知识点，大家做一个了解就可以了。 6.2TypeScript 类中泛型 这节课在看看类中泛型的使用方法。 6.2.1编写一个基本类 为了下面的教学演示，所以我先编写一个基本的类SelectGirl,在类的构造函数中(constructor)需要传递一组女孩的名称，然后再通过下边展现女孩的名称，代码如下： 123456789class SelectGirl &#123; constructor(private girls: string[]) &#123;&#125; getGirl(index: number): string &#123; return this.girls[index]; &#125;&#125;const selectGirl = new SelectGirl([&quot;大脚&quot;, &quot;刘英&quot;, &quot;晓红&quot;]);console.log(selectGirl.getGirl(1)); 写完后，我们可以在终端中使用ts-node Demo.ts进行预览，可以看到控制台中输出了刘英的名字。学到现在你写这样的一个类应该是非常容易的了。 现在问题来了，比如现在更好的保护小姐姐，这些小姐姐使用编号啦，那我们程序要如何修改。需要写成下面的样子，这时候我们代码看起来就没有那么优雅了,在 TypeScript 中，编写复杂代码的时候，会经常使用泛型。 123456class SelectGirl &#123; constructor(private girls: string[] | number[]) &#123;&#125; getGirl(index: number): string | number &#123; return this.girls[index]; &#125;&#125; 6.2.2初始类的泛型 这时候我们要用泛型重构代码，要如何作那？有了上节课的基础，应该很好理解，就是用&lt;&gt;编写，我们把代码修改成了这个样子。 123456789class SelectGirl&lt;T&gt; &#123; constructor(private girls: T[]) &#123;&#125; getGirl(index: number): T &#123; return this.girls[index]; &#125;&#125;const selectGirl = new SelectGirl([&quot;大脚&quot;, &quot;刘英&quot;, &quot;晓红&quot;]);console.log(selectGirl.getGirl(1)); 这时候代码并不报错，也使用了泛型，但是在实例化对象的时候，**TypeScript 是通过类型推断出来的。需要在实例化对象的时候，对泛型的值进行确定，**比如是string类型，就这样写。 1const selectGirl = new SelectGirl() &lt; string &gt; [&quot;大脚&quot;, &quot;刘英&quot;, &quot;晓红&quot;]; 6.2.3泛型中的继承 现在需求又变了，要求返回是一个对象中的name,也就是下面的代码要改成这个样子。 1return this.girls[index].name; 现在的代码一定时报错的，但是这时候还要求我们这么做，意思就是说传递过来的值必须是一个对象类型的，里边还要有name属性。这时候就要用到继承了，我用接口的方式来实现。写一个Girl的接口，每个接口里都要有 name 属性。代码如下： 123interface Girl &#123; name: string;&#125; 有了接口后用extends关键字实现泛型继承，代码如下： 123class SelectGirl&lt;T extends Girl&gt; &#123; ...&#125; 这句代码的意思是泛型里必须有一个name属性，因为它继承了Girl接口。 现在程序还是报错的，因为我们getGirl方法的返回类型还不对，这时**候应该是一个string类型才对，**所以代码应该改为下面的样子： 1234567891011121314151617interface Girl &#123; name: string;&#125;class SelectGirl&lt;T extends Girl&gt; &#123; constructor(private girls: T[]) &#123;&#125; getGirl(index: number): string &#123; return this.girls[index].name; &#125;&#125;const selectGirl = new SelectGirl([ &#123; name: &quot;大脚&quot; &#125;, &#123; name: &quot;刘英&quot; &#125;, &#123; name: &quot;晓红&quot; &#125;,]);console.log(selectGirl.getGirl(1)); 我们回过头来看一下这段代码的意思，就是我们在SelectGirl类中使用了泛型，意思是我不知道我以后要用什么类型，但是我有一个约束条件，这个类型，必须要有一个name属性。这个在工作中经常使用，所以必须要好好理解这的知识。 初学泛型肯定会很难理解，我当时看书也是看的一脸懵，经过反复的实验和看别人的源代码，才对泛型有了比较深的理解。 6.2.4泛型约束 现在的泛型可以是任意类型，可以是对象、字符串、布尔、数字都是可以的。但你现在要求这个泛型必须是string或者number类型。我们还是拿上面的例子，不过把代码改为最初的样子。 123456789class SelectGirl&lt;T&gt; &#123; constructor(private girls: T[]) &#123;&#125; getGirl(index: number): T &#123; return this.girls[index]; &#125;&#125;const selectGirl = new SelectGirl&lt;string&gt;([&quot;大脚&quot;, &quot;刘英&quot;, &quot;晓红&quot;]);console.log(selectGirl.getGirl(1)); 然后进行约束，这时候还是可以使用关键字extends来进行约束，把代码改成下面的样子。 123class SelectGirl&lt;T extends number | string&gt; &#123; //.....&#125; 作为教学泛型讲这些就可以了，但是**在实际工作中，泛型的应用更广泛和复杂，**这些需要在实际项目中不断精进和加深理解，有句话说的非常好，师傅领进门，修行在个人了。 6.3初识命名空间-Namespace 这节课为了有更好的演示效果，我们要在浏览器中运行代码。这就要求我们重新创建一个项目，直接在桌面上建立一个文件夹TSWeb。 6.3.1搭建浏览器开发环境步骤 如何搭建一个最基础的 TS 开发环境了。正好这节课也需要，我们就从新搭建一下。如果你已经很熟悉这部分内容可以跳过。 建立好文件夹后，打开 VSCode，把文件夹拉到编辑器当中，然后打开终端，运行npm init -y,创建package.json文件。 生成文件后，我们接着在终端中运行tsc -init,生成tsconfig.json文件。 新建src和build文件夹，再建一个index.html文件。 在src目录下，新建一个page.ts文件，这就是我们要编写的ts文件了。 配置tsconfig.json文件，设置outDir和rootDir(在 15 行左右)，也就是设置需要编译的文件目录，和编译好的文件目录。 然后编写index.html，引入&lt;script src=&quot;./build/page.js&quot;&gt;&lt;/script&gt;,当让我们现在还没有page.js文件。 编写page.ts文件，加入一句输出console.log('jspang.com'),再在控制台输入tsc,就会生成page.js文件 再到浏览器中查看index.html文件，如果按F12可以看到jspang.com，说明我们的搭建正常了。 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;script src=&quot;./build/page.js&quot;&gt;&lt;/script&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; 这就是你开发最基础的前端项目时需要作的环境配置。我觉的学习这东西，学会了就要用，如果不用你很快就会忘记。所以以后你在做项目，请尽量使用TypeScript来进行编写。 6.3.2没有命名空间时的问题 为了你更好的理解，先写一下这样代码，用类的形式在index.html中实现header,content和Footer部分，类似我们常说的模板。 在page.ts文件里，写出下面的代码： 12345678910111213141516171819202122232425262728293031class Header &#123; constructor() &#123; const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Header&quot;; document.body.appendChild(elem); &#125;&#125;class Content &#123; constructor() &#123; const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Content&quot;; document.body.appendChild(elem); &#125;&#125;class Footer &#123; constructor() &#123; const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Footer&quot;; document.body.appendChild(elem); &#125;&#125;class Page &#123; constructor() &#123; new Header(); new Content(); new Footer(); &#125;&#125; 写完后我们用tsc进行编译一次，然后修改index.html文件，在&lt;body&gt;标签里引入&lt;script&gt;标签，并实例化Page，代码如下: 123&lt;body&gt; &lt;script&gt;new Page();&lt;/script&gt;&lt;/body&gt; 这时候再到浏览器进行预览，看起来没有什么问题，但是有经验的程序员就会发现，这样写全部都是全局变量（通过查看./build/page.js文件可以看出全部都是var声明的变量）。过多的全局变量会让我们代码变的不可维护。 这时候你在浏览器的控制台(Console)中，分别输入Header、Content、Footer和Page都时可以拿到对应的变量的,说明他们全都是全局变量。 其实你理想的是，只要有Page这个全局变量就足够了，剩下的可以模块化封装起来，不暴露到全局。 6.3.4命名空间的使用 **命名空间这个语法，很类似编程中常说的模块化思想，**比如webpack打包时，**每个模块有自己的环境，不会污染其他模块,不会有全局变量产生。**命名空间就跟这个很类似，注意这里是类似，而不是相同。 命名空间声明的关键词是namespace **比如声明一个namespace Home,需要暴露出去的类，可以使用export关键词，这样只有暴漏出去的类是全局的，**其他的不会再生成全局污染了。修改后的代码如下： 123456789101112131415161718192021222324252627282930313233namespace Home &#123; class Header &#123; constructor() &#123; const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Header&quot;; document.body.appendChild(elem); &#125; &#125; class Content &#123; constructor() &#123; const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Content&quot;; document.body.appendChild(elem); &#125; &#125; class Footer &#123; constructor() &#123; const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Footer&quot;; document.body.appendChild(elem); &#125; &#125; export class Page &#123;//暴露出来 constructor() &#123; new Header(); new Content(); new Footer(); &#125; &#125;&#125; TS 代码写完后，再到index.html文件中进行修改，用命名空间的形式进行调用，就可以正常了。 写完后，记得用tsc编译一下，当然你也可以使用tsc -w进行监视了，只要有改变就会进行重新编译。 1new Home.Page(); 现在再到浏览器中进行查看，可以看到现在就只有Home.Page是在控制台可以得到的，其他的Home.Header…这些都是得不到的，说明只有Home.Page是全局的，其他的都是模块化私有的。 这就是 **TypeScript 给我们提供的类似模块化开发的语法，**它的好处就是让全局变量减少了很多，**实现了基本的封装，**减少了全局变量的污染。 6.4深入命名空间 6.4.1用命名空间实现组件化 上节课的代码虽实现了模块化和全局变量的污染，但是我们工作中分的要更细致一些，会单独写一个components的文件，然后进行组件化。 在src目录下新建一个文件components.ts，编写代码如下： 1234567891011121314151617181920212223namespace Components &#123; export class Header &#123; constructor() &#123; const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Header&quot;; document.body.appendChild(elem); &#125; &#125; export class Content &#123; constructor() &#123; const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Content&quot;; document.body.appendChild(elem); &#125; &#125; export class Footer &#123; constructor() &#123; const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Footer&quot;; document.body.appendChild(elem); &#125; &#125;&#125; 这里需要注意的是，我每个类(class)都使用了export导出，导出后就可以在page.ts中使用这些组件了。比如这样使用-代码如下。 123456789namespace Home &#123; export class Page &#123; constructor() &#123; new Components.Header(); new Components.Content(); new Components.Footer(); &#125; &#125;&#125; 这时候你可以使用tsc进行重新编译，但在预览时，你会发现还是会报错，找不到Components,想解决这个问题，我们必须要在index.html里进行引入components.js文件。 12&lt;script src=&quot;./build/page.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./build/components.js&quot;&gt;&lt;/script&gt; 这样才可以正常的出现效果。但这样引入太麻烦了，可不可以像webpack一样，只生成一个文件那？那答案是肯定的。 6.4.2多文件编译成一个文件 直接打开tsconfig.json文件，然后找到outFile配置项，这个就是用来生成一个文件的设置，但是如果设置了它，就不再支持&quot;module&quot;:&quot;commonjs&quot;设置了，我们需要把它改成&quot;module&quot;:&quot;amd&quot;,然后在去掉对应的outFile注释，设置成下面的样子。 1234&#123; &quot;module&quot;:&quot;amd&quot;， &quot;outFile&quot;: &quot;./build/page.js&quot;&#125; 配置好后，删除掉build下的js文件，然后用tsc进行再次编译。 然后删掉index.html文件中的component.js,在浏览器里还是可以正常运行的。 6.4.3子命名空间 也就是说在命名空间里，再写一个命名空间,比如在Components.ts文件下修改代码如下。 123456namespace Components &#123; export namespace SubComponents &#123; export class Test &#123;&#125; &#125; //someting ...&#125; 写完后在控制台再次编辑tsc，然后你在浏览器中也是可以查到这个命名空间的Components.SubComponents.Test(需要刷新页面后才会显示)。 通过两节课的时间，基本讲完了命名空间的内容，在工作中如果遇到，这些知识已经完全够用，所以这部分内容就先到这里了。 6.5TypeScript 使用 import 语法 那这节我们就把上节的代码改成import引入。 6.5.1修改 components.ts 文件 现在去掉components.ts里的namespace命名空间代码，写成 ES6 的 export 导出模式。代码如下： 1234567891011121314151617181920212223export class Header &#123; constructor() &#123; const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Header&quot;; document.body.appendChild(elem); &#125;&#125;export class Content &#123; constructor() &#123; const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Content&quot;; document.body.appendChild(elem); &#125;&#125;export class Footer &#123; constructor() &#123; const elem = document.createElement(&quot;div&quot;); elem.innerText = &quot;This is Footer&quot;; document.body.appendChild(elem); &#125;&#125; 现在三个类就都已经用export导出了，也就是说可以实现用import进行引入了。 修改 page.ts 文件 来到page.ts文件，去掉namespace命名空间对应的代码，然后使用 import 语法进行导入Header、Content和Footer,代码如下： 12345678import &#123; Header, Content, Footer &#125; from &quot;./components&quot;;export class Page &#123; constructor() &#123; new Header(); new Content(); new Footer(); &#125;&#125; 现在看起来确实和工作中写的代码非常类似了。这时候可以使用tsc进行编译。然后可以看到编译好的代码都是define开头的(这是 amd 规范的代码，不能直接在浏览器中运行，可以在 Node 中直接运行)，这种代码在浏览器中是没办法被直接运行的，需要其他库(require.js)的支持。 引入 require.js 我这里使用了一个现成的 CDN 的require.js,地址你可以直接复制，然后用&lt;script&gt;标签进行引入。 Require.js 的 CDN 地址： https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.js 复制好 URL 地址后，记得使用&lt;script&gt;标签进行引入，代码如下。 1&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.js&quot;&gt;&lt;/script&gt; 这时候就可以解析define这样的语法了。然后把page.ts中加入default关键字，如果不加是没办法直接引用到的。 123456789import &#123; Header, Content, Footer &#125; from &quot;./components&quot;;export default class Page &#123; constructor() &#123; new Header(); new Content(); new Footer(); &#125;&#125; 这时候再用tsc进行编译一下，你会发现还是又问题。因为使用export default这种形式的语法，需要在html里用require来进行引入。 require 方式引入 因为你已经加入了require.js这个库，所以现在可以直接在代码中使用require了。具体代码如下： 1234567&lt;body&gt; &lt;script&gt; require([&quot;page&quot;], function (page) &#123; new page.default(); &#125;); &lt;/script&gt;&lt;/body&gt; 写完这部，刷新页面，可以看到正常显示出来了，虽然用起来比较麻烦，但是我们还是实现了用import来进行引入，当我们又了webpack和Parcel的时候就不会这么麻烦，这些都交给打包工具来处理就好了。 25. 用 Parcel 打包 TypeScript 代码 上节课代码配置起来非常麻烦，步骤也很多。工作中一定是有更好的解决方案的。其实最通用的有两种解决方案Webpack和Parcel。webpack不用多说，只要是前端基本都会，这几年Parcel也开始崛起，用的人也越来越多。所以这节课就讲一下，如何使用Parcel来打包TypeScript代码。 建立一个新项目 这里给出新建项目的步骤，如果你已经熟悉此过程，可以跳过。 教学需要，这里我们重新建立一个项目TSTest,在桌面新建立一个文件夹，然后在VSCode中打开。 打开终端，输入npm init -y,创建package.json文件 在终端中输入tsc --init,创建tsconfig.json文件 修改tsconfig.json配置rootDir和outDir. 新建src文件夹，在里边建立index.html,page.ts文件 编写index.html文件，并引入page.ts文件 编写page.ts文件。 index.html 文件代码： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;script src=&quot;./page.ts&quot;&gt;&lt;/script&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; page.ts 文件代码： 12const teacher: string = &quot;jspang&quot;;console.log(teacher); 这时候我们并不能正常的预览出效果，我们需要Parcel的帮忙。 Parcel 的安装和使用 Parcel 可以通过npm或者yarn来进行安装，我这里npm安装很慢，会 5 分钟左右，所以我使用yarn来进行安装。代码如下。 1yarn add --dev parcel@next 使用 yarn 安装大概需要 1 分钟左右，这些主要看你自身的网络情况。 安装好以后，打开package.json文件，可以看到这样一段代码，我安装的版本是^2.0.0-beta.1,如果你学习时和这个版本不一样，操作可能会稍有不同。 修改package.json里边的代码。 123456&#123; &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;parcel ./src/index.html&quot; &#125;,&#125; 这个意思就是使用parcel对index.html进行一个编译。 然后打开终端输入yarn test,这时候终端会给出一个地址http://localhost:1234,把地址放到浏览器上，可以看到浏览器的控制台会输出jspang。 这说明Parcel会自动对index.html中引入的TypeScript文件进行编译，然后打包好后，就可以直接使用了。 使用Parcel大大简化了我们的配置过程，如果你想详细学习Parcel可以自行学习，毕竟我们这个是 TypeScript 的教程，所以更多的 Parcel 知识就不作介绍了。 26. 在 TypeScript 中使用 JQuery 这个需求也经常使用，就是在 TypeScript 的代码中使用其他类库，其实这里就涉及到一个类型文件(Type file)的问题，网上有大量别人写好的类型文件，我们只要下载使用就可以了。 引入 JQuery 框架库 接着上节课的代码，在TSTest文件夹的src目录下，引入JQuery文件，这里采用CDN的形式进行引入。 BootCDN 地址： https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.js 直接在index.html加入&lt;script&gt;标签，代码如下： 1&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.js&quot;&gt;&lt;/script&gt; 有了 jquery 框架，就可以在TypeScript文件中进行使用JQuery的语法了。 然后在page.ts文件中编写如下代码。 123456const teacher: string = &quot;jspang&quot;;console.log(teacher);$(function () &#123; alert(&quot;jspang&quot;);&#125;); 写完后到终端中输入yarn test进行编译和启动服务。然后在地址栏输入了http://localhost:1234,可以看到程序可以正常输出，也没有任何的报错。 安装 types/jquery(解决方法) 第一种：就是安装别人写好的文件 但是在vscode中是会报错的，这时候就需要我们安装类型文件type file,直接可以用 npm 进行安装。 1npm i @types/jquery 这个安装的时间还是比较长的，所以视频中我就不进行展示了。 第二种:简单粗暴 还有一种简单粗暴的方法的方式就是直接在page.ts文件的头部加入这句代码： 1declare var $: any; 第三种：自己写一个.d.ts声明文件的类库，如果你用的类库很少见，就需要自己写了。这个写起来还是很麻烦的。我只是简单的学过，但在工作中从来没自己写过，所以也不推荐给大家。比如 JQuery 就有几十个接口，如果你要写，这个文件会写很长，所以原则就是有别人写好的就直接用，实在没有就用粗暴的方法，如果实在不行，再考虑写.d.ts声明文件。 TypeScrip 的视频我们就暂时告一段落，紧接着会更新 Vue3 的课程，希望下伙伴们继续跟我一期学习。","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端开发","slug":"前端开发","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"狂神说mysql","slug":"狂神说mysql","date":"2021-04-02T05:58:10.000Z","updated":"2021-04-23T13:29:14.504Z","comments":true,"path":"2021/04/02/狂神说mysql/","link":"","permalink":"http://example.com/2021/04/02/%E7%8B%82%E7%A5%9E%E8%AF%B4mysql/","excerpt":"","text":"一.什么是数据库 数据库 ( DataBase , 简称DB ) 概念 : 长期存放在计算机内,有组织,可共享的大量数据的集合,是一个数据 “仓库” 作用 : 保存,并能安全管理数据(如:增删改查等),减少冗余… 数据库总览 : 关系型数据库 ( SQL ) 非关系型数据库 ( NOSQL ) MySQL , Oracle , SQL Server , SQLite , DB2 , … 关系型数据库通过外键关联来建立表与表之间的关系 Redis , MongoDB , … 非关系型数据库通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定 什么是DBMS 数据库管理系统 ( DataBase Management System ) 数据库管理软件 , 科学组织和存储数据 , 高效地获取和维护数据 因为我们要学习的MySQL应该算是一个数据库管理系统. MySQL简介 概念 : 是现在流行的开源的,免费的 关系型数据库 历史 : 由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。 特点 : 免费 , 开源数据库 小巧 , 功能齐全 可运行于Windows或Linux操作系统 可适用于中小型甚至大型网站应用 SQLyog 可手动操作,管理MySQL数据库的软件工具 特点 : 简洁 , 易用 , 图形化 mysql的数据存放在data下面 使用SQLyog管理工具自己完成以下操作 : 连接本地MySQL数据库 新建MySchool数据库 查询历史记录 新建表 字段 GradeID : int(11) , Primary Key (pk) GradeName : varchar(50) 数据库名称MySchool 新建数据库表(grade) 小技巧以后sql太复杂,先手动操作再学习历史记录 常用命令（0）连接数据库 打开MySQL命令窗口 在DOS命令行窗口进入 安装目录\\mysql\\bin 可设置环境变量，设置了环境变量，可以在任意目录打开！ 连接数据库语句 : mysql -h 服务器主机地址 -u 用户名 -p 用户密码 注意 : -p后面不能加空格,否则会被当做密码的内容,导致登录失败 ! 几个基本的数据库操作命令 : 特点：–注释 所有语句用；结尾 12345678910111213141516171819202122--启动mysql -uroot -p密码(不能有空格)//1.update user set password=password(&#x27;123456&#x27;)where user=&#x27;root&#x27;; --修改密码--2flush privileges; 刷新数据库--3 show databases; --显示所有数据库--4 5 6use dbname；--打开某个数据库show tables; --先打开，再显示数据库mysql中所有的表describe student; --显示表mysql数据库student表的列信息--7create database name; --创建数据库--8use databasename; --选择数据库--9exit; 退出Mysql连接--10-- 本身唯一注释/*多行注释*/? 命令关键词 : --寻求帮助 二.数据库操作 2.1结构化查询语句分类 常见命令（1）数据库操作 命令行操作数据库 创建数据库 : create database [if not exists] 数据库名; 删除数据库 : drop database [if exists] 数据库名; 查看数据库 : show databases; 使用数据库 : use 数据库名; 对比工具操作数据库 学习方法： 对照SQLyog工具自动生成的语句学习 固定语法中的单词需要记忆 2.2创建数据表(重点+2.4) 属于DDL的一种，语法 : 123456789101112131415161718create table [if not exists] `表名`( &#x27;字段名1&#x27; 列类型 [属性][索引][注释], &#x27;字段名2&#x27; 列类型 [属性][索引][注释], #... &#x27;字段名n&#x27; 列类型 [属性][索引][注释])[表类型][表字符集][注释];--实例--表名称和字段用``飘--用括号括起来CREATE TABLE IF NOT EXISTS `student`( `id` INT(4)/*长度*/ NOT NULL AUTO_INCREMENT COMMENT &#x27;学号&#x27;, --1.AUTO_INCREMENT 自增 2.字符串统一使用单引号3.除了最后一个都要加, `name` VARCHAR (20) NOT NULL DEFAULT &#x27;12345&#x27; COMMENT &#x27;密码&#x27;, `sex` VARCHAR (2) NOT NULL DEFAULT &#x27;女&#x27; COMMENT &#x27;性别&#x27;, PRIMARY KEY (`id`))ENGINE=INNODB DEFAULT CHARSET=utf8 说明 : 反引号用于区别MySQL保留字与普通字符而引入的 (键盘esc下面的键). 2.3数据值和列类型（重点） 列类型 : 规定数据库中该列存放的数据类型 1.数值类型 2.字符串类型 3.日期和时间型数值类型 NULL值 理解为 “没有值” 或 “未知值” 不要用NULL进行算术运算 , 结果仍为NULL 2.4数据字段属性（重点） UnSigned 无符号的 声明该数据列不允许负数 . id int unsigned not null auto_increment, ZEROFILL 0填充的 不足位数的用0来填充 , 如int(3),5则为005 Auto_InCrement 自动增长的 , 每添加一条数据 , 自动在上一个记录数上加 1(默认) 通常用于设置主键 , 且为整数类型 可定义起始值和步长 当前表设置步长(AUTO_INCREMENT=100) : 只影响当前表 SET @@auto_increment_increment=5 ; 影响所有使用自增的表(全局) NULL 和 NOT NULL 默认为NULL , 即没有插入该列的数值 如果设置为NOT NULL , 则该列必须有值 DEFAULT 默认的 用于设置默认值 例如,性别字段,默认为&quot;男&quot; , 否则为 “女” ; 若无指定该列的值 , 则默认值为&quot;男&quot;的值 1234567891011121314-- 目标 : 创建一个school数据库-- 创建学生表(列,字段)-- 学号int 登录密码varchar(20) 姓名,性别varchar(2),出生日期(datatime),家庭住址,email-- 创建表之前 , 一定要先选择数据库CREATE TABLE IF NOT EXISTS `student` ( `id` int(4) NOT NULL AUTO_INCREMENT COMMENT &#x27;学号&#x27;, `name` varchar(30) NOT NULL DEFAULT &#x27;匿名&#x27; COMMENT &#x27;姓名&#x27;, `pwd` varchar(20) NOT NULL DEFAULT &#x27;123456&#x27; COMMENT &#x27;密码&#x27;, `sex` varchar(2) NOT NULL DEFAULT &#x27;男&#x27; COMMENT &#x27;性别&#x27;, `birthday` datetime DEFAULT NULL COMMENT &#x27;生日&#x27;, `address` varchar(100) DEFAULT NULL COMMENT &#x27;地址&#x27;, `email` varchar(50) DEFAULT NULL COMMENT &#x27;邮箱&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 常见命令（2）查看数据库表定义的逆向操作： 123456-- 查看数据库的定义命令SHOW CREATE DATABASE school;-- 查看数据表的定义SHOW CREATE TABLE student;-- 显示表结构DESC student; -- 设置严格检查模式(不能容错了)SET sql_mode=&#x27;STRICT_TRANS_TABLES&#x27;; 2.5数据表的类型 常见数据库引擎 设置数据表的类型 1234CREATE TABLE 表名()ENGINE = MyISAM (or InnoDB)-- 查看mysql所支持的引擎类型 (表类型)SHOW ENGINES; MySQL的数据表的类型 : MyISAM , InnoDB , HEAP , BOB , CSV等… 常见的 MyISAM 与 InnoDB 类型： 锁：MyISAM表锁定 InniDB行锁定 经验 ( 适用场合 ) : 适用 MyISAM : 节约空间及相应速度 适用 InnoDB : 安全性 , 事务处理及多用户操作数据表 引擎的物理存储 数据表的存储位置 MySQL数据表以文件方式存放在磁盘中 包括表文件 , 数据文件 , 以及数据库的选项文件 位置 : Mysql安装目录\\data\\下存放数据表 . 目录名对应数据库名 , 该目录下文件名对应数据表 . 注意 : MyISAM类型数据表对应三个文件 : * . frm – 表结构定义文件 * . MYD – 数据文件 ( data ) * . MYI – 索引文件 ( index ) InnoDB类型*数据表只有一个 .frm文件 , 以及上一级目录的ibdata1文件 设置charset 设置数据表字符集 我们可为数据库,数据表,数据列设定不同的字符集，设定方法 : (保证不同环境可以运用)创建时通过命令来设置 , 如 : CREATE TABLE 表名()CHARSET = utf8; 如无设定 , 则根据MySQL数据库配置文件 my.ini 中的参数设定 2.6修改数据库 修改表 ( ALTER TABLE ) 修改表名 :ALTER TABLE 旧表名 RENAME AS 新表名 添加字段 : ALTER TABLE 表名 ADD字段名 列属性[属性] 修改字段 :mordify可以修改字段类型 change用来重命名 ALTER TABLE 表名 MODIFY 字段名 列类型[属性] --修改约束 ALTER TABLE 表名 CHANGE 旧字段名 新字段名 列属性[属性] --字段重命名 删除字段 : ALTER TABLE 表名 DROP 字段名 删除数据表 语法：DROP TABLE [IF EXISTS] 表名 IF EXISTS为可选 , 判断是否存在该数据表 如删除不存在的数据表会抛出错误 注意点： 可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！ 每个库目录存在一个保存当前数据库的选项文件db.opt。 注释： 多行注释 /* 注释内容 */ 单行注释 – 注释内容 (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）) 模式通配符： _ 任意单个字符 % 任意多个字符，甚至包括零字符 单引号需要进行转义 ’ **CMD命令行内的语句结束符可以为 “;”, “\\G”, “\\g”，**仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。 SQL对大小写不敏感 （关键字） 清除已有语句：\\c 三.MySQL数据管理 3,1外键（写一遍） 外键概念 如果公共关键字在一个关系中是主关键字，那么这个公共关键字被称为另一个关系的外键。由此可见，外键表示了两个关系之间的相关联系。以另一个关系的外键作主关键字的表被称为主表，具有此外键的表被称为主表的从表。 在实际操作中，将一个表的值放入第二个表来表示关联，所使用的值是第一个表的主键值(在必要时可包括复合主键值)。此时，第二个表中保存这些值的属性称为外键(foreign key)。 外键作用 保持数据一致性，完整性，主要目的是控制存储在外键表中的数据,约束。使两张表形成关联，外键只能引用外表中的列的值或使用空值。 创建外键 1建表时指定外键约束 123456789101112131415161718192021222324-- 创建外键的方式一 : 创建子表同时创建外键-- 年级表 (id\\年级名称)CREATE TABLE `grade` ( `gradeid` INT(10) NOT NULL AUTO_INCREMENT COMMENT &#x27;年级ID&#x27;, `gradename` VARCHAR(50) NOT NULL COMMENT &#x27;年级名称&#x27;, PRIMARY KEY (`gradeid`)) ENGINE=INNODB DEFAULT CHARSET=utf8-- 学生信息表 (学号,姓名,性别,年级,手机,地址,出生日期,邮箱,身份证号)CREATE TABLE `student` ( `studentno` INT(4) NOT NULL COMMENT &#x27;学号&#x27;, `studentname` VARCHAR(20) NOT NULL DEFAULT &#x27;匿名&#x27; COMMENT &#x27;姓名&#x27;, `sex` TINYINT(1) DEFAULT &#x27;1&#x27; COMMENT &#x27;性别&#x27;, `gradeid` INT(10) DEFAULT NULL COMMENT &#x27;年级&#x27;, `phoneNum` VARCHAR(50) NOT NULL COMMENT &#x27;手机&#x27;, `address` VARCHAR(255) DEFAULT NULL COMMENT &#x27;地址&#x27;, `email` VARCHAR(50) DEFAULT NULL COMMENT &#x27;邮箱&#x27;, `idCard` VARCHAR(18) DEFAULT NULL COMMENT &#x27;身份证号&#x27;, PRIMARY KEY (`studentno`), KEY `FK_gradeid` (`gradeid`), --key作为外键加上约束（执行引用） reference CONSTRAINT `FK_gradeid` FOREIGN KEY (`gradeid`) REFERENCES `grade` (`gradeid`)) ENGINE=INNODB DEFAULT CHARSET=utf8 2建表后修改 123-- 创建外键方式二 : 创建子表完毕后,修改子表添加外键ALTER TABLE `student`ADD CONSTRAINT `FK_gradeid` FOREIGN KEY (`gradeid`) REFERENCES `grade` (`gradeid`); 删除外键 操作：先删除 grade 表，发现报错 注意 : 删除具有主外键关系的表时 , 要先删子表 , 后删主表 12345-- 删除外键ALTER TABLE student DROP FOREIGN KEY FK_gradeid;-- 发现执行完上面的,索引还在,所以还要删除索引-- 注:这个索引是建立外键的时候默认生成的ALTER TABLE student DROP INDEX FK_gradeid; 注意：以上操作都是物理外键，数据库级别的外键，我们不建议使用(数据库过多，了解即可) 我们想使用多张表的数据，想使用外键操作(JAVA操作) 3.2DML语言(数据库管理语言) 数据库意义 ： 数据存储、数据管理 管理数据库数据方法： 通过SQLyog等管理工具管理数据库数据 通过DML语句管理数据库数据 DML语言 ：数据操作语言 用于操作数据库对象中所包含的数据 包括 :（语法注意事项） INSERT (添加数据语句) UPDATE (更新数据语句) DELETE (删除数据语句) 3.3添加数据 INSERT命令(背) 语法： 1INSERT INTO 表名[(字段1,字段2,字段3,...)] VALUES(&#x27;值1&#x27;,&#x27;值2&#x27;,&#x27;值3&#x27;) 注意 : 字段或值之间用英文逗号隔开 . ’ 字段1,字段2…’ 该部分可省略 , 但添加的值务必与表结构,数据列**,顺序相对应,且数量一致 .** 可同时插入多条数据 , values 后用英文逗号隔开 . 12345678910111213-- 使用语句如何增加语句?-- 语法 : INSERT INTO 表名[(字段1,字段2,字段3,...)] VALUES(&#x27;值1&#x27;,&#x27;值2&#x27;,&#x27;值3&#x27;)INSERT INTO grade(gradename) VALUES (&#x27;大一&#x27;);INSERT INTO grade VALUES (&#x27;大二&#x27;);--避免这样的写法，最好数据和字段一一对应-- 查询:INSERT INTO grade VALUE (&#x27;大二&#x27;)错误代码：1136-- 主键自增,那能否省略呢?可以省略，如果不写会一一匹配-- 结论:&#x27;字段1,字段2...&#x27;该部分可省略 , 但添加的值务必与表结构,数据列,顺序相对应,且数量一致.-- 一次插入多条数据用逗号隔开INSERT INTO grade(gradename) VALUES (&#x27;大三&#x27;),(&#x27;大四&#x27;);--对应多个属性INSERT INTO `student` (`name`,`pwd`,`sex`) VALUE (`张三`,`aaaa`,`男`) 练习题目 自己使用INSERT语句为课程表subject添加数据 . 使用到外键. 3.4修改数据 update命令 语法：update 对象 set 修改的值 1UPDATE 表名 SET column_name=value [,column_name2=value2,...] [WHERE condition]; 注意 : column_name 为要更改的数据列名，尽量带上`` value 为修改后的数据 , 可以为变量 , 具体指 , 表达式或者嵌套的SELECT结果 condition 为筛选条件 , 如不指定则修改该表的所有列数据(跑路操作),多个设置加上逗号 where条件子句 可以简单的理解为 : 有条件地从表中筛选数据 123-- 修改年级信息UPDATE grade SET gradename = &#x27;高中&#x27; WHERE gradeid = 1;--没有where所有的结果都改变UPDATE grade SET `birthday`=CURRENT_TIME WHERE `name`=&#x27;djjd&#x27; 3.4删除数据 DELETE命令 语法： 1DELETE FROM 表名 [WHERE condition]; 注意：condition为筛选条件 , 如不指定则删除该表的所有列数据 12-- 删除最后一个数据DELETE FROM grade WHERE gradeid = 5 TRUNCATE命令 作用：用于完全清空表数据 , 但表结构 , 索引 , 约束等不变 ; 语法： 123TRUNCATE [TABLE] table_name;-- 清空年级表TRUNCATE grade 注意：区别于DELETE命令 相同 : 都能删除数据 , 不删除表结构 , 但TRUNCATE速度更快 不同 : 使用TRUNCATE TABLE 重新设置AUTO_INCREMENT计数器(归零) 使用TRUNCATE TABLE不会对事务有影响 （事务后面会说） 测试： 1234567891011121314151617181920212223-- 创建一个测试表CREATE TABLE `test` ( `id` INT(4) NOT NULL AUTO_INCREMENT, `coll` VARCHAR(20) NOT NULL, PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8 -- 插入几个测试数据INSERT INTO test(coll) VALUES(&#x27;row1&#x27;),(&#x27;row2&#x27;),(&#x27;row3&#x27;);-- 删除表数据(不带where条件的delete)DELETE FROM test;-- 结论:如不指定Where则删除该表的所有列数据,自增当前值依然从原来基础上进行,会记录日志.-- 删除表数据(truncate)TRUNCATE TABLE test;-- 结论:truncate删除数据,自增当前值会恢复到初始值重新开始;不会记录日志. -- 同样使用DELETE清空不同引擎的数据库表数据.重启数据库服务后-- InnoDB : 自增列从初始值重新开始 (因为是存储在内存中,断电即失)-- MyISAM : 自增列依然从上一个自增数据基础上开始 (存在文件中,不会丢失) 四.使用DQL查询数据 DQL语言( Data Query Language 数据查询语言 )** 查询数据库数据 , 如SELECT语句 简单的单表查询或多表的复杂查询和嵌套查询 是数据库语言中最核心,最重要的语句 使用频率最高的语句 SELECT语法 123456789101112SELECT [ALL | DISTINCT] &#123;* | table.* | [table.field1[as alias1][,table.field2[as alias2]][,...]]&#125; FROM table_name [as table_alias]--(起别名) [left | right | inner join table_name2] -- 联合查询 [WHERE ...] -- 指定结果需满足的条件 [GROUP BY ...] -- 指定结果按照哪几个字段来分组 [HAVING] -- 过滤分组的记录必须满足的次要条件 [ORDER BY ...] -- 指定查询记录按一个或多个条件排序 [LIMIT &#123;[offset,]row_count | row_countOFFSET offset&#125;]; -- 指定查询的记录从哪条至哪条 注意 : [ ] 括号代表可选的 , { }括号代表必选得 指定查询字段 12345-- 查询表中所有的数据列结果 , 采用 **&quot; \\* &quot;** 符号; 但是效率低，不推荐 .-- 查询所有学生信息SELECT * FROM student;-- 查询指定列(学号 , 姓名)SELECT studentno,studentname FROM student; AS 子句作为别名 作用： 可给数据列取一个新别名 可给表取一个新别名 可把经计算或总结的结果用另一个新名称来代替 1234567-- 这里是为列取别名(当然as关键词可以省略)SELECT studentno AS 学号,studentname AS 姓名 FROM student;-- 使用as也可以为表取别名SELECT studentno AS 学号,studentname AS 姓名 FROM student AS s;-- 使用as,为查询结果取一个新名字-- CONCAT()函数拼接字符串SELECT CONCAT(&#x27;姓名:&#x27;,studentname) AS 新姓名 FROM student; DISTINCT关键字的使用 作用 : 去掉SELECT查询返回的记录结果中重复的记录 ( 返回所有列的值都相同 ) , 只返回一条 1234567-- # 查看哪些同学参加了考试(学号) 去除重复项SELECT * FROM result; -- 查看考试成绩SELECT studentno FROM result; -- 查看哪些同学参加了考试SELECT DISTINCT studentno FROM result; -- 了解:DISTINCT 去除重复项 , (默认是ALL) 使用表达式的列 数据库中的表达式 : 一般由文本值 , 列值 , NULL , 函数和操作符等组成 应用场景 : SELECT语句返回结果列中使用 SELECT语句中的ORDER BY , HAVING等子句中使用 DML语句中的 where 条件语句中使用表达式 1234567-- selcet查询中可以使用表达式SELECT @@auto_increment_increment; -- 查询自增步长SELECT VERSION(); -- 查询版本号SELECT 100*3-1 AS 计算结果; -- 表达式-- 学员考试成绩集体提分一分查看SELECT studentno,StudentResult+1 AS &#x27;提分后&#x27; FROM result; 避免SQL返回结果中包含 ’ . ’ , ’ * ’ 和括号等干扰开发语言程序. where条件语句 作用：用于检索数据表中 符合条件 的记录 搜索条件可由一个或多个逻辑表达式组成 , 结果一般为真或假. 逻辑操作符 测试 12345678910111213141516171819202122-- 满足条件的查询(where)SELECT Studentno,StudentResult FROM result;-- 查询考试成绩在95-100之间的SELECT Studentno,StudentResultFROM resultWHERE StudentResult&gt;=95 AND StudentResult&lt;=100;-- AND也可以写成 &amp;&amp;SELECT Studentno,StudentResultFROM resultWHERE StudentResult&gt;=95 &amp;&amp; StudentResult&lt;=100;-- 模糊查询(对应的词:精确查询)SELECT Studentno,StudentResultFROM resultWHERE StudentResult BETWEEN 95 AND 100;-- 除了1000号同学,要其他同学的成绩SELECT studentno,studentresultFROM resultWHERE studentno!=1000;-- 使用NOTSELECT studentno,studentresultFROM resultWHERE NOT studentno=1000; 模糊查询 ：比较操作符 LIKE：SQL匹配 注意： 数值数据类型的记录之间才能进行算术运算 ; 相同数据类型的数据之间才能进行比较 ; 测试： 1234567891011121314151617181920212223242526272829303132333435363738394041424344-- 模糊查询 between and \\ like \\ in \\ null-- =============================================-- LIKE-- =============================================-- 查询姓刘的同学的学号及姓名-- like结合使用的通配符 : % (代表0到任意个字符) _ (一个字符)SELECT studentno,studentname FROM studentWHERE studentname LIKE &#x27;刘%&#x27;;-- 查询姓刘的同学,后面只有一个字的SELECT studentno,studentname FROM studentWHERE studentname LIKE &#x27;刘_&#x27;;-- 查询姓刘的同学,后面只有两个字的SELECT studentno,studentname FROM studentWHERE studentname LIKE &#x27;刘__&#x27;;-- 查询姓名中含有 嘉 字的SELECT studentno,studentname FROM studentWHERE studentname LIKE &#x27;%嘉%&#x27;;-- 查询姓名中含有特殊字符的需要使用转义符号 &#x27;\\&#x27;-- 自定义转义符关键字: ESCAPE &#x27;:&#x27;-- =============================================-- IN-- =============================================-- 查询学号为1000,1001,1002的学生姓名SELECT studentno,studentname FROM studentWHERE studentno IN (1000,1001,1002);-- 查询地址在北京,南京,河南洛阳的学生SELECT studentno,studentname,address FROM studentWHERE address IN (&#x27;北京&#x27;,&#x27;南京&#x27;,&#x27;河南洛阳&#x27;);-- =============================================-- NULL 空-- =============================================-- 查询出生日期没有填写的同学-- 不能直接写=NULL , 这是代表错误的 , 用 is nullSELECT studentname FROM studentWHERE BornDate IS NULL;-- 查询出生日期填写的同学SELECT studentname FROM studentWHERE BornDate IS NOT NULL;-- 查询没有写家庭住址的同学(空字符串不等于null)SELECT studentname FROM studentWHERE Address=&#x27;&#x27; OR Address IS NULL; 连接查询 JOIN 对比 左中右查询 七种Join： 测试 where-- 等值查询 join （连接的表）on（判断的条件） --连接查询 结果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/*连接查询 如需要多张数据表的数据进行查询,则可通过连接运算符实现多个查询内连接 inner join 查询两个表中的结果集中的交集外连接 outer join 左外连接 left join (以左表作为基准,右边表来一一匹配,匹配不上的,返回左表的记录,右表以NULL填充) 右外连接 right join (以右表作为基准,左边表来一一匹配,匹配不上的,返回右表的记录,左表以NULL填充)*/-- 查询参加了考试的同学信息(学号,学生姓名,科目编号,分数)SELECT * FROM student;SELECT * FROM result;/*思路:(1):分析需求,确定查询的列来源于两个类,student result,连接查询(2):确定使用哪种连接查询?(内连接)*/--并集SELECT s.studentno,studentname,subjectno,StudentResultFROM student as sINNER JOIN result as rON r.studentno = s.studentno-- 右连接(也可实现)SELECT s.studentno,studentname,subjectno,StudentResultFROM student sRIGHT JOIN result rON r.studentno = s.studentno-- 等值连接SELECT s.studentno,studentname,subjectno,StudentResultFROM student s , result rWHERE r.studentno = s.studentno-- 左连接 (查询了所有同学,不考试的也会查出来)SELECT s.studentno,studentname,subjectno,StudentResultFROM student s --查询s所有的值LEFT JOIN result rON r.studentno = s.studentno-- 查一下缺考的同学(左连接应用场景)SELECT s.studentno,studentname,subjectno,StudentResultFROM student sLEFT JOIN result rON r.studentno = s.studentnoWHERE StudentResult IS NULL-- 思考题:查询参加了考试的同学信息(学号,学生姓名,科目名,分数)SELECT s.studentno,studentname,subjectname,StudentResultFROM student sINNER JOIN result rON r.studentno = s.studentnoINNER JOIN `subject` subON sub.subjectno = r.subjectno-- 思考题:查询参加了考试的同学信息(学号,学生姓名,科目名,分数)SELECT s.studentno,studentname,subjectname,StudentResultFROM student sINNER JOIN result rON r.studentno = s.studentnoINNER JOIN `subject` subON sub.subjectno = r.subjectno-- 查询学员及所属的年级(学号,学生姓名,年级名)SELECT studentno AS 学号,studentname AS 学生姓名,gradename AS 年级名称FROM student sINNER JOIN grade gON s.`GradeId` = g.`GradeID`-- 查询科目及所属的年级(科目名称,年级名称)SELECT subjectname AS 科目名称,gradename AS 年级名称FROM SUBJECT subINNER JOIN grade gON sub.gradeid = g.gradeid-- 查询 数据库结构-1 的所有考试结果(学号 学生姓名 科目名称 成绩)SELECT s.studentno,studentname,subjectname,StudentResultFROM student sINNER JOIN result rON r.studentno = s.studentnoINNER JOIN `subject` subON r.subjectno = sub.subjectnoWHERE subjectname=&#x27;数据库结构-1&#x27; 自连接 数据表与自身进行连接 1234567891011121314151617181920212223242526272829/*自连接 数据表与自身进行连接需求:从一个包含栏目ID , 栏目名称和父栏目ID的表中 查询父栏目名称和其他子栏目名称*/-- 创建一个表CREATE TABLE `category` ( `categoryid` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT &#x27;主题id&#x27;, `pid` INT(10) NOT NULL COMMENT &#x27;父id&#x27;, `categoryName` VARCHAR(50) NOT NULL COMMENT &#x27;主题名字&#x27;, PRIMARY KEY (`categoryid`)) ENGINE=INNODB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8-- 插入数据INSERT INTO `category` (`categoryid`, `pid`, `categoryName`)VALUES(&#x27;2&#x27;,&#x27;1&#x27;,&#x27;信息技术&#x27;),(&#x27;3&#x27;,&#x27;1&#x27;,&#x27;软件开发&#x27;),(&#x27;4&#x27;,&#x27;3&#x27;,&#x27;数据库&#x27;),(&#x27;5&#x27;,&#x27;1&#x27;,&#x27;美术设计&#x27;),(&#x27;6&#x27;,&#x27;3&#x27;,&#x27;web开发&#x27;),(&#x27;7&#x27;,&#x27;5&#x27;,&#x27;ps技术&#x27;),(&#x27;8&#x27;,&#x27;2&#x27;,&#x27;办公信息&#x27;);--例子： 编写SQL语句,将栏目的父子关系呈现出来 (父栏目名称,子栏目名称)-- 核心思想:把一张表看成两张一模一样的表,然后将这两张表连接查询(自连接)SELECT a.categoryName AS &#x27;父栏目&#x27;,b.categoryName AS &#x27;子栏目&#x27;FROM category AS a,category AS bWHERE a.`categoryid`=b.`pid` 排序和分页 分页：缓解数据库的压力，给人体验更好瀑布流 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*============== 排序 ================语法 : ORDER BY ORDER BY 语句用于根据指定的列对结果集进行排序。 ORDER BY 语句默认按照ASC升序对记录进行排序。 如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。*/-- 查询 数据库结构-1 的所有考试结果(学号 学生姓名 科目名称 成绩)-- 按成绩降序排序SELECT s.studentno,studentname,subjectname,StudentResultFROM student sINNER JOIN result rON r.studentno = s.studentnoINNER JOIN `subject` subON r.subjectno = sub.subjectnoWHERE subjectname=&#x27;数据库结构-1&#x27;ORDER BY StudentResult DESC/*============== 分页 ================语法 : SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset好处 : (用户体验,网络传输,查询压力)推导: 第一页 : limit 0,5 第二页 : limit 5,5 第三页 : limit 10,5 ...... 第N页 : limit (pageNo-1)*pageSzie,pageSzie [pageNo:页码,pageSize:单页面显示条数]*/-- 每页显示5条数据SELECT s.studentno,studentname,subjectname,StudentResultFROM student sINNER JOIN result rON r.studentno = s.studentnoINNER JOIN `subject` subON r.subjectno = sub.subjectnoWHERE subjectname=&#x27;数据库结构-1&#x27;ORDER BY StudentResult DESC , studentnoLIMIT 0,5-- 查询 JAVA第一学年 课程成绩前10名并且分数大于80的学生信息(学号,姓名,课程名,分数)SELECT s.studentno,studentname,subjectname,StudentResultFROM student sINNER JOIN result rON r.studentno = s.studentnoINNER JOIN `subject` subON r.subjectno = sub.subjectnoWHERE subjectname=&#x27;JAVA第一学年&#x27;ORDER BY StudentResult DESCLIMIT 0,10 子查询 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/*============== 子查询 ================什么是子查询? 在查询语句中的WHERE条件子句中,又嵌套了另一个查询语句 嵌套查询可由多个子查询组成,求解的方式是由里及外; 子查询返回的结果一般都是集合,故而建议使用IN关键字;*/ -- 查询 数据库结构-1 的所有考试结果(学号,科目编号,成绩),并且成绩降序排列-- 方法一:使用连接查询SELECT studentno,r.subjectno,StudentResultFROM result rINNER JOIN `subject` subON r.`SubjectNo`=sub.`SubjectNo`WHERE subjectname = &#x27;数据库结构-1&#x27;ORDER BY studentresult DESC; -- 方法二:使用子查询(执行顺序:由里及外)SELECT studentno,subjectno,StudentResultFROM resultWHERE subjectno=( SELECT subjectno FROM `subject` WHERE subjectname = &#x27;数据库结构-1&#x27;)ORDER BY studentresult DESC; -- 查询课程为 高等数学-2 且分数不小于80分的学生的学号和姓名-- 方法一:使用连接查询SELECT s.studentno,studentnameFROM student sINNER JOIN result rON s.`StudentNo` = r.`StudentNo`INNER JOIN `subject` subON sub.`SubjectNo` = r.`SubjectNo`WHERE subjectname = &#x27;高等数学-2&#x27; AND StudentResult&gt;=80 -- 方法二:使用连接查询+子查询-- 分数不小于80分的学生的学号和姓名SELECT r.studentno,studentname FROM student sINNER JOIN result r ON s.`StudentNo`=r.`StudentNo`WHERE StudentResult&gt;=80 -- 在上面SQL基础上,添加需求:课程为 高等数学-2SELECT r.studentno,studentname FROM student sINNER JOIN result r ON s.`StudentNo`=r.`StudentNo`WHERE StudentResult&gt;=80 AND subjectno=( SELECT subjectno FROM `subject` WHERE subjectname = &#x27;高等数学-2&#x27;) -- 方法三:使用子查询-- 分步写简单sql语句,然后将其嵌套起来SELECT studentno,studentname FROM student WHERE studentno IN( SELECT studentno FROM result WHERE StudentResult&gt;=80 AND subjectno=( SELECT subjectno FROM `subject` WHERE subjectname = &#x27;高等数学-2&#x27; )) /*练习题目: 查 C语言-1 的前5名学生的成绩信息(学号,姓名,分数) 使用子查询,查询郭靖同学所在的年级名称*/ 分组和过滤 12345678910111213 SELECT subjectname,AVG(studentresult) AS 平均分,MAX(StudentResult) AS 最高分,MIN(StudentResult) AS 最低分 FROM result AS r INNER JOIN `subject` AS s ON r.subjectno = s.subjectno GROUP BY r.subjectno --group分组，因为max ,min的结果不能是聚合函数的 HAVING 平均分&gt;80; /* where写在group by前面. 要是放在分组后面的筛选 要使用HAVING.. 因为having是从前面筛选的字段再筛选（可以判断组），而where是从数据表中的&gt;字段直接进行的筛选的 */ 五.MySQL函数 常用函数 数据函数 12345SELECT ABS(-8); /*绝对值*/SELECT CEILING(9.4); /*向上取整*/SELECT FLOOR(9.4); /*向下取整*/SELECT RAND(); /*随机数,返回一个0-1之间的sql随机数*/SELECT SIGN(0); /*符号函数: 负数返回-1,正数返回1,0返回0*/ 字符串函数 1234567891011121314SELECT CHAR_LENGTH(&#x27;狂神说坚持就能成功&#x27;); /*返回字符串包含的字符数*/SELECT CONCAT(&#x27;我&#x27;,&#x27;爱&#x27;,&#x27;程序&#x27;); /*合并字符串,参数可以有多个*/SELECT INSERT(&#x27;我爱编程helloworld&#x27;,1,2,&#x27;超级热爱&#x27;); /*替换字符串,从某个位置开始替换某个长度*/SELECT LOWER(&#x27;KuangShen&#x27;); /*小写*/SELECT UPPER(&#x27;KuangShen&#x27;); /*大写*/SELECT LEFT(&#x27;hello,world&#x27;,5); /*从左边截取*/SELECT RIGHT(&#x27;hello,world&#x27;,5); /*从右边截取*/SELECT REPLACE(&#x27;狂神说坚持就能成功&#x27;,&#x27;坚持&#x27;,&#x27;努力&#x27;); /*替换字符串*/SELECT SUBSTR(&#x27;狂神说坚持就能成功&#x27;,4,6); /*截取字符串,开始和长度*/SELECT REVERSE(&#x27;狂神说坚持就能成功&#x27;); /*反转-- 查询姓周的同学,改成邹SELECT REPLACE(studentname,&#x27;周&#x27;,&#x27;邹&#x27;) AS 新名字FROM student WHERE studentname LIKE &#x27;周%&#x27;; 日期和时间函数 12345678910111213 SELECT CURRENT_DATE(); /*获取当前日期*/ SELECT CURDATE(); /*获取当前日期*/ SELECT NOW(); /*获取当前日期和时间*/ SELECT LOCALTIME(); /*获取当前日期和时间*/ SELECT SYSDATE(); /*获取当前日期和时间*/ -- 获取年月日,时分秒 SELECT YEAR(NOW()); SELECT MONTH(NOW()); SELECT DAY(NOW()); SELECT HOUR(NOW()); SELECT MINUTE(NOW()); SELECT SECOND(NOW()); 系统信息函数 12SELECT VERSION(); /*版本*/SELECT USER(); /*用户*/ 聚合函数where不能use 查出的都是单个，除非groupby 函数名称 描述 COUNT() 返回满足Select条件的记录总和数，如 select count(*) 【不建议使用 *，效率低】 SUM() 返回数字字段或表达式列作统计，返回一列的总和。 AVG() 通常为数值字段或表达列作统计，返回一列的平均值 MAX() 可以为数值字段，字符字段或表达式列作统计，返回最大的值。 MIN() 可以为数值字段，字符字段或表达式列作统计，返回最小的值。 123456789101112131415161718192021 -- 聚合函数 /*COUNT:非空的*/ SELECT COUNT(studentname) FROM student; SELECT COUNT(*) FROM student; SELECT COUNT(1) FROM student; /*推荐*/ -- 从含义上讲，count(1) 与 count(*) 都表示对全部数据行的查询。 -- count(字段) 会统计该字段在表中出现的次数，忽略字段为null 的情况。即不统计字段为null 的记录。 -- count(*) 包括了所有的列，相当于行数，在统计结果的时候，包含字段为null 的记录； -- count(1) 用1代表代码行，在统计结果的时候，包含字段为null 的记录 。 /* 很多人认为count(1)执行的效率会比count(*)高，原因是count(*)会存在全表扫描，而count(1)可以针对一个字段进行查询。其实不然，count(1)和count(*)都会对全表进行扫描，统计所有记录的条数，包括那些为null的记录，因此，它们的效率可以说是相差无几。而count(字段)则与前两者不同，它会统计该字段不为null的记录条数。 下面它们之间的一些对比： 1）在表没有主键时，count(1)比count(*)快 2）有主键时，主键作为计算条件，count(主键)效率最高； 3）若表格只有一个字段，则count(*)效率较高。 */ SELECT SUM(StudentResult) AS 总和 FROM result; SELECT AVG(StudentResult) AS 平均分 FROM result; SELECT MAX(StudentResult) AS 最高分 FROM result; SELECT MIN(StudentResult) AS 最低分 FROM result; 题目： 1234567891011121314151617 -- 查询不同课程的平均分,最高分,最低分 -- 前提:根据不同的课程进行分组 SELECT subjectname,AVG(studentresult) AS 平均分,MAX(StudentResult) AS 最高分,MIN(StudentResult) AS 最低分 FROM result AS r INNER JOIN `subject` AS s ON r.subjectno = s.subjectno GROUP BY r.subjectno HAVING 平均分&gt;80; Select SubjectName ,AVG(studentresult) As 平均分,MAX(StudentResult) as 最高分,Min(Student) /* where写在group by前面. 要是放在分组后面的筛选 要使用HAVING.. 因为having是从前面筛选的字段再筛选，而where是从数据表中的&gt;字段直接进行的筛选的 */ MD5 加密 一、MD5简介 MD5即Message-Digest Algorithm 5（信息-摘要算法5），**用于确保信息传输完整一致。**是计算机广泛使用的杂凑算法之一（又译摘要算法、哈希算法），主流编程语言普遍已有MD5实现。将数据（如汉字）运算为另一固定长度值，是杂凑算法的基础原理，MD5的前身有MD2、MD3和MD4。 二、实现数据加密 新建一个表 testmd5 123456 CREATE TABLE `testmd5` ( `id` INT(4) NOT NULL, `name` VARCHAR(20) NOT NULL, `pwd` VARCHAR(50) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 插入一些数据 1INSERT INTO testmd5 VALUES(1,&#x27;kuangshen&#x27;,&#x27;123456&#x27;),(2,&#x27;qinjiang&#x27;,&#x27;456789&#x27;) 如果我们要对pwd这一列数据进行加密，语法是： 1update testmd5 set pwd = md5(pwd); 如果单独对某个用户(如kuangshen)的密码加密： 12INSERT INTO testmd5 VALUES(3,&#x27;kuangshen2&#x27;,&#x27;123456&#x27;)update testmd5 set pwd = md5(pwd) where name = &#x27;kuangshen2&#x27;; 插入新的数据自动加密 1INSERT INTO testmd5 VALUES(4,&#x27;kuangshen3&#x27;,md5(&#x27;123456&#x27;)); 查询登录用户信息（md5对比使用，查看用户输入加密后的密码进行比对） 1SELECT * FROM testmd5 WHERE `name`=&#x27;kuangshen&#x27; AND pwd=MD5(&#x27;123456&#x27;); 六.事务和索引 事务transaction 什么是事务 事务就是将一组SQL语句放在同一批次内去执行(转账) 如果一个SQL语句出错,则该批次内的所有SQL都将被取消执行 MySQL事务处理只支持InnoDB和BDB数据表类型 事务的ACID原则 原子性(Atomic) 整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（ROLLBACK）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性(Consist) 一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少。也就是说：如果事务是并发多个，系统也必须如同串行事务一样操作。其主要特征是保护性和不变性(Preserving an Invariant)，以转账案例为例，假设有五个账户，每个账户余额是100元，那么五个账户总额是500元，如果在这个5个账户之间同时发生多个转账，无论并发多少个，比如在A与B账户之间转账5元，在C与D账户之间转账10元，在B与E之间转账15元，五个账户总额也应该还是500元，这就是保护性和不变性。 **隔离性(Isolated)**两个或者以上事务 隔离强调的是两个或两个以上同时发生（并发）的业务同时操作一个数据库，为了让两个事务一方面能都看到、得到正确的结果，一方面还要保证一定的效率而产生的不同的隔离级别。 隔离状态执行事务，并发执行时互相不干扰 隔离级别(4个) 123456789101112131415--演示过程必须开两个事务--1-楠哥，转账--2-楠哥老婆，查账，不错，钱已到账set session transaction isolation level repeatable read;SET transaction isolation level read uncommitted;SET transaction isolation level read committed;set transaction isolation level repeatable read;SET transaction isolation level serializable;SET GLOBAL transaction isolation level read uncommitted;SET GLOBAL transaction isolation level read committed;set GLOBAL transaction isolation level repeatable read;SET GLOBAL transaction isolation level serializable;--SESSION 和 GLOBAL 关键字用来指定修改的事务隔离级别的范围：要重启 隔离的问题： 1.脏读：事物A和事物B，事物A未提交的数据事物B可以读取到这里读取到的数据叫做“脏数据” 2.不可重复读:A事务在本次事务中，对自己操作过的数据，进行了多次读取发现数据不一致，不可重复读。 3.幻读（目前mysql用mvcc解决了）：A事务在本次事务中对未操作的数据进行多次查询，发现第一次没有，第二次出现了就像幻觉一样 （1）读未提交：read uncommitted（Q:脏读，不可重复读） 这种隔离级别最低，这种级别一般是在理论上存在，数据库隔离级别一般都高于该级别 简而言之第一个事务没提交，别的事物就能读，这种数据不一定是正确的因为人家可能回滚呀！ 案例： 楠哥发工资了，老婆让楠哥把工资打到他老婆的账号上，但是该事务并未提交，就让老婆去查看，老婆一看真的打了钱了，高高兴兴关了网页，此时楠哥急中生智进行回滚，钱瞬间回来，一次蒙混了一个月工资。所以楠哥老婆看到的数据我们称之为“脏数据”且读取不可重复。 （2）读已提交：read committed（Q:不可重复读） 能读到别的事物已经提交的数据。 A事务在本次事务中，对自己操作过的数据，进行了多次读取发现数据不一致，不可重复读。 简单点说就是不能让我好好的重复读，一个事务里读出来的数据都不一样，让不让人干活了。 发现钱少了，不可重复读：同一事物读出的东西不一样 （3）可重复读：repeatable read（Q:幻读） （4）串行化：serializable(解决一切问题但是慢) 持久性(Durable) 在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。事物没有提交恢复原状，提交了持久化数据库(提交了不可逆) 基本语法 – 注意: — 1.MySQL中默认是自动提交 — 2.使用事务时应先关闭自动提交 123456789101112131415161718192021222324-- 使用set语句来改变自动提交模式SET autocommit = 0; /*关闭*/SET autocommit = 1; /*开启*/ -- 注意:--- 1.MySQL中默认是自动提交--- 2.使用事务时应先关闭自动提交 -- 开始一个事务,标记事务的起始点START TRANSACTION 或者begin -- 提交一个事务给数据库COMMIT -- 将事务回滚,数据回到本次事务的初始状态ROLLBACK -- 还原MySQL数据库的自动提交SET autocommit =1; -- 保存点SAVEPOINT 保存点名称 -- 设置一个事务保存点ROLLBACK TO SAVEPOINT 保存点名称 -- 回滚到保存点RELEASE SAVEPOINT 保存点名称 -- 删除保存点 测试 1234567891011121314151617181920212223242526272829/*课堂测试题目A在线买一款价格为500元商品,网上银行转账.A的银行卡余额为2000,然后给商家B支付500.商家B一开始的银行卡余额为10000创建数据库shop和创建表account并插入2条数据*/ CREATE DATABASE `shop`CHARACTER SET utf8 COLLATE utf8_general_ci;USE `shop`; CREATE TABLE `account` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `name` VARCHAR(32) NOT NULL, `cash` DECIMAL(9,2) NOT NULL, PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8 INSERT INTO account (`name`,`cash`)VALUES(&#x27;A&#x27;,2000.00),(&#x27;B&#x27;,10000.00) -- 转账实现SET autocommit = 0; -- 关闭自动提交START TRANSACTION; -- 开始一个事务,标记事务的起始点UPDATE account SET cash=cash-500 WHERE `name`=&#x27;A&#x27;;UPDATE account SET cash=cash+500 WHERE `name`=&#x27;B&#x27;;COMMIT; -- 提交事务# rollback;SET autocommit = 1; -- 恢复自动提交 索引 索引的作用 提高查询速度 确保数据的唯一性 可以加速表和表之间的连接 , 实现表与表之间的参照完整性 使用分组和排序子句进行数据检索时 , 可以显著减少分组和排序的时间 全文检索字段进行搜索优化. 分类 主键索引 (Primary Key) 唯一索引 (Unique) 常规索引 (Index) 全文索引 (FullText) 主键索引 主键 : 某一个属性组能唯一标识一条记录 特点 : 最常见的索引类型 确保数据记录的唯一性 确定特定数据记录在数据库中的位置 唯一索引 作用 : 避免同一个表中某数据列中的值重复 与主键索引的区别 主键索引只能有一个 唯一索引可能有多个 12345CREATE TABLE `Grade`( `GradeID` INT(11) AUTO_INCREMENT PRIMARYKEY, `GradeName` VARCHAR(32) NOT NULL UNIQUE -- 或 UNIQUE KEY `GradeID` (`GradeID`)) 常规索引 作用 : 快速定位特定数据 注意 : index 和 key 关键字都可以设置常规索引 应加在查询找条件的字段 不宜添加太多常规索引,影响数据的插入,删除和修改操作 123456CREATE TABLE `result`( -- 省略一些代码 INDEX/KEY `ind` (`studentNo`,`subjectNo`) -- 创建表时添加)-- 创建后添加ALTER TABLE `result` ADD INDEX `ind`(`studentNo`,`subjectNo`); 全文索引 百度搜索：全文索引 作用 : 快速定位特定数据 开始之前，先说一下全文索引的版本、存储引擎、数据类型的支持情况 MySQL 5.6 以前的版本，只有 MyISAM 存储引擎支持全文索引； MySQL 5.6 及以后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引; 只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引。 测试或使用全文索引时，要先看一下自己的 MySQL 版本、存储引擎和数据类型是否支持全文索引。 注意 : 只能用于MyISAM类型的数据表 只能用于CHAR , VARCHAR , TEXT数据列类型 适合大型数据集 1234567891011121314151617181920212223242526272829303132/*#方法一：创建表时 CREATE TABLE 表名 ( 字段名1 数据类型 [完整性约束条件…], 字段名2 数据类型 [完整性约束条件…], [UNIQUE | FULLTEXT | SPATIAL ] INDEX | KEY [索引名] (字段名[(长度)] [ASC |DESC]) );#方法二：CREATE在已存在的表上创建索引 CREATE [UNIQUE | FULLTEXT | SPATIAL ] INDEX 索引名 ON 表名 (字段名[(长度)] [ASC |DESC]) ;#方法三：ALTER TABLE在已存在的表上创建索引 ALTER TABLE 表名 ADD [UNIQUE | FULLTEXT | SPATIAL ] INDEX 索引名 (字段名[(长度)] [ASC |DESC]) ; #删除索引：DROP INDEX 索引名 ON 表名字;#删除主键索引: ALTER TABLE 表名 DROP PRIMARY KEY;#显示索引信息: SHOW INDEX FROM student;*/ /*增加全文索引*/ALTER TABLE `school`.`student` ADD FULLTEXT INDEX `studentname` (`StudentName`); /*EXPLAIN : 分析SQL语句执行性能*/EXPLAIN SELECT * FROM student WHERE studentno=&#x27;1000&#x27;; /*使用全文索引*/-- 全文搜索通过 MATCH() 函数完成。-- 搜索字符串作为 against() 的参数被给定。搜索以忽略字母大小写的方式执行。对于表中的每个记录行，MATCH() 返回一个相关性值。即，在搜索字符串与记录行在 MATCH() 列表中指定的列的文本之间的相似性尺度。EXPLAIN SELECT *FROM student WHERE MATCH(studentname) AGAINST(&#x27;love&#x27;); 拓展：测试索引 建表app_user： 123456789101112CREATE TABLE `app_user` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(50) DEFAULT &#x27;&#x27; COMMENT &#x27;用户昵称&#x27;, `email` varchar(50) NOT NULL COMMENT &#x27;用户邮箱&#x27;, `phone` varchar(20) DEFAULT &#x27;&#x27; COMMENT &#x27;手机号&#x27;, `gender` tinyint(4) unsigned DEFAULT &#x27;0&#x27; COMMENT &#x27;性别（0:男；1：女）&#x27;, `password` varchar(100) NOT NULL COMMENT &#x27;密码&#x27;, `age` tinyint(4) DEFAULT &#x27;0&#x27; COMMENT &#x27;年龄&#x27;, `create_time` datetime DEFAULT CURRENT_TIMESTAMP, `update_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,--保存修改记录的最后时间 PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;app用户表&#x27; Current_timestamp: 当你更新字段时，只有字段值发生变化了，你的时间字段才会变为UPDATE操作时的时间。 如果只对字段设置默认值取CURRENT_TIMESTAMP，而没有设置随当前时间戳更新的话（就是建表时不勾选下图中的玩意儿），只有记录创建时会有时间戳，此后对记录的更新操作都不会再改变该记录的时间字段了。 批量插入数据：100w 123456789101112131415DROP FUNCTION IF EXISTS mock_data;DELIMITER $$CREATE FUNCTION mock_data()RETURNS INTBEGIN DECLARE num INT DEFAULT 1000000;--定义数字和大小 DECLARE i INT DEFAULT 0; WHILE i &lt; num DO INSERT INTO app_user(`name`, `email`, `phone`, `gender`, `password`, `age`) VALUES(CONCAT(&#x27;用户&#x27;, i), &#x27;24736743@qq.com&#x27;, CONCAT(&#x27;18&#x27;, FLOOR(RAND()*(999999999-100000000)+100000000)),FLOOR(RAND()*2),UUID(), FLOOR(RAND()*100)); SET i = i + 1; END WHILE; RETURN i;END;SELECT mock_data(); 索引效率测试 无索引 12345678910111213141516171819SELECT * FROM app_user WHERE name = &#x27;用户9999&#x27;; -- 查看耗时SELECT * FROM app_user WHERE name = &#x27;用户9999&#x27;;SELECT * FROM app_user WHERE name = &#x27;用户9999&#x27;; mysql&gt; EXPLAIN SELECT * FROM app_user WHERE name = &#x27;用户9999&#x27;\\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: app_user partitions: NULL type: ALLpossible_keys: NULL key: NULL key_len: NULL ref: NULL rows: 992759 filtered: 10.00 Extra: Using where1 row in set, 1 warning (0.00 sec) 创建索引 1CREATE INDEX idx_app_user_name ON app_user(name); --有索引之后查询快了很多 ，在大数据的时候区别很大 测试普通索引 123456789101112131415161718mysql&gt; EXPLAIN SELECT * FROM app_user WHERE name = &#x27;用户9999&#x27;\\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: app_user partitions: NULL type: refpossible_keys: idx_app_user_name key: idx_app_user_name key_len: 203 ref: const rows: 1 filtered: 100.00 Extra: NULL1 row in set, 1 warning (0.00 sec) mysql&gt; SELECT * FROM app_user WHERE name = &#x27;用户9999&#x27;;1 row in set (0.00 sec) 索引准则 索引不是越多越好 不要对经常变动的数据加索引 小数据量的表建议不要加索引 索引一般应加在查找条件的字段 索引的数据结构 12345678910-- 我们可以在创建上述索引的时候，为其指定索引类型，分两类hash类型的索引：查询单条快，范围查询慢btree类型的索引：b+树，层数越多，数据量指数级增长（我们就用它，因为innodb默认支持它） -- 不同的存储引擎支持的索引类型也不一样InnoDB 支持事务，支持行级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；MyISAM 不支持事务，支持表级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；Memory 不支持事务，支持表级别锁定，支持 B-tree、Hash 等索引，不支持 Full-text 索引；NDB 支持事务，支持行级别锁定，支持 Hash 索引，不支持 B-tree、Full-text 等索引；Archive 不支持事务，支持表级别锁定，不支持 B-tree、Hash、Full-text 等索引； 阅读文档面试：http://blog.codinglabs.org/articles/theory-of-mysql-index.html 七.权限及如何设计数据库 用户管理 用SQLyog 创建用户并授予权限演示 删除和添加用户 基本命令 123456789101112131415161718192021222324252627282930313233343536/* 用户和权限管理 */ ------------------用户信息表：mysql.user-- 刷新权限FLUSH PRIVILEGES-- 增加用户 CREATE USER kuangshen IDENTIFIED BY &#x27;123456&#x27;CREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串) - 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。 - 只能创建用户，不能赋予权限。 - 用户名，注意引号：如 &#x27;user_name&#x27;@&#x27;192.168.1.1&#x27; - 密码也需引号，纯数字密码也要加引号 - 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD -- 重命名用户 RENAME USER kuangshen TO kuangshen2RENAME USER old_user TO new_user http://www.python3.vip/tut/auto/appium/01/-- 设置密码SET PASSWORD = PASSWORD(&#x27;密码&#x27;) -- 为当前用户设置密码SET PASSWORD FOR 用户名 = PASSWORD(&#x27;密码&#x27;) -- 为指定用户设置密码 -- 删除用户 DROP USER kuangshen2DROP USER 用户名 -- 分配权限/添加用户GRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] &#x27;password&#x27;] - all privileges 表示所有权限 - *.* 表示所有库的所有表 - 库名.表名 表示某库下面的某表 -- 查看权限 SHOW GRANTS FOR root@localhost;SHOW GRANTS FOR 用户名 -- 查看当前用户权限 SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER(); -- 撤消权限REVOKE 权限列表 ON 表名 FROM 用户名REVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名 -- 撤销所有权限 权限解释 123456789101112131415161718192021222324252627282930313233343536373839-- 权限列表ALL [PRIVILEGES] -- 设置除GRANT OPTION之外的所有简单权限ALTER -- 允许使用ALTER TABLEALTER ROUTINE -- 更改或取消已存储的子程序CREATE -- 允许使用CREATE TABLECREATE ROUTINE -- 创建已存储的子程序CREATE TEMPORARY TABLES -- 允许使用CREATE TEMPORARY TABLECREATE USER -- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。CREATE VIEW -- 允许使用CREATE VIEWDELETE -- 允许使用DELETEDROP -- 允许使用DROP TABLEEXECUTE -- 允许用户运行已存储的子程序FILE -- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILEINDEX -- 允许使用CREATE INDEX和DROP INDEXINSERT -- 允许使用INSERTLOCK TABLES -- 允许对您拥有SELECT权限的表使用LOCK TABLESPROCESS -- 允许使用SHOW FULL PROCESSLISTREFERENCES -- 未被实施RELOAD -- 允许使用FLUSHREPLICATION CLIENT -- 允许用户询问从属服务器或主服务器的地址REPLICATION SLAVE -- 用于复制型从属服务器（从主服务器中读取二进制日志事件）SELECT -- 允许使用SELECTSHOW DATABASES -- 显示所有数据库SHOW VIEW -- 允许使用SHOW CREATE VIEWSHUTDOWN -- 允许使用mysqladmin shutdownSUPER -- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。UPDATE -- 允许使用UPDATEUSAGE -- “无权限”的同义词GRANT OPTION -- 允许授予权限 /* 表维护 */ -- 分析和存储表的关键字分布ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE 表名 ...-- 检查一个或多个表是否有错误CHECK TABLE tbl_name [, tbl_name] ... [option] ...option = &#123;QUICK | FAST | MEDIUM | EXTENDED | CHANGED&#125;-- 整理数据文件的碎片OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... MySQL备份 数据库备份必要性 保证重要数据不丢失 数据转移 MySQL数据库备份方法 mysqldump备份工具（命令行） 数据库管理工具,如SQLyog（右键） 直接拷贝数据库文件和相关配置文件 mysqldump客户端 作用 : 转储数据库 搜集数据库进行备份 将数据转移到另一个SQL服务器,不一定是MySQL服务器 导入导出 12345678910111213141516171819-- 导出1. 导出一张表 -- mysqldump -uroot -p123456 school student &gt;D:/a.sql mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:/a.sql)2. 导出多张表 -- mysqldump -uroot -p123456 school student result &gt;D:/a.sql mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:/a.sql)3. 导出所有表 -- mysqldump -uroot -p123456 school &gt;D:/a.sql mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:/a.sql)4. 导出一个库 -- mysqldump -uroot -p123456 -B school &gt;D:/a.sql mysqldump -u用户名 -p密码 -B 库名 &gt; 文件名(D:/a.sql) 可以-w携带备份条件 可以远程导出-- 导入1. 在登录mysql的情况下：--use databasename 切换到指定数据库-- source D:/a.sql source 备份文件2. 在不登录的情况下 mysql -u用户名 -p密码 库名 &lt; 备份文件 规范化数据库设计 为什么需要数据库设计 当数据库比较复杂时我们需要设计数据库 糟糕的数据库设计 : 数据冗余,存储空间浪费 数据更新和插入的异常 程序性能差 良好的数据库设计 : 节省数据的存储空间 能够保证数据的完整性 方便进行数据库应用系统的开发 软件项目开发周期中数据库设计 : 需求分析阶段: 分析客户的业务和数据处理需求 概要设计阶段:设计数据库的E-R模型图 , 确认需求信息的正确和完整. 设计数据库步骤 收集信息 与该系统有关人员进行交流 , 座谈 , 充分了解用户需求 , 理解数据库需要完成的任务. 标识实体[Entity] 标识数据库要管理的关键对象或实体,实体一般是名词 标识每个实体需要存储的详细信息[Attribute] 标识实体之间的关系[Relationship] 三大范式 问题 : 为什么需要数据规范化? 不合规范的表设计会导致的问题： 信息重复 更新异常 插入异常 无法正确表示信息 删除异常 丢失有效信息 三大范式 第一范式 (1st NF) 第一范式的目标是确**保每列的原子性,如果每列都是不可再分的最小数据单元,**则满足第一范式 第二范式(2nd NF) 第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。 第二范式要求每个表只描述一件事情 第三范式(3rd NF) 如果一个关系满足第二范式,并且除了主键以外的其他列都不传递依赖于主键列,则满足第三范式. 第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。 规范化和性能的关系 为满足某种商业目标 , 数据库性能比规范化数据库更重要 在数据规范化的同时 , 要综合考虑数据库的性能 通过在给定的表中添加额外的字段,以大量减少需要从中搜索信息所需的时间（从多表查询到单表查询） 通过在给定的表中插入计算列(大数据量降低为小数据量),以方便查询 注：关联的表不能超过三张 八：JDBC Java数据库连接，（Java Database Connectivity，简称JDBC）是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。JDBC也是Sun Microsystems的商标。我们通常说的JDBC是面向关系型数据库的。 建立测试库 1234567891011121314151617CREATE DATABASE jdbcStudy CHARACTER SET utf8 COLLATE utf8_general_ci;USE jdbcStudy;CREATE TABLE `users`(id INT PRIMARY KEY,NAME VARCHAR(40),PASSWORD VARCHAR(40),email VARCHAR(60),birthday DATE);INSERT INTO `users`(id,NAME,PASSWORD,email,birthday)VALUES(1,&#x27;zhansan&#x27;,&#x27;123456&#x27;,&#x27;zs@sina.com&#x27;,&#x27;1980-12-04&#x27;),(2,&#x27;lisi&#x27;,&#x27;123456&#x27;,&#x27;lisi@sina.com&#x27;,&#x27;1981-12-04&#x27;),(3,&#x27;wangwu&#x27;,&#x27;123456&#x27;,&#x27;wangwu@sina.com&#x27;,&#x27;1979-12-04&#x27;)12345678910111213141516 jdbc测试 步骤： 加载驱动 链接数据库DriverManager 获得执行sql的对象 statement 获得返回的结果集 施放链接 注意：报错可能原因： &amp;没有替换为&amp;amp useSSL没有放在最前 上述两点改掉一点就正常了，也不知道为什么 12345678910111213141516171819202122232425import java.sql.*;public class test1 &#123; public static void main(String[] args) throws Exception &#123; //加载驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //用户信息和url String url = &quot;jdbc:mysql://localhost:3306/jdbcstudy?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8&quot;; String username=&quot;root&quot;; String password=&quot;123456&quot;; //链接成功 数据库对象 Connection connection = DriverManager.getConnection(url,username,password); //执行SQL的对象 Statement statement = connection.createStatement(); //执行SQL的对象 去执行SQL 可能返回结果 String sql=&quot;select * from users&quot;; ResultSet resultSet = statement.executeQuery(sql);//返回的结果集 while (resultSet.next())&#123; System.out.println(&quot;id=&quot;+resultSet.getObject(&quot;id&quot;)); System.out.println(&quot;name=&quot;+resultSet.getObject(&quot;name&quot;)); &#125; //施放链接 resultSet.close(); statement.close(); connection.close(); &#125;&#125; DriverManager 12//DriverManager.registerDriver(new com.mysql.jdbc.Driver());Class.forName(&quot;com.mysql.jdbc.Driver&quot;); url 12345String url = &quot;jdbc:mysql://localhost:3306/jdbcstudy?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8&quot;;//mysql--3306// 协议://主机地址:端口号/数据库名?参数1&amp;参数2...//oracle--1521//jdbc:oracle:thin:@localhost:1521:sid Connection 1234//链接成功 数据库对象 connection代表数据库Connection connection = DriverManager.getConnection(url,username,password);connection.rollback();connection.setAutoCommit(); Statement：向数据库发送sql语句 123statement.executeQuery();//查询操作 返回结果集ResultSetstatement.execute();//可以执行任何sql，效率低一点statement.executeUpdate();//更新 插入 删除都是用这个，返回受影响的行数 ResultSet：只有查询是这个 1234567891011121314//不知道类型就用ObjectresultSet.getObject();//知道类型可以直接使用对应类型获取resultSet.getString();resultSet.getInt();resultSet.getFloat();resultSet.getDouble();resultSet.next();//移动到下一行数据resultSet.beforeFirst();//移动到最前resultSet.afterLast();//移动到最后resultSet.previous();//移动到前一行resultSet.absolute(i);//移动到第i行指定行 代码实现&amp;工具类JdbcUtils 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//db.properties存储信息降低耦合driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/jdbcstudy?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8username=rootpassword=root import java.io.InputStream;import java.sql.*;import java.util.Properties;public class JdbcUtils &#123; private static String driver=null; private static String url=null; private static String username=null; private static String password=null; static &#123; try &#123; InputStream in = JdbcUtils.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;); Properties properties=new Properties(); assert in != null; properties.load(in); driver=properties.getProperty(&quot;driver&quot;); url=properties.getProperty(&quot;url&quot;); username=properties.getProperty(&quot;username&quot;); password=properties.getProperty(&quot;password&quot;); //驱动只用加载一次 Class.forName(driver); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; //获取连接 public static Connection getConnection() throws SQLException &#123; return DriverManager.getConnection(url,username,password); &#125; //施放资源 public static void release(Connection connection, Statement statement, ResultSet resultSet) throws Exception &#123; if (resultSet!=null)&#123; resultSet.close(); &#125; if (statement!=null)&#123; statement.close(); &#125; if (connection!=null)&#123; connection.close(); &#125; &#125;&#125; 操作 12345678910111213141516171819202122232425262728import utils.JdbcUtils;import java.sql.Connection;import java.sql.ResultSet;import java.sql.Statement;public class Test2 &#123; public static void main(String[] args) throws Exception &#123; Connection connection=null; Statement statement=null; ResultSet resultSet=null; try &#123; connection= JdbcUtils.getConnection(); statement=connection.createStatement(); String sql=&quot;insert into users(id,name,password,email,birthday)&quot; + &quot;values(100,&#x27;tzt&#x27;,&#x27;123456&#x27;,&#x27;123456@qq.com&#x27;,&#x27;1998-08-08&#x27;);&quot;; //可以先在数据库里执行感受一下 int i=statement.executeUpdate(sql); if (i&gt;0)&#123; System.out.println(&quot;插入成功！&quot;); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; JdbcUtils.release(connection,statement,resultSet); &#125; &#125;&#125; 九：SQL注入的问题 SQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。 sql存在漏洞，会被攻击导致数据泄露 比如登录业务中，需要查询账号密码所对应的用户（比对），可能用到如下sql语句： 123select * from users where name=&#x27;name&#x27; and password =&#x27;password&#x27;//对应sqlString sql=&quot;select&quot; 其中name和password两个变量都是用户所传入的数据 如果用户构造合适的输入，比如： 12String name=&quot; &#x27; or &#x27;1=1&#x27; -- &quot;;String password =&quot;12412r1&quot;;//password在此例中的值不重要 那么如上sql语句拼接成了： 12select * from users where name=&#x27; &#x27; or 1=1 -- password =&#x27;12412r1&#x27; 就可以匹配到表中所有用户的信息 对策：PreparedStatement 可以防止SQL注入，而且效率更高 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import utils.JdbcUtils;import java.sql.*;public class Test2 &#123; public static void main(String[] args) throws Exception &#123; Connection connection=null; PreparedStatement statement=null; ResultSet resultSet=null; try &#123; connection= JdbcUtils.getConnection(); //？占位符 对？赋值 String sql=&quot;insert into users(id,name,password,email,birthday)&quot; + &quot;values(?,?,?,?,?);&quot;; //和Statement的区别！！！！！！！！！ //预编译sql先写sql不执行 statement=connection.prepareStatement(sql); //手动给参数赋值 statement.setInt(1,99); statement.setString(2,&quot;hhh&quot;); statement.setString(3,&quot;12312313&quot;); statement.setString(4,&quot;15612318@qq.com&quot;); //sql.Date 数据库的date //util.Date java的data new Date().getTime()获取时间对象 statement.setDate(5,new java.sql.Date(new Date(1231).getTime())); //传入参数之后执行 int i=statement.executeUpdate(); if (i&gt;0)&#123; System.out.println(&quot;插入成功！&quot;); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; JdbcUtils.release(connection,statement,resultSet); &#125; &#125;&#125;//删除try&#123; conn=JdbcUtils.getConnection(); String sql=&quot;delete from users where id=?&quot;; st=conn.prepareStatement(sql); st.setInt(1,4);//给第一个参数赋值 int i=st.executeUpdate(); if(i&gt;0)&#123; sout(&quot;删除成功&quot;); &#125;&#125;catch(SQLException e)&#123; &#125; IDEA链接数据库 点击窗口右侧database加号，选择MySQL 填写数据库链接信息 测试链接时有可能提示要下包，按照提示自动下载即可 然后apply OK就完成了 如图所示即为成功，不能有红线 可能出现的错误： Server returns invalid timezone. Go to ‘Advanced’ tab and set ‘serverTimezone’ property manually. 临时解决：在MySQL登录后输入： 1set global time_zone = &#x27;+8:00&#x27;; 这种方法在重启MySQL后失效，需要重新设置 永久解决：在IDEA中，链接数据库的界面中高级设置，把时区设置为东八区 JDBC操作事务 123456789101112131415161718192021222324252627282930313233343536import utils.JdbcUtils;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;public class Test3 &#123; public static void main(String[] args) throws Exception &#123; Connection connection=null; PreparedStatement statement=null; ResultSet resultSet=null; try&#123; connection= JdbcUtils.getConnection(); connection.setAutoCommit(false);//关闭自动提交 开启事务 String sql1=&quot;update users set name=&#x27;hhh&#x27; where name=&#x27;hyx&#x27;;&quot;; String sql2=&quot;update users set name=&#x27;tzt&#x27; where name=&#x27;ttt&#x27;;&quot;; int i=1/0; statement=connection.prepareStatement(sql1); statement.executeUpdate(); statement=connection.prepareStatement(sql2); statement.executeUpdate(); //业务完毕提交事务 connection.commit(); System.out.println(&quot;成功&quot;); &#125;catch (Exception e)&#123; e.printStackTrace(); //如果失败则回滚 connection.rollback(); &#125;finally &#123; JdbcUtils.release(connection,statement,resultSet); &#125; &#125;&#125; 数据库连接池 数据库链接–执行完毕–施放十分消耗资源 池化技术：准备一些预先的资源，过来就链接预先准备好的 若常用连接数10个 最小连接数：10个即可 最大连接数：15 业务最高承载上限，超过此值则排队等待 等待超时：等待时间超过一定值直接失败 编写连接池：实现DataSource接口 开源数据源实现 DBCP C3P0 Druid：阿里巴巴 使用了数据库连接池之后，我们在项目开发中就不需要编写链接数据库的代码了！ DBCP 需要导入的包： commons-dbcp-1.4 commons-pool-1.6 配置文件 1234driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/jdbcstudy?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8username=rootpassword=root 工具类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package utils;import org.apache.commons.dbcp.BasicDataSourceFactory;import javax.sql.DataSource;import java.io.InputStream;import java.sql.*;import java.util.Properties;public class JdbcUtils_DBCP &#123; private static DataSource dataSource=null; static &#123; try &#123; InputStream in = JdbcUtils.class.getClassLoader().getResourceAsStream(&quot;dbcp.properties&quot;); Properties properties=new Properties(); assert in != null; properties.load(in); //创建数据源 工厂模式→创建 dataSource=BasicDataSourceFactory.createDataSource(properties); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; //获取连接 public static Connection getConnection() throws Exception &#123; return dataSource.getConnection(); &#125; //施放资源 public static void release(Connection connection, Statement statement, ResultSet resultSet) throws Exception &#123; if (resultSet != null) &#123; resultSet.close(); &#125; if (statement != null) &#123; statement.close(); &#125; if (connection != null) &#123; connection.close(); &#125; &#125;&#125; 测试 123456789101112131415161718192021222324252627282930313233343536import utils.JdbcUtils_DBCP;import java.sql.Connection;import java.sql.Date;import java.sql.PreparedStatement;import java.sql.ResultSet;public class Test4 &#123; public static void main(String[] args) throws Exception &#123; Connection connection=null; PreparedStatement statement=null; ResultSet resultSet=null; try &#123; connection= JdbcUtils_DBCP.getConnection(); //？占位符 String sql=&quot;insert into users(id,name,password,email,birthday)&quot; + &quot;values(?,?,?,?,?);&quot;; //和Statement的区别！！！！！！！！！ statement=connection.prepareStatement(sql); //手动给参数赋值 statement.setInt(1,49); statement.setString(2,&quot;few&quot;); statement.setString(3,&quot;12312313&quot;); statement.setString(4,&quot;15612318@qq.com&quot;); statement.setDate(5,new java.sql.Date(new Date(1231).getTime())); int i=statement.executeUpdate(); if (i&gt;0)&#123; System.out.println(&quot;插入成功！&quot;); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; JdbcUtils_DBCP.release(connection,statement,resultSet); &#125; &#125;&#125;","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"狂神说Mybatis-Plus","slug":"狂神说Mybatis-Plus","date":"2021-04-01T05:58:10.000Z","updated":"2021-04-23T13:23:49.665Z","comments":true,"path":"2021/04/01/狂神说Mybatis-Plus/","link":"","permalink":"http://example.com/2021/04/01/%E7%8B%82%E7%A5%9E%E8%AF%B4Mybatis-Plus/","excerpt":"","text":"mybatis-plus （懒人的必备神器） 视频地址：https://www.bilibili.com/video/BV17E411N7KN视频地址 这个老师讲课真的很好，学java后端的都可以去看一下，从基础到架构很详细，推荐给大家https://space.bilibili.com/95256449/狂神说 最近做项目听到老师讲到使用mybatis-plus,刚好狂神更新了mybatis-plus视频，简直天助我也，学完不要太震惊，真的牛逼，从此CURD告别写sql。 看这篇文章需要掌握点mysql，mybatis，springboot，狂神老师那都有对应的视频，可以去看看！！！ 官方地址：https://mp.baomidou.com/ 简介 MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。 愿景 我们的愿景是成为 MyBatis 最好的搭档，就像 魂斗罗 中的 1P、2P，基友搭配，效率翻倍。 特性 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作 强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题 支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作 支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ） 内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用 内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询 分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库 内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作 支持数据库 mysql 、 mariadb 、 oracle 、 db2 、 h2 、 hsql 、 sqlite 、 postgresql 、 sqlserver 达梦数据库 、 虚谷数据库 、 人大金仓数据库 快速指南 我们将通过一个简单的 Demo 来阐述 MyBatis-Plus 的强大功能，在此之前，我们假设您已经： 拥有 Java 开发环境以及相应 IDE 熟悉 Spring Boot 熟悉 Maven 使用第三方组件： 1、导入对应的依赖 2、研究依赖如何配置 3、代码如何编写 4、提高扩展技术的能力 步骤 1、创建数据库 mybatis_plus 现有一张 User 表，其表结构如下： id name age email 1 Jone 18 test1@baomidou.com 2 Jack 20 test2@baomidou.com 3 Tom 28 test3@baomidou.com 4 Sandy 21 test4@baomidou.com 5 Billie 24 test5@baomidou.com 其对应的数据库 Schema 脚本如下： 1234567891011DROP TABLE IF EXISTS user;CREATE TABLE user( id BIGINT(20) NOT NULL COMMENT &#x27;主键ID&#x27;, name VARCHAR(30) NULL DEFAULT NULL COMMENT &#x27;姓名&#x27;, age INT(11) NULL DEFAULT NULL COMMENT &#x27;年龄&#x27;, email VARCHAR(50) NULL DEFAULT NULL COMMENT &#x27;邮箱&#x27;, PRIMARY KEY (id));-- 真实开发中，version（乐观锁），deleted（逻辑删除）、gmt_create、gem_mo 其对应的数据库 Data 脚本如下： 1234567DELETE FROM user;INSERT INTO user (id, name, age, email) VALUES(1, &#x27;Jone&#x27;, 18, &#x27;test1@baomidou.com&#x27;),(2, &#x27;Jack&#x27;, 20, &#x27;test2@baomidou.com&#x27;),(3, &#x27;Tom&#x27;, 28, &#x27;test3@baomidou.com&#x27;),(4, &#x27;Sandy&#x27;, 21, &#x27;test4@baomidou.com&#x27;),(5, &#x27;Billie&#x27;, 24, &#x27;test5@baomidou.com&#x27;); 2、导入相应的依赖 123456789101112131415161718&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!--mybatis-plus 是自己开发的，非官方的！--&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.5&lt;/version&gt;&lt;/dependency&gt;&lt;!--lombok--&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.10&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 说明：我们使用mybatis-plus可以节省我们大量的代码，尽量不要同时导入mybatis和mybatis-plus！ 版本的差异！ 3、连接数据库 1234567# mysql 5 驱动不同 com.mysql.jsbc.Driver# mysql 8 驱动不同 com.mysql.cj.jsbc.Driver、需要增加时区的配置spring.datasource.username=rootspring.datasource.password=rootspring.datasource.url=jdbc:mysql://localhost:3306/mybatis_plus?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver 4、编写代码 pojo–&gt;dao–&gt;(连接mybatis，配置mapper.xml文件)–&gt;service-controller (传统方式 ) 使用mybatis-plus之后 123* pojo* dao接口（不用写mapper.xml文件）* 使用 编写实体类 User.java（此处使用了 Lombok 简化代码） 1234567@Datapublic class User &#123; private Long id; private String name; private Integer age; private String email;&#125; 编写Mapper类 UserMapper.java 12345//在对应的Mapper上继承基本的类baseMapperpublic interface UserMapper extends BaseMapper&lt;User&gt; &#123; //所有的CRUD已经编写完成 //不需要像以前的配置一些xml&#125; 在 Spring Boot 启动类中添加 @MapperScan 注解，扫描 Mapper 文件夹： 12345678@SpringBootApplication@MapperScan(&quot;com.jiang.mapper&quot;)//扫描mapper文件夹public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(QuickStartApplication.class, args); &#125;&#125; 添加测试类，进行功能测试： 1234567891011121314151617@RunWith(SpringRunner.class)@SpringBootTestpublic class SampleTest &#123; @Autowired private UserMapper userMapper; @Test public void testSelect() &#123; System.out.println((&quot;----- selectAll method test ------&quot;)); //参数是一个Wrapper，条件结构器，这里先不用 填null //查询所有的用户 List&lt;User&gt; userList = userMapper.selectList(null); Assert.assertEquals(5, userList.size()); userList.forEach(System.out::println); &#125;&#125; UserMapper 中的 selectList() 方法的参数为 MP 内置的条件封装器 Wrapper，所以不填写就是无任何条件 控制台输出： 12345User(id=1, name=Jone, age=18, email=test1@baomidou.com)User(id=2, name=Jack, age=20, email=test2@baomidou.com)User(id=3, name=Tom, age=28, email=test3@baomidou.com)User(id=4, name=Sandy, age=21, email=test4@baomidou.com)User(id=5, name=Billie, age=24, email=test5@baomidou.com) 完整的代码示例请移步：Spring Boot 快速启动示例 [Spring MVC 快速启动示例] 5、小结 通过以上几个简单的步骤，我们就实现了 User 表的 CRUD 功能，甚至连 XML 文件都不用编写！ 从以上步骤中，我们可以看到集成MyBatis-Plus非常的简单，只需要引入 starter 工程，并配置 mapper 扫描路径即可。 但 MyBatis-Plus 的强大远不止这些功能，想要详细了解 MyBatis-Plus 的强大功能？那就继续往下看吧！ 配置日志 我们所用的sql现在是不可见的，我们希望知道他是怎么执行的，所以我们必须要查看日志！ 12#配置日志mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl CRUD扩展 Insert 插入 12// 插入一条记录int insert(T entity); 参数说明 类型 参数名 描述 T entity 实体对象 举例测试 123456789@Testpublic void testInsert() &#123; System.out.println((&quot;----- selectAll method test ------&quot;)); User user = new User(); user.setName=(&quot;shuishui&quot;); user.setAge(3); user.setEmail(&quot;12434141@qq.com&quot;); userMapper.insert(user);&#125; 数据库插入的id为全局默认的id（ID_WORKER) 主键生成策略 1.分布式系统唯一id生成（ID_WORKER) 雪花算法 SnowFlake 算法，是 Twitter 开源的分布式 id 生成算法。其核心思想就是：使用一个 64 bit 的 long 型的数字作为全局唯一 id。在分布式系统中的应用十分广泛，且ID 引入了时间戳，基本上保持自增的。 这 64 个 bit 中，其中 1 个 bit 是不用的，然后用其中的 41 bit 作为毫秒数，用 10 bit 作为工作机器 id，12 bit 作为序列号。 https://blog.csdn.net/lq18050010830/article/details/89845790 2.主键自增AUTO 我们需要配置主键自增 1、实体类字段上 @TableId（type =IdType.AUTO） 2、数据库字段一定要是自增的 其他的码源详解 123456789101112131415161718public enum IdType &#123; AUTO(0), //数据可id自增 NONE(1), //未设置主键 INPUT(2), //手动输入 ID_WORKER(3), //默认的全局唯一id 雪花 UUID(4), //全局唯一id uuid ID_WORKER_STR(5); // ID_WORKEK 字符串表示法 private int key; private IdType(int key) &#123; this.key = key; &#125; public int getKey() &#123; return this.key; &#125;&#125; 更新操作 1234// 根据 whereEntity 条件，更新记录int update(@Param(Constants.ENTITY) T entity, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; updateWrapper);// 根据 ID 修改，参数是对象int updateById(@Param(Constants.ENTITY) T entity); #参数说明 类型 参数名 描述 T entity 实体对象 (set 条件值,可为 null) Wrapper updateWrapper 实体对象封装操作类（可以为 null,里面的 entity 用于生成 where 语句） 举例测试 123456789101112@Testpublic void testUpdate() &#123; //sql自动动态配置 User user = new User(); user.setName=(&quot;shui&quot;); user.setId(3L); //长整型 user.setAge(&quot;18&quot;); //注意：updateById的参数是一个对象 int i=userMapper.updateById(user);//受影响的行数&#125; 自动填充 创建时间、修改时间！这些个操作一遍都是自动化完成，我们不希望手动更新！ 阿里巴巴开发手册：所有的数据库表：gmt_create\\gmt_modified几乎所有的表都要配置上！而且需要自动化 方式一：数据库级别 在表中新增字段 create_time 、update_time(默认CURRENT_TIMESIAMP) 方式二：代码级别 实体类上的属性需要增加注解==@TableField== 1234567//创建时间@TableField(fill = FieldFill.INSERT)//插入的时候操作private Date createTime;//更新时间 @TableField(fill = FieldFill.INSERT_UPDATE)//插入和更新的时候操作private Date updateTime; 编写处理器来处理这个注释即可！ 123456789101112131415161718192021222324252627282930313233@Slf4j@Component //一定不要忘了把处理器加到IOC容器中public class MyMetaObjectHandler implements MetaObjectHandler &#123; //插入时候的填充策略 @Override @Componcent //一定不要忘记吧处理器加到IOC容器中 public void insertFill(MetaObject metaObject) &#123; log.info(&quot;start insert fill ....&quot;); //日志 //设置字段的值（String fieldName字段名,Object fieldVal要传递的值,MetaObject metaObject) this.setFieldVaLByName(&quot;createTime&quot;,new Date(),metaObject); this.setFieldVaLByName(&quot;createTime&quot;,new Date(),metaObject); //this.strictInsertFill(metaObject, &quot;createTime&quot;, LocalDateTime.class, LocalDateTime.now()); // 起始版本 3.3.0(推荐使用) // this.fillStrategy(metaObject, &quot;createTime&quot;, LocalDateTime.now()); // 也可以使用(3.3.0 该方法有bug请升级到之后的版本如`3.3.1.8-SNAPSHOT`) /* 上面选其一使用,下面的已过时(注意 strictInsertFill 有多个方法,详细查看源码) */ //this.setFieldValByName(&quot;operator&quot;, &quot;Jerry&quot;, metaObject); //this.setInsertFieldValByName(&quot;operator&quot;, &quot;Jerry&quot;, metaObject); &#125; //更新时间的填充策略 @Override public void updateFill(MetaObject metaObject) &#123; log.info(&quot;start update fill ....&quot;); this.setFieldValByName(&quot;updateTime&quot;,new Date(),metaObject); //this.strictUpdateFill(metaObject, &quot;updateTime&quot;, LocalDateTime.class, LocalDateTime.now()); // 起始版本 3.3.0(推荐使用) // this.fillStrategy(metaObject, &quot;updateTime&quot;, LocalDateTime.now()); // 也可以使用(3.3.0 该方法有bug请升级到之后的版本如`3.3.1.8-SNAPSHOT`) /* 上面选其一使用,下面的已过时(注意 strictUpdateFill 有多个方法,详细查看源码) */ //this.setFieldValByName(&quot;operator&quot;, &quot;Tom&quot;, metaObject); //this.setUpdateFieldValByName(&quot;operator&quot;, &quot;Tom&quot;, metaObject); &#125;&#125; 吐槽：这么麻烦，难道用数据库不香吗？ 乐观锁 面试中经常会问到乐观锁，悲观锁 乐观锁：顾名思义十分乐观，它总是被认为不会出现问题，无论干什么都不去上锁！如果出现了问题，再次更新测试 悲观锁：顾名思义十分悲观，它总是出现问题，无论干什么都会上锁！再去操作！ 乐观锁实现方式 取出记录是，获取当前version 更新时，带上这个version 执行更新事，set version=newVersion where version =oldVersion 如果version不对，就更新失败 123456乐观锁： 1、先查询，获得版本号 version=1update user set name =&quot;shuishui&quot; ,version =version+1where id =2 and version=1--如果线程抢先完成，这个时候version=2，会导致A修改失败 测试乐观锁 1、表中创建乐观锁字段version 默认值为1 2、同步实体类 12@Version //乐观锁Version注解private Integer version; 3、注册组件 （config包下） springboot： 1234567891011@EnableTransactionManagement@MapperScan(&quot;com.baomidou.cloud.service.*.mapper*&quot;)@Configuration//配置类public class MyBatisPlusConfig&#123; //注册乐观锁插件 @Bean public OptimisticLockerInterceptor optimisticLockerInterceptor() &#123; return new OptimisticLockerInterceptor(); //拦截器 &#125;&#125; spring xml: 1&lt;bean class=&quot;com.baomidou.mybatisplus.extension.plugins.OptimisticLockerInterceptor&quot;/&gt; 特别说明: 支持的数据类型只有:int,Integer,long,Long,Date,Timestamp,LocalDateTime 整数类型下 newVersion = oldVersion + 1 newVersion 会回写到 entity 中 仅支持 updateById(id) 与 update(entity, wrapper) 方法 在 update(entity, wrapper) 方法下, wrapper 不能复用!!! 测试一下：线程一执行的时候线程二插队了 查询操作 12345678910111213141516171819202122// 根据 ID 查询T selectById(Serializable id);// 根据 entity 条件，查询一条记录T selectOne(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 查询（根据ID 批量查询）List&lt;T&gt; selectBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);// 根据 entity 条件，查询全部记录List&lt;T&gt; selectList(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 查询（根据 columnMap 条件）List&lt;T&gt; selectByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap);// 根据 Wrapper 条件，查询全部记录List&lt;Map&lt;String, Object&gt;&gt; selectMaps(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询全部记录。注意： 只返回第一个字段的值List&lt;Object&gt; selectObjs(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 entity 条件，查询全部记录（并翻页）IPage&lt;T&gt; selectPage(IPage&lt;T&gt; page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询全部记录（并翻页）IPage&lt;Map&lt;String, Object&gt;&gt; selectMapsPage(IPage&lt;T&gt; page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询总记录数Integer selectCount(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); #参数说明 类型 参数名 描述 Serializable id 主键ID Wrapper queryWrapper 实体对象封装操作类（可以为 null） Collection&lt;? extends Serializable&gt; idList 主键ID列表(不能为 null 以及 empty) Map&lt;String, Object&gt; columnMap 表字段 map 对象 IPage page 分页查询条件（可以为 RowBounds.DEFAULT） 实例测试 1234567891011121314151617181920212223@Testpublic void testSelectById()&#123; User user =userMapper.selectById(1); System.out.println(user)&#125;//测试批量查询@Testpublic void testSelectByBatchId()&#123; List&lt;User&gt; user =userMapper.selectBatchIds(Arrays.asList(1,2,3)); users.forEach(System.out::println)&#125;//条件查询public void testSelectByBatchIds()&#123; HashMap&lt;String,Object&gt; map=new HashMap&lt;&gt;(); //自定义查询 map.put(&quot;name&quot;,&quot;shuishui&quot;); map.put(&quot;age&quot;,3); List&lt;User&gt; user = userMapper.selectByMap(map); users.forEach(System.out::println);&#125; 分页查询 分页在网站使用的十分多 1、原始的limit进行分页 2、pageHelper 第三方插件 3、Mybatis-Plus中也内置了分页插件！ 如何使用 1、配置拦截器组件即可 1234567891011121314151617181920//Spring boot方式@EnableTransactionManagement@Configuration@MapperScan(&quot;com.baomidou.cloud.service.*.mapper*&quot;)public class MybatisPlusConfig &#123; @Bean public PaginationInterceptor paginationInterceptor() &#123; PaginationInterceptor paginationInterceptor = new PaginationInterceptor(); // 设置请求的页面大于最大页后操作， true调回到首页，false 继续请求 默认false // paginationInterceptor.setOverflow(false); // 设置最大单页限制数量，默认 500 条，-1 不受限制 // paginationInterceptor.setLimit(500); // 开启 count 的 join 优化,只针对部分 left join paginationInterceptor.setCountSqlParser(new JsqlParserCountOptimize(true)); return paginationInterceptor; &#125; //直接 return new PaginationInterceptor();&#125; 2、写测试 12345678910111213//测试分页查询@Testpulic void testPage()&#123; // 参数一：当前页 // 参数二：页面大小 // 使用了分页插件之后，所有的分页操作也变得简单了 Page&lt;User&gt; page =new Page&lt;&gt;(2,5); userMapper.selectPage(page,null); page.getRecords().forEach(System.out::println); //获取总数 page.getTotal();&#125; 删除 12345678// 根据 entity 条件，删除记录int delete(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; wrapper);// 删除（根据ID 批量删除）int deleteBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);// 根据 ID 删除int deleteById(Serializable id);// 根据 columnMap 条件，删除记录int deleteByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap); #参数说明 类型 参数名 描述 Wrapper wrapper 实体对象封装操作类（可以为 null） Collection&lt;? extends Serializable&gt; idList 主键ID列表(不能为 null 以及 empty) Serializable id 主键ID Map&lt;String, Object&gt; columnMap 表字段 map 对象 测试删除： 123456789101112131415161718@Testpublic void testDeleteById()&#123; userMapper.deleteById(1);&#125;//批量删除@Testpublic void testDeleteBatchId()&#123; userMapper.deleteBatchIds(Arrays.asList(1,2));&#125;//条件删除@Testpublic void testDeleteMap()&#123; HashMap&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;name&quot;,&quot;shuishui&quot;); userMapper.deleteByMap(Map);&#125; 在工作中会遇到逻辑删除 逻辑删除 物理删除 ：从数据库中直接移出 逻辑删除：在数据库中没有被移出，而是通过一个变量来让他失效！deleted=0 ==&gt;deleted =1(失效) SpringBoot 配置方式： application.yml 加入配置(如果你的默认值和mp默认的一样,该配置可无): 123456mybatis-plus: global-config: db-config: logic-delete-field: flag #全局逻辑删除字段值 3.3.0开始支持，详情看下面。 logic-delete-value: 1 # 逻辑已删除值(默认为 1) logic-not-delete-value: 0 # 逻辑未删除值(默认为 0) 注册 Bean(3.1.1开始不再需要这一步)： 12345678910111213import com.baomidou.mybatisplus.core.injector.ISqlInjector;import com.baomidou.mybatisplus.extension.injector.LogicSqlInjector;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class MyBatisPlusConfiguration &#123; @Bean public ISqlInjector sqlInjector() &#123; return new LogicSqlInjector(); &#125;&#125; 实体类字段上加上@TableLogic注解 12@TableLogicprivate Integer deleted; 效果: 使用mp自带方法删除和查找都会附带逻辑删除功能 (自己写的xml不会) 123example删除时 update user set deleted=1 where id =1 and deleted=0查找时 select * from user where deleted=0 全局逻辑删除: 3.3.0开始支持 如果公司代码比较规范，比如统一了全局都是flag为逻辑删除字段。 使用此配置则不需要在实体类上添加 @TableLogic。 但如果实体类上有 @TableLogic 则以实体上的为准，忽略全局。 即先查找注解再查找全局，都没有则此表没有逻辑删除。 1234mybatis-plus: global-config: db-config: logic-delete-field: flag #全局逻辑删除字段值 附件说明 逻辑删除是为了方便数据恢复和保护数据本身价值等等的一种方案，但实际就是删除。 如果你需要再查出来就不应使用逻辑删除，而是以一个状态去表示。 如： 员工离职，账号被锁定等都应该是一个状态字段，此种场景不应使用逻辑删除。 若确需查找删除数据，如老板需要查看历史所有数据的统计汇总信息，请单独手写sql。 以上的CRUD操作都必须要掌握 性能更新插件 我们在平时的开发中，会遇到一些慢sql。测试！druid… 作用：性能分析拦截器，用于输出每条SQL语句及执行时间 MP也提供性能分析插件，如果超过这和时间就会停止运行 1、导入插件 123456789101112131415161718//Spring boot方式@EnableTransactionManagement@Configuration@MapperScan(&quot;com.baomidou.cloud.service.*.mapper*&quot;)public class MybatisPlusConfig &#123; /** * SQL执行效率插件 */ @Bean @Profile(&#123;&quot;dev&quot;,&quot;test&quot;&#125;)// 设置 dev test 环境开启 public PerformanceInterceptor performanceInterceptor() &#123; PerformanceInterceptor performanceInterceptor = new PerformanceInterceptor(); performanceInterceptor.setMaxTime(100);// ms 设置sql执行的最大时间，如果超过就停止 performanceInterceptor.setFormat(true); return new PerformanceInterceptor(); &#125;&#125; 记得在SpringBoot配置环境为dev或者test环境！ 2、测试使用 1234567@Testvoid contextLoads()&#123; //参数是一个Wrapper，条件结构器，这里先不用，填null //查询全部用户 List&lt;User&gt; users =userMapper.selectList(null); user.forEach(System.out::println);&#125; 注意！参数说明： 参数：maxTime SQL 执行最大时长，超过自动停止运行，有助于发现问题。 参数：format SQL SQL是否格式化，默认false。 该插件只用于开发dev环境，不建议生产环境使用。 条件构造器 十分重要：Wrapper 我们写一些复杂的sql可以用它来完成 和map对比，wrapper重在方法 现做几个实例看看： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Testvoid contextLoads()&#123; // 查询name不为null的用户，并且邮箱不为null的永不，年龄大于等于20的用户 QueryWrapper&lt;User&gt; wrapper =new QueryWrapper&lt;&gt;(); wrapper.isNotNull(&quot;name&quot;); wrapper.isNotNull(&quot;email&quot;); wrapper.ge(&quot;age&quot;,12); //g大于 e等于 userMapper.selectList(wrapper).forEach(System.out::println);&#125;@Testvoid test2()&#123; // 查询name为shuishui的用户 QueryWrapper&lt;User&gt; wrapper =new QueryWrapper&lt;&gt;(); wrapper.eq(&quot;name&quot;,&quot;shuishui&quot;); User user=userMapper.selectList(wrapper) System.out.println（user）;&#125;@Testvoid test3()&#123; // 查询年龄在20~30岁之间的用户 QueryWrapper&lt;User&gt; wrapper =new QueryWrapper&lt;&gt;(); wrapper.between(&quot;age&quot;,20,30); Integer count =userMapper.selectCount(wrapper);//查询结果数 System.out.println（count）;&#125;//模糊查询@Testvoid test4()&#123; QueryWrapper&lt;User&gt; wrapper =new QueryWrapper&lt;&gt;(); wrapper.notLike(&quot;name&quot;,“s”);//相当于NOT LIKE &#x27;%s%&#x27; wrapper.likeRight(&quot;email&quot;,“s”);//相当于LIKE &#x27;s%&#x27; List&lt;Map&lt;String,Object&gt;&gt;maps =userMapper.selectMaps(wrapper);//查询结果数 maps.forEach(System.out::println）;&#125;@Testvoid test5()&#123; QueryWrapper&lt;User&gt; wrapper =new QueryWrapper&lt;&gt;(); //子查询 wrapper.insql(&quot;id&quot;,&quot;select id from user where id&lt;3&quot;); List&lt;Object&gt; objects =userMapper.selectobjs(wrapper);/ objects.forEach(System.out::println); //WHERE deleted=0 AND id IN (select id from user where id&lt;3)@Testvoid test6()&#123; QueryWrapper&lt;User&gt; wrapper =new QueryWrapper&lt;&gt;(); //通过id进行排序 wrapper.orderByAsc(&quot;id&quot;); List&lt;User&gt; users =userMapper.selectList(wrapper);/ objects.forEach(System.out::println);&#125; 更多的方法都在官方文档里 代码自动生成器 dao、pojo、conrtroller、service自动生成 AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、 Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.kuang;import com.baomidou.mybatisplus.annotation.DbType; import com.baomidou.mybatisplus.annotation.FieldFill;import com.baomidou.mybatisplus.annotation.IdType; import com.baomidou.mybatisplus.annotation.TableField;import com.baomidou.mybatisplus.generator.AutoGenerator;import com.baomidou.mybatisplus.generator.config.DataSourceConfig;import com.baomidou.mybatisplus.generator.config.GlobalConfig;import com.baomidou.mybatisplus.generator.config.PackageConfig;import com.baomidou.mybatisplus.generator.config.StrategyConfig;import com.baomidou.mybatisplus.generator.config.po.TableFill;import com.baomidou.mybatisplus.generator.config.rules.DateType; import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;import java.util.ArrayList;// 代码自动生成器 public class KuangCode &#123; public static void main(String[] args) &#123; // 需要构建一个 代码自动生成器 对象 AutoGenerator mpg = new AutoGenerator(); // 配置策略 // 1、全局配置 GlobalConfig gc = new GlobalConfig(); //全局配置 String projectPath = System.getProperty(&quot;user.dir&quot;); //获取用户目录，项目路径 gc.setOutputDir(projectPath+&quot;/src/main/java&quot;); //代码要输出的目录 gc.setAuthor(&quot;JZJ&quot;); //设置作者 gc.setOpen(false); //是否打开资源管理器，文件夹 gc.setFileOverride(false); // 是否覆盖 gc.setServiceName(&quot;%sService&quot;); // 去Service的I前缀 gc.setIdType(IdType.ID_WORKER); gc.setDateType(DateType.ONLY_DATE); //日期类型 gc.setSwagger2(true); mpg.setGlobalConfig(gc); //2、设置数据源 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(&quot;jdbc:mysql://localhost:3306/kuang_community? useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8&quot;); dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;); dsc.setUsername(&quot;root&quot;); dsc.setPassword(&quot;123456&quot;); dsc.setDbType(DbType.MYSQL); mpg.setDataSource(dsc); //3、包的配置 PackageConfig pc = new PackageConfig(); pc.setModuleName(&quot;blog&quot;); //博客模块 pc.setParent(&quot;com.kuang&quot;); //生成com.kuang.blog pc.setEntity(&quot;entity&quot;); //pojo pc.setMapper(&quot;mapper&quot;); pc.setService(&quot;service&quot;); pc.setController(&quot;controller&quot;); mpg.setPackageInfo(pc); //4、策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setInclude(&quot;blog_tags&quot;,&quot;course&quot;,&quot;links&quot;,&quot;sys_settings&quot;,&quot;user_record&quot;,&quot; user_say&quot;); // 设置要映射的表名重点 strategy.setNaming(NamingStrategy.underline_to_camel); //命名规则，下划线转驼峰 strategy.setInclude(scanner(&quot;表名，多个英文逗号分割&quot;).split(&quot;,&quot;));//设置要映射的表名 strategy.setColumnNaming(NamingStrategy.underline_to_camel); // 自动lombok strategy.setEntityLombokModel(true); strategy.setLogicDeleteFieldName(&quot;deleted&quot;); // 自动填充配置 TableFill gmtCreate = new TableFill(&quot;gmt_create&quot;, FieldFill.INSERT); TableFill gmtModified = new TableFill(&quot;gmt_modified&quot;, FieldFill.INSERT_UPDATE); ArrayList&lt;TableFill&gt; tableFills = new ArrayList&lt;&gt;(); tableFills.add(gmtCreate); tableFills.add(gmtModified); strategy.setTableFillList(tableFills); // 乐观锁 strategy.setVersionFieldName(&quot;version&quot;); strategy.setRestControllerStyle(true); strategy.setControllerMappingHyphenStyle(true); // localhost:8080/hello_id_2 mpg.setStrategy(strategy); mpg.execute(); //执行 StrategyConfig strategy=new StrategyCon &#125; AutoGenerator mpg=new AutoGenerator(); new GlobalConfig();&#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"后端学习","slug":"后端学习","permalink":"http://example.com/tags/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"狂神说swagger-集成springboot","slug":"狂神说swagger-集成springboot","date":"2021-04-01T04:58:10.000Z","updated":"2021-04-23T13:22:47.393Z","comments":true,"path":"2021/04/01/狂神说swagger-集成springboot/","link":"","permalink":"http://example.com/2021/04/01/%E7%8B%82%E7%A5%9E%E8%AF%B4swagger-%E9%9B%86%E6%88%90springboot/","excerpt":"","text":"19、集成Swagger终极版 学习目标： 了解Swagger的概念及作用 掌握在项目中集成Swagger自动生成API文档 19.1、Swagger简介 前后端分离 前端 -&gt; 前端控制层、视图层 后端 -&gt; 后端控制层、服务层、数据访问层 前后端通过API进行交互 前后端相对独立且松耦合 产生的问题 前后端集成，**前端或者后端无法做到“及时协商，尽早解决”，**最终导致问题集中爆发 解决方案 首先定义schema [ 计划的提纲 ]，并实时跟踪最新的API，降低集成风险 早些年：制定Word计划文档 前后端分离： 前端测试后端接口：postman 后端提供接口，需要实时更新最新的消息及改动！ Swagger 号称世界上最流行的API框架 Restful Api 文档在线自动生成器 =&gt; API 文档 与API 定义同步更新 直接运行，在线测试API 支持多种语言 （如：Java，PHP等） 官网：https://swagger.io/ 19.2、SpringBoot集成Swagger SpringBoot集成Swagger =&gt; springfox，两个jar包 Springfox-swagger2 swagger-springmvc 使用Swagger 要求：jdk 1.8 + 否则swagger2无法运行 步骤： 1、新建一个SpringBoot-web项目 2、添加Maven依赖 123456789101112&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt; 3、编写HelloController，测试确保运行成功！ 12345678@RestControllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) public String hello()&#123; return &quot;hello&quot;; &#125;&#125; 4、要使用Swagger，我们需要编写一个配置类-SwaggerConfig来配置 Swagger 1234@Configuration //配置类@EnableSwagger2// 开启Swagger2的自动配置public class SwaggerConfig &#123; &#125; 5、访问测试 ：http://localhost:8080/swagger-ui.html ，可以看到swagger的界面； 19.3、配置Swagger 1、Swagger实例Bean是Docket，所以通过配置Docket实例来配置Swaggger。 swaggerConfig .java 1234@Bean //配置docket以配置Swagger具体参数,接管原有配置public Docket docket() &#123; return new Docket(DocumentationType.SWAGGER_2);&#125; Docket 实例关联上 apiInfo() 1234@Beanpublic Docket docket() &#123; return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo());&#125; 2、可以通过apiInfo()属性配置文档信息 ApiInfo没有set方法只能构造器配置 123456789101112131415import org.springframework.context.annotation.Bean;//配置文档信息private ApiInfo apiInfo() &#123; Contact contact = new Contact(&quot;联系人名字&quot;, &quot;http://xxx.xxx.com/联系人访问链接&quot;, &quot;联系人邮箱&quot;); return new ApiInfo( &quot;Swagger学习&quot;, // 标题 &quot;学习演示如何配置Swagger&quot;, // 描述 &quot;v1.0&quot;, // 版本 &quot;http://terms.service.url/组织链接&quot;, // 组织链接 contact, // 联系人信息 &quot;Apach 2.0 许可&quot;, // 许可 &quot;许可链接&quot;, // 许可连接 new ArrayList&lt;&gt;()// 扩展 );&#125; 3、重启项目，访问测试 http://localhost:8080/swagger-ui.html 看下效果； 19.4、配置扫描接口 1、构建Docket时通过select()方法配置怎么扫描接口。 12345678@Beanpublic Docket docket() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口，基于什么扫描 .apis(RequestHandlerSelectors.basePackage(&quot;com.jiang.controller&quot;)) .build();//工厂模式&#125; 2、重启项目测试，由于我们配置根据包的路径扫描接口，所以我们只能看到一个类 3、除了通过包路径配置扫描接口外，还可以通过配置其他方式扫描接口，这里注释一下所有的配置方式： RequestHandlerSelectors.*(可以填以下内容) 1234567any() // 扫描所有，项目中的所有接口都会被扫描到none() // 不扫描接口// 通过方法上的注解扫描，如withMethodAnnotation(GetMapping.class)只扫描get请求withMethodAnnotation(final Class&lt;? extends Annotation&gt; annotation)// 通过类上的注解扫描，如.withClassAnnotation(Controller.class)只扫描有controller注解的类中的接口withClassAnnotation(final Class&lt;? extends Annotation&gt; annotation)basePackage(final String basePackage) // 根据包路径扫描接口 4、除此之外，我们还可以配置接口扫描过滤： 12345678910@Beanpublic Docket docket() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口 .apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;)) // 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口 .paths(PathSelectors.ant(&quot;/kuang/**&quot;)) .build();&#125; 5、PathSelectors.*这里的可选值还有 1234any() // 任何请求都扫描none() // 任何请求都不扫描regex(final String pathRegex) // 通过正则表达式控制ant(final String antPattern) // 通过ant()控制 我只希望我的swagger在生产环境中使用，在发布的时候不适用？ 判断是不是生产环境 注入enable（false） 19.5、配置Swagger开关 1、通过enable()方法配置是否启用swagger，如果是false，swagger将不能在浏览器中访问了 在生产环境中使用，在发布的时候不适用 123456789101112@Beanpublic Docket docket() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .enable(false) //配置是否启用Swagger，如果是false，在浏览器将无法访问 .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口 .apis(RequestHandler Selectors.basePackage(&quot;com.kuang.swagger.controller&quot;)) // 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口 .paths(PathSelectors.ant(&quot;/kuang/**&quot;)) .build();&#125; 2、如何动态配置当项目处于test、dev环境时显示swagger，处于prod时不显示？ 1234567891011121314151617@Beanpublic Docket docket(Environment environment) &#123; // 设置要显示swagger的环境 Profiles of = Profiles.of(&quot;dev&quot;, &quot;test&quot;); // 通过environment.acceptsProfiles判断当前是否处于自己设定的环境中 // 通过 enable() 接收此参数判断是否要显示 boolean b = environment.acceptsProfiles(of); return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .enable(b) //配置是否启用Swagger，如果是false，在浏览器将无法访问 .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口 .apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;)) // 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口 .paths(PathSelectors.ant(&quot;/kuang/**&quot;)) .build();&#125; 3、可以在项目中增加一个dev的配置文件查看效果！ 要带上kuang 19.6、配置API分组 1、如果没有配置分组，默认是default。通过groupName()方法即可配置分组： 123456@Beanpublic Docket docket(Environment environment) &#123; return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo()) .groupName(&quot;hello&quot;) // 配置分组 // 省略配置....&#125; 2、重启项目查看分组 3、如何配置多个分组？配置多个分组只需要配置多个docket即可： 123456789101112@Beanpublic Docket docket1()&#123; return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;group1&quot;);&#125;@Beanpublic Docket docket2()&#123; return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;group2&quot;);&#125;@Beanpublic Docket docket3()&#123; return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;group3&quot;);&#125; 4、重启项目查看即可 19.7、实体配置 1、新建一个实体类 1234567@ApiModel(&quot;用户实体&quot;)public class User &#123; @ApiModelProperty(&quot;用户名&quot;) public String username; @ApiModelProperty(&quot;密码&quot;) public String password;&#125; 2、只要这个实体在请求接口的返回值上（即使是泛型），都能映射到实体项中： 1234@RequestMapping(&quot;/getUser&quot;)public User getUser()&#123; return new User();&#125; 3、重启查看测试 注：并不是因为@ApiModel这个注解让实体显示在这里了，而是只要出现在接口方法的返回值上的实体都会显示在这里，而@ApiModel和**@ApiModelProperty这两个注解只是为实体添加注释的。** @ApiModel为类添加注释 @ApiModelProperty为类属性添加注释 19.8、常用注解 Swagger的所有注解定义在io.swagger.annotations包下 下面列一些经常用到的，未列举出来的可以另行查阅说明： Swagger注解 简单说明 @Api(tags = “xxx模块说明”) 作用在模块类上 @ApiOperation(“xxx接口说明”) 作用在接口方法上 @ApiModel(“xxxPOJO说明”) 作用在模型类上：如VO、BO @ApiModelProperty(value = “xxx属性说明”,hidden = true) 作用在类方法和属性上，hidden设置为true可以隐藏该属性 @ApiParam(“xxx参数说明”) 作用在参数、方法和字段上，类似@ApiModelProperty 我们也可以给请求的接口配置一些注释 123456@ApiOperation(&quot;狂神的接口&quot;)@PostMapping(&quot;/kuang&quot;)@ResponseBodypublic String kuang(@ApiParam(&quot;这个名字会被返回&quot;)String username)&#123; return username;&#125; 这样的话，可以给一些比较难理解的属性或者接口，增加一些配置信息，让人更容易阅读！ 相较于传统的Postman或Curl方式测试接口，使用swagger简直就是傻瓜式操作，不需要额外说明文档(写得好本身就是文档)而且更不容易出错，只需要录入数据然后点击Execute，如果再配合自动化框架，可以说基本就不需要人为操作了。 Swagger是个优秀的工具，现在国内已经有很多的中小型互联网公司都在使用它，相较于传统的要先出Word接口文档再测试的方式，显然这样也更符合现在的快速迭代开发行情。当然了，提醒下大家在正式环境要记得关闭Swagger，一来出于安全考虑二来也可以节省运行时内存。 Swagger3和Swagger2对比 ▌swagger3.0 与2.xx配置差异： 应用主类添加注解@EnableOpenApi (swagger2是@EnableSwagger2) swagger配置类SwaggerProperties.class，与swagger2.xx 版本有差异，具体看下文 自定义一个配置类 SwaggerConfiguration.class,看下文 访问地址：http://localhost:8080/swagger-ui/index.html (swagger2.xx版本访问的地址为http://localhost:8080/swagger-ui.html) ▌整合使用完整过程 Maven项目中引入springfox-boot-starter依赖： 12345&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt; application.yml配置 123456789101112spring: application: name: springfox-swaggerserver: port: 8080# ===== 自定义swagger配置 ===== #swagger: enable: true application-name: $&#123;spring.application.name&#125; application-version: 1.0 application-description: springfox swagger 3.0整合Demo try-host: http://localhost:$&#123;server.port&#125; 应用主类 Controller类 123456789101112131415161718192021222324@EnableOpenApi // 也可以不写此注解@Api(description=&quot;讲师管理&quot;)@RestController@RequestMapping(&quot;/admin/edu/teacher&quot;)public class MyController &#123; @Autowired private TeacherService teacherService; @ApiOperation(value = &quot;所有讲师列表&quot;) @GetMapping public List&lt;Teacher&gt; list()&#123; return teacherService.list(null); &#125; @ApiOperation(value = &quot;根据ID删除讲师&quot;) @DeleteMapping(&quot;&#123;id&#125;&quot;) public boolean removeById( @ApiParam(name = &quot;id&quot;, value = &quot;讲师ID&quot;, required = true) @PathVariable String id)&#123; return teacherService.removeById(id); &#125;&#125; 一些常用注解说明 @Api：用在controller类，描述API接口 @ApiOperation：描述接口方法 @ApiModel：描述对象 @ApiModelProperty：描述对象属性 @ApiImplicitParams：描述接口参数 @ApiResponses：描述接口响应 @ApiIgnore：忽略接口方法 自定义一个swagger配置类SwaggerProperties.class 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@Component@ConfigurationProperties(&quot;swagger&quot;)public class SwaggerProperties &#123; /** * 是否开启swagger，生产环境一般关闭，所以这里定义一个变量 */ private Boolean enable; /** * 项目应用名 */ private String applicationName; /** * 项目版本信息 */ private String applicationVersion; /** * 项目描述信息 */ private String applicationDescription; /** * 接口调试地址 */ private String tryHost; public Boolean getEnable() &#123; return enable; &#125; public void setEnable(Boolean enable) &#123; this.enable = enable; &#125; public String getApplicationName() &#123; return applicationName; &#125; public void setApplicationName(String applicationName) &#123; this.applicationName = applicationName; &#125; public String getApplicationVersion() &#123; return applicationVersion; &#125; public void setApplicationVersion(String applicationVersion) &#123; this.applicationVersion = applicationVersion; &#125; public String getApplicationDescription() &#123; return applicationDescription; &#125; public void setApplicationDescription(String applicationDescription) &#123; this.applicationDescription = applicationDescription; &#125; public String getTryHost() &#123; return tryHost; &#125; public void setTryHost(String tryHost) &#123; this.tryHost = tryHost; &#125;&#125; springfox swagger3配置类SwaggerConfiguration.class： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119import io.swagger.models.auth.In;import org.apache.commons.lang3.reflect.FieldUtils;import org.springframework.boot.SpringBootVersion;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.util.ReflectionUtils;import org.springframework.web.servlet.config.annotation.InterceptorRegistration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.oas.annotations.EnableOpenApi;import springfox.documentation.service.*;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spi.service.contexts.SecurityContext;import springfox.documentation.spring.web.plugins.Docket;import java.lang.reflect.Field;import java.util.*;@Configurationpublic class SwaggerConfiguration implements WebMvcConfigurer &#123; private final SwaggerProperties swaggerProperties; public SwaggerConfiguration(SwaggerProperties swaggerProperties) &#123; this.swaggerProperties = swaggerProperties; &#125; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.OAS_30).pathMapping(&quot;/&quot;) // 定义是否开启swagger，false为关闭，可以通过变量控制 .enable(swaggerProperties.getEnable()) // 将api的元信息设置为包含在json ResourceListing响应中。 .apiInfo(apiInfo()) // 接口调试地址 .host(swaggerProperties.getTryHost()) // 选择哪些接口作为swagger的doc发布 .select() .apis(RequestHandlerSelectors.any()) .paths(PathSelectors.any()) .build() // 支持的通讯协议集合 .protocols(newHashSet(&quot;https&quot;, &quot;http&quot;)) // 授权信息设置，必要的header token等认证信息 .securitySchemes(securitySchemes()) // 授权信息全局应用 .securityContexts(securityContexts()); &#125; /** * API 页面上半部分展示信息 */ private ApiInfo apiInfo() &#123; return new ApiInfoBuilder().title(swaggerProperties.getApplicationName() + &quot; Api Doc&quot;) .description(swaggerProperties.getApplicationDescription()) .contact(new Contact(&quot;lighter&quot;, null, &quot;123456@gmail.com&quot;)) .version(&quot;Application Version: &quot; + swaggerProperties.getApplicationVersion() + &quot;, Spring Boot Version: &quot; + SpringBootVersion.getVersion()) .build(); &#125; /** * 设置授权信息 */ private List&lt;SecurityScheme&gt; securitySchemes() &#123; ApiKey apiKey = new ApiKey(&quot;BASE_TOKEN&quot;, &quot;token&quot;, In.HEADER.toValue()); return Collections.singletonList(apiKey); &#125; /** * 授权信息全局应用 */ private List&lt;SecurityContext&gt; securityContexts() &#123; return Collections.singletonList( SecurityContext.builder() .securityReferences(Collections.singletonList(new SecurityReference(&quot;BASE_TOKEN&quot;, new AuthorizationScope[]&#123;new AuthorizationScope(&quot;global&quot;, &quot;&quot;)&#125;))) .build() ); &#125; @SafeVarargs private final &lt;T&gt; Set&lt;T&gt; newHashSet(T... ts) &#123; if (ts.length &gt; 0) &#123; return new LinkedHashSet&lt;&gt;(Arrays.asList(ts)); &#125; return null; &#125; /** * 通用拦截器排除swagger设置，所有拦截器都会自动加swagger相关的资源排除信息 */ @SuppressWarnings(&quot;unchecked&quot;) @Override public void addInterceptors(InterceptorRegistry registry) &#123; try &#123; Field registrationsField = FieldUtils.getField(InterceptorRegistry.class, &quot;registrations&quot;, true); List&lt;InterceptorRegistration&gt; registrations = (List&lt;InterceptorRegistration&gt;) ReflectionUtils.getField(registrationsField, registry); if (registrations != null) &#123; for (InterceptorRegistration interceptorRegistration : registrations) &#123; interceptorRegistration .excludePathPatterns(&quot;/swagger**/**&quot;) .excludePathPatterns(&quot;/webjars/**&quot;) .excludePathPatterns(&quot;/v3/**&quot;) .excludePathPatterns(&quot;/doc.html&quot;); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 效果图： ▌扩展资料 swagger 官网：swagger.io(https://swagger.io/) springfox 官网：springfox(http://springfox.github.io/springfox/) springfox Github 仓库：springfox / springfox(https://github.com/springfox/springfox) springfox-demos Github 仓库：springfox / springfox-demos(https://github.com/springfox/springfox-demos) springfox Maven 仓库：Home » io.springfox(https://mvnrepository.com/artifact/io.springfox)","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"后端学习","slug":"后端学习","permalink":"http://example.com/tags/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"狂神说Springboot2","slug":"狂神说Springboot2","date":"2021-04-01T03:58:10.000Z","updated":"2021-04-02T07:26:44.382Z","comments":true,"path":"2021/04/01/狂神说Springboot2/","link":"","permalink":"http://example.com/2021/04/01/%E7%8B%82%E7%A5%9E%E8%AF%B4Springboot2/","excerpt":"","text":"17、集成SpringSecurity 17.1、安全简介 在 Web 开发中，安全一直是非常重要的一个方面。安全虽然属于应用的非功能性需求，但是应该在应用开发的初期就考虑进来。如果在应用开发的后期才考虑安全的问题，就可能陷入一个两难的境地：一方面，应用存在严重的安全漏洞，无法满足用户的要求，并可能造成用户的隐私数据被攻击者窃取；另一方面，应用的基本架构已经确定，要修复安全漏洞，可能需要对系统的架构做出比较重大的调整，因而需要更多的开发时间，影响应用的发布进程。因此，从应用开发的第一天就应该把安全相关的因素考虑进来，并在整个应用的开发过程中。 市面上存在比较有名的：Shiro，Spring Security ！ 这里需要阐述一下的是，每一个框架的出现都是为了解决某一问题而产生了，那么Spring Security框架的出现是为了解决什么问题呢？ 首先我们看下它的官网介绍：Spring Security官网地址 Spring Security is a powerful and highly customizable authentication and access-control framework. It is the de-facto standard for securing Spring-based applications. Spring Security is a framework that focuses on providing both authentication and authorization to Java applications. Like all Spring projects, the real power of Spring Security is found in how easily it can be extended to meet custom requirements Spring Security是一个功能强大且高度可定制的身份验证和访问控制框架。它实际上是保护基于spring的应用程序的标准。 Spring Security是一个框架，侧重于为Java应用程序提供身份验证和授权。与所有Spring项目一样，Spring安全性的真正强大之处在于它可以轻松地扩展以满足定制需求 从官网的介绍中可以知道这是一个权限框架。想我们之前做项目是没有使用框架是怎么控制权限的？对于权限 一般会细分为功能权限，访问权限，和菜单权限。代码会写的非常的繁琐，冗余。 怎么解决之前写权限代码繁琐，冗余的问题，一些主流框架就应运而生而Spring Scecurity就是其中的一种。 Spring 是一个非常流行和成功的 Java 应用开发框架。Spring Security 基于 Spring 框架，提供了一套 Web 应用安全性的完整解决方案。一般来说，Web 应用的安全性包括用户认证（Authentication）和用户授权（Authorization）两个部分。用户认证指的是验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。 对于上面提到的两种应用情景，Spring Security 框架都有很好的支持。在用户认证方面，Spring Security 框架支持主流的认证方式，包括 HTTP 基本认证、HTTP 表单验证、HTTP 摘要认证、OpenID 和 LDAP 等。在用户授权方面，Spring Security 提供了基于角色的访问控制和访问控制列表（Access Control List，ACL），可以对应用中的领域对象进行细粒度的控制。 权限：功能、访问、菜单权限 拦截器代码过多用 17.2、实战测试 网站开发小技巧： 在配置文件配置 1spring.thymeleaf.cache=false 配置是清除缓存，实现热部署。也就是修改了html后不用重启，刷新页面就能看到效果。 修改完html后一定要ctrl+f9重新build一下。再回到浏览器刷新，就能看到效果了 实验环境搭建 1、新建一个初始的springboot项目web模块，thymeleaf模块 地址：https://gitee.com/ENNRIAAA/spring-security-material 2、导入静态资源 3、controller跳转！ 1234567891011121314151617181920212223@Controllerpublic class RouterController &#123; @RequestMapping(&#123;&quot;/&quot;,&quot;/index&quot;&#125;) public String index()&#123; return &quot;index&quot;; &#125; @RequestMapping(&quot;/toLogin&quot;) public String toLogin()&#123; return &quot;views/login&quot;; &#125; @RequestMapping(&quot;/level1/&#123;id&#125;&quot;) public String level1(@PathVariable(&quot;id&quot;) int id)&#123; return &quot;views/level1/&quot;+id; &#125; @RequestMapping(&quot;/level2/&#123;id&#125;&quot;) public String level2(@PathVariable(&quot;id&quot;) int id)&#123; return &quot;views/level2/&quot;+id; &#125; @RequestMapping(&quot;/level3/&#123;id&#125;&quot;) public String level3(@PathVariable(&quot;id&quot;) int id)&#123; return &quot;views/level3/&quot;+id; &#125;&#125; 4、测试实验环境是否OK！ 认识SpringSecurity Spring Security **是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型，**他可以实现强大的Web安全控制，对于安全控制，我们仅需要引入 spring-boot-starter-security 模块，进行少量的配置，即可实现强大的安全管理！ 记住几个类： WebSecurityConfigurerAdapter：自定义Security策略 AuthenticationManagerBuilder：自定义认证策略 @EnableWebSecurity：开启WebSecurity模式 @Enablexxxx 开启某个功能 Spring Security的两个主要目标是 “认证” 和 “授权”（访问控制）。 “认证”（Authentication） 身份验证是关于验证您的凭据，如用户名/用户ID和密码，以验证您的身份。 身份验证通常通过用户名和密码完成，有时与身份验证因素结合使用。 “授权” （Authorization） 授权发生在系统成功验证您的身份后，最终会授予您访问资源（如信息，文件，数据库，资金，位置，几乎任何内容）的完全权限。 这个概念是通用的，而不是只在Spring Security 中存在。 认证和授权 目前，我们的测试环境，是谁都可以访问的，我们使用 Spring Security 增加上认证和授权的功能 1、引入 Spring Security 模块 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 2、编写 Spring Security 配置类 参考官网：https://spring.io/projects/spring-security 查看我们自己项目中的版本，找到对应的帮助文档： https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5 #servlet-applications 8.16.4 3、编写基础配置类 1234567@EnableWebSecurity // 开启WebSecurity模式public class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; &#125;&#125; 定制请求的授权规则 12345678910111213141516171819@EnableWebSecurity // 开启WebSecurity模式public class SecurityConfig extends WebSecurityConfigurerAdapter &#123; //链式编程 @Override protected void configure(HttpSecurity http) throws Exception &#123; //首页所有人可以访问，功能页只有对应有权限的人能访问 //请求授权的规则 http.authorizeRequests() .antMatchers(&quot;/&quot;).permitAll() .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;vip1&quot;) .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;vip2&quot;) .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;vip3&quot;); //没有权限默认调到登录页面 // /login //http.formLogin(); &#125;&#125; 4、测试一下：发现除了首页都进不去了！因为我们目前没有登录的角色，因为请求需要登录的角色拥有对应的权限才可以！ 5、在configure()方法中加入以下配置，开启自动配置的登录功能！ 1234// 开启自动配置的登录功能// /login 请求来到登录页// /login?error 重定向到这里表示登录失败http.formLogin(); 7、测试一下：发现，没有权限的时候，会跳转到登录的页面！ 8、查看刚才登录页的注释信息； 我们可以定义认证规则，重写configure(AuthenticationManagerBuilder auth)方法 12345678910111213//定义认证规则@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; //在内存中定义，也可以在jdbc中去拿.... //姓名密码以及角色 auth.inMemoryAuthentication() .withUser(&quot;kuangshen&quot;).password(&quot;123456&quot;).roles(&quot;vip2&quot;,&quot;vip3&quot;) .and() .withUser(&quot;root&quot;).password(&quot;123456&quot;).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;) .and() .withUser(&quot;guest&quot;).password(&quot;123456&quot;).roles(&quot;vip1&quot;,&quot;vip2&quot;);&#125; 9、测试，我们可以使用这些账号登录进行测试！发现会报错！ There is no PasswordEncoder mapped for the id “null” 10、原因，我们要将前端传过来的密码进行某种方式加密，否则就无法登录，修改代码 123456789101112131415//定义认证规则@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; //在内存中定义，也可以在jdbc中去拿.... //Spring security 5.0中新增了多种加密方式，也改变了密码的格式。 //要想我们的项目还能够正常登陆，需要修改一下configure中的代码。我们要将前端传过来的密码进行某种方式加密 //spring security 官方推荐的是使用bcrypt加密方式。 auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder()) .withUser(&quot;kuangshen&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip2&quot;,&quot;vip3&quot;) .and() .withUser(&quot;root&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;) .and() .withUser(&quot;guest&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;);&#125; 11、测试，发现，登录成功，并且每个角色只能访问自己认证下的规则！搞定 权限控制和注销显示设置 1、开启自动配置的注销的功能 12345678//定制请求的授权规则@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; //.... //开启自动配置的注销的功能 // /logout 注销请求 http.logout();&#125; 小技巧：注意改变界面形态 2、我们在前端，增加一个注销的按钮，index.html 导航栏中 123&lt;a class=&quot;item&quot; th:href=&quot;@&#123;/logout&#125;&quot;&gt; &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 注销&lt;/a&gt; 3、我们可以去测试一下，登录成功后点击注销，发现注销完毕会跳转到登录页面！ 4、但是，我们想让他注销成功后，依旧可以跳转到首页，该怎么处理呢？ 12// .logoutSuccessUrl(&quot;/&quot;); 注销成功来到首页http.logout().logoutSuccessUrl(&quot;/&quot;); 5、测试，注销完毕后，发现跳转到首页OK 6、我们现在又来一个需求：用户没有登录的时候，导航栏上只显示登录按钮，用户登录之后，导航栏可以显示登录的用户信息及注销按钮！还有就是，比如kuangshen这个用户，它只有 vip2，vip3功能，那么登录则只显示这两个功能，而vip1的功能菜单不显示！这个就是真实的网站情况了！该如何做呢？ 我们需要结合thymeleaf中的一些功能 sec：authorize=“isAuthenticated()”:是否认证登录！来显示不同的页面 Maven依赖： 123456&lt;!-- https://mvnrepository.com/artifact/org.thymeleaf.extras/thymeleaf-extras-springsecurity4 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt; &lt;version&gt;3.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; 7、修改我们的 前端页面 导入命名空间 xmlns:sec=\"http://www.thymeleaf.org/extras/spring-security\" 可以加提示不报错，不写程序一样会跑 12345678910111213141516171819202122232425262728293. 修改导航栏，增加认证判断4. &#96;&#96;&#96;html &lt;!--登录注销--&gt; &lt;div class&#x3D;&quot;right menu&quot;&gt; &lt;!--如果未登录--&gt; &lt;div sec:authorize&#x3D;&quot;!isAuthenticated()&quot;&gt; &lt;a class&#x3D;&quot;item&quot; th:href&#x3D;&quot;@&#123;&#x2F;login&#125;&quot;&gt; &lt;i class&#x3D;&quot;address card icon&quot;&gt;&lt;&#x2F;i&gt; 登录 &lt;&#x2F;a&gt; &lt;&#x2F;div&gt; &lt;!--如果已登录--&gt; &lt;div sec:authorize&#x3D;&quot;isAuthenticated()&quot;&gt; &lt;a class&#x3D;&quot;item&quot;&gt; &lt;i class&#x3D;&quot;address card icon&quot;&gt;&lt;&#x2F;i&gt; 用户名：&lt;span sec:authentication&#x3D;&quot;principal.username&quot;&gt;&lt;&#x2F;span&gt; 角色：&lt;span sec:authentication&#x3D;&quot;principal.authorities&quot;&gt;&lt;&#x2F;span&gt; &lt;&#x2F;a&gt; &lt;&#x2F;div&gt; &lt;div sec:authorize&#x3D;&quot;isAuthenticated()&quot;&gt; &lt;a class&#x3D;&quot;item&quot; th:href&#x3D;&quot;@&#123;&#x2F;logout&#125;&quot;&gt; &lt;i class&#x3D;&quot;address card icon&quot;&gt;&lt;&#x2F;i&gt; 注销 &lt;&#x2F;a&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; 8、重启测试，我们可以登录试试看，登录成功后确实，显示了我们想要的页面； 9、如果注销404了，就是因为它默认防止csrf跨站请求伪造，因为会产生安全问题，我们可以将请求改为post表单提交，或者在spring security中关闭csrf功能；我们试试：在 配置中增加 http.csrf().disable(); 12http.csrf().disable();//关闭csrf功能:跨站请求伪造,默认只能通过post方式提交logout请求http.logout().logoutSuccessUrl(&quot;/&quot;); 10、我们继续将下面的角色功能块认证完成！ 增加hasRole(‘vip1/2/3’) 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!-- sec:authorize=&quot;hasRole(&#x27;vip1&#x27;)&quot; --&gt;&lt;div class=&quot;column&quot; sec:authorize=&quot;hasRole(&#x27;vip1&#x27;)&quot;&gt; &lt;div class=&quot;ui raised segment&quot;&gt; &lt;div class=&quot;ui&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;h5 class=&quot;content&quot;&gt;Level 1&lt;/h5&gt; &lt;hr&gt; &lt;div&gt;&lt;a th:href=&quot;@&#123;/level1/1&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-1-1&lt;/a&gt;&lt;/div&gt; &lt;div&gt;&lt;a th:href=&quot;@&#123;/level1/2&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-1-2&lt;/a&gt;&lt;/div&gt; &lt;div&gt;&lt;a th:href=&quot;@&#123;/level1/3&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-1-3&lt;/a&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;column&quot; sec:authorize=&quot;hasRole(&#x27;vip2&#x27;)&quot;&gt; &lt;div class=&quot;ui raised segment&quot;&gt; &lt;div class=&quot;ui&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;h5 class=&quot;content&quot;&gt;Level 2&lt;/h5&gt; &lt;hr&gt; &lt;div&gt;&lt;a th:href=&quot;@&#123;/level2/1&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-2-1&lt;/a&gt;&lt;/div&gt; &lt;div&gt;&lt;a th:href=&quot;@&#123;/level2/2&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-2-2&lt;/a&gt;&lt;/div&gt; &lt;div&gt;&lt;a th:href=&quot;@&#123;/level2/3&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-2-3&lt;/a&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;column&quot; sec:authorize=&quot;hasRole(&#x27;vip3&#x27;)&quot;&gt; &lt;div class=&quot;ui raised segment&quot;&gt; &lt;div class=&quot;ui&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;h5 class=&quot;content&quot;&gt;Level 3&lt;/h5&gt; &lt;hr&gt; &lt;div&gt;&lt;a th:href=&quot;@&#123;/level3/1&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-3-1&lt;/a&gt;&lt;/div&gt; &lt;div&gt;&lt;a th:href=&quot;@&#123;/level3/2&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-3-2&lt;/a&gt;&lt;/div&gt; &lt;div&gt;&lt;a th:href=&quot;@&#123;/level3/3&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-3-3&lt;/a&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 11、测试一下！ 12、权限控制和注销搞定！ 记住我 现在的情况，我们只要登录之后，关闭浏览器，再登录，就会让我们重新登录，但是很多网站的情况，就是有一个记住密码的功能，这个该如何实现呢？很简单 1、开启记住我功能 1234567//定制请求的授权规则@Overrideprotected void configure(HttpSecurity http) throws Exception &#123;//。。。。。。。。。。。 //记住我 http.rememberMe();&#125; 2、我们再次启动项目测试一下，发现登录页多了一个记住我功能，我们登录之后关闭 浏览器，然后重新打开浏览器访问，发现用户依旧存在！ 思考：如何实现的呢？其实非常简单 我们可以查看浏览器的cookie 3、我们点击注销的时候，可以发现，spring security 帮我们自动删除了这个 cookie 4、结论：登录成功后，将cookie发送给浏览器保存，以后登录带上这个cookie，只要通过检查就可以免登录了。如果点击注销，则会删除这个cookie，具体的原理我们在JavaWeb阶段都讲过了，这里就不在多说了！ 定制登录页 现在这个登录页面都是spring security 默认的，怎么样可以使用我们自己写的Login界面呢？ 1、在刚才的登录页配置后面指定 loginpage 1http.formLogin().loginPage(&quot;/toLogin&quot;); 2、然后前端也需要指向我们自己定义的 login请求 123&lt;a class=&quot;item&quot; th:href=&quot;@&#123;/toLogin&#125;&quot;&gt; &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 登录&lt;/a&gt; 3、我们登录，需要将这些信息发送到哪里，我们也需要配置，login.html 配置提交请求及方式，方式必须为post: 在 loginPage()源码中的注释上有写明： 1234567891011121314151617&lt;form th:action=&quot;@&#123;/login&#125;&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;field&quot;&gt; &lt;label&gt;Username&lt;/label&gt; &lt;div class=&quot;ui left icon input&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Username&quot; name=&quot;username&quot;&gt; &lt;i class=&quot;user icon&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;field&quot;&gt; &lt;label&gt;Password&lt;/label&gt; &lt;div class=&quot;ui left icon input&quot;&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;i class=&quot;lock icon&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;/div&gt; &lt;input type=&quot;submit&quot; class=&quot;ui blue submit button&quot;/&gt;&lt;/form&gt; 4、这个请求提交上来，我们还需要验证处理，怎么做呢？我们可以查看formLogin()方法的源码！我们配置接收登录的用户名和密码的参数！ 12345http.formLogin() .usernameParameter(&quot;username&quot;) .passwordParameter(&quot;password&quot;) .loginPage(&quot;/toLogin&quot;) .loginProcessingUrl(&quot;/login&quot;); // 登陆表单提交请求 5、在登录页增加记住我的多选框 1&lt;input type=&quot;checkbox&quot; name=&quot;remember&quot;&gt; 记住我 6、后端验证处理！ 12//定制记住我的参数！http.rememberMe().rememberMeParameter(&quot;remember&quot;); 7、测试，OK 17.3、完整配置代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; //定制请求的授权规则 @Override protected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests().antMatchers(&quot;/&quot;).permitAll() .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;vip1&quot;) .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;vip2&quot;) .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;vip3&quot;); //开启自动配置的登录功能：如果没有权限，就会跳转到登录页面！ // /login 请求来到登录页 // /login?error 重定向到这里表示登录失败 http.formLogin() .usernameParameter(&quot;username&quot;) .passwordParameter(&quot;password&quot;) .loginPage(&quot;/toLogin&quot;) .loginProcessingUrl(&quot;/login&quot;); // 登陆表单提交请求 //开启自动配置的注销的功能 // /logout 注销请求 // .logoutSuccessUrl(&quot;/&quot;); 注销成功来到首页 http.csrf().disable();//关闭csrf功能:跨站请求伪造,默认只能通过post方式提交logout请求 http.logout().logoutSuccessUrl(&quot;/&quot;); //记住我 http.rememberMe().rememberMeParameter(&quot;remember&quot;); &#125; //定义认证规则 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; //在内存中定义，也可以在jdbc中去拿.... //Spring security 5.0中新增了多种加密方式，也改变了密码的格式。 //要想我们的项目还能够正常登陆，需要修改一下configure中的代码。我们要将前端传过来的密码进行某种方式加密 //spring security 官方推荐的是使用bcrypt加密方式。 auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder()) .withUser(&quot;kuangshen&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip2&quot;,&quot;vip3&quot;) .and() .withUser(&quot;root&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;) .and() .withUser(&quot;guest&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;); &#125;&#125; 18、集成Shiro 18.1、简介 Apache Shiro是一个Java 的安全（权限）框架。 Shiro 可以非常容易的开发出足够好的应用，其不仅可以用在JavaSE环境，也可以用在JavaEE环境。 Shiro可以完成，认证，授权，加密，会话管理，Web集成，缓存等。 下载地址http://shiro.apache.org/ 有哪些功能？ Authentication：身份认证 / 登录，验证用户是不是拥有相应的身份； Authorization：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限； Session Management：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通 JavaSE 环境的，也可以是如 Web 环境的； Cryptography：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储； Web Support：Web 支持，可以非常容易的集成到 Web 环境； Caching：缓存，比如用户登录后，其用户信息、拥有的角色 / 权限不必每次去查，这样可以提高效率； Concurrency：shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去； Testing：提供测试支持； Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问； Remember Me：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。 Shiro 架构（外部） 从外部来看 Shiro ，即从应用程序角度的来观察如何使用 Shiro 完成工作。如下图： Subject：主体，代表了当前 “用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是 Subject，如网络爬虫，机器人等；即一个抽象概念；所有 Subject 都绑定到 SecurityManager，与 Subject 的所有交互都会委托给 SecurityManager；可以把 Subject 认为是一个门面；SecurityManager 才是实际的执行者； SecurityManager：安全管理器；即所有与安全有关的操作都会与 SecurityManager 交互；且它管理着所有 Subject；可以看出它是 Shiro 的核心，它负责与后边介绍的其他组件进行交互，如果学习过 SpringMVC，你可以把它看成 DispatcherServlet 前端控制器； Realm：域，Shiro 从从 Realm 获取安全数据（如用户、角色、权限），就是说 SecurityManager 要验证用户身份，那么它需要从 Realm 获取相应的用户进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色 / 权限进行验证用户是否能进行操作；可以把 Realm 看成 DataSource，即安全数据源。 1见后创建由下向上 也就是说对于我们而言，最简单的一个 Shiro 应用： 应用代码通过 Subject 来进行认证和授权，而 Subject 又委托给 SecurityManager； 我们需要给 Shiro 的 SecurityManager 注入 Realm，从而让 SecurityManager 能得到合法的用户及其权限进行判断。 从以上也可以看出，Shiro 不提供维护用户 / 权限，而是通过 Realm 让开发人员自己注入。 Shiro架构（内部） Subject：主体，可以看到主体可以是任何可以与应用交互的 “用户”； SecurityManager：相当于 SpringMVC 中的 DispatcherServlet 或者 Struts2 中的 FilterDispatcher；是 Shiro 的心脏；所有具体的交互都通过 SecurityManager 进行控制；它管理着所有 Subject、且负责进行认证和授权、及会话、缓存的管理。 Authenticator：认证器，负责主体认证的，这是一个扩展点，如果用户觉得 Shiro 默认的不好，可以自定义实现；其需要认证策略（Authentication Strategy），即什么情况下算用户认证通过了； Authrizer：授权器，或者访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能； Realm：可以有 1 个或多个 Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是 JDBC 实现，也可以是 LDAP 实现，或者内存实现等等；由用户提供；注意：Shiro 不知道你的用户 / 权限存储在哪及以何种格式存储；所以我们一般在应用中都需要实现自己的 Realm； SessionManager：如果写过 Servlet 就应该知道 Session 的概念，Session 呢需要有人去管理它的生命周期，这个组件就是 SessionManager；而 Shiro 并不仅仅可以用在 Web 环境，也可以用在如普通的 JavaSE 环境、EJB 等环境；所以呢，Shiro 就抽象了一个自己的 Session 来管理主体与应用之间交互的数据；这样的话，比如我们在 Web 环境用，刚开始是一台 Web 服务器；接着又上了台 EJB 服务器；这时想把两台服务器的会话数据放到一个地方，这个时候就可以实现自己的分布式会话（如把数据放到 Memcached 服务器）； SessionDAO：DAO 大家都用过，数据访问对象，用于会话的 CRUD，比如我们想把 Session 保存到数据库，那么可以实现自己的 SessionDAO，通过如 JDBC 写到数据库；比如想把 Session 放到 Memcached 中，可以实现自己的 Memcached SessionDAO；另外 SessionDAO 中可以使用 Cache 进行缓存，以提高性能； CacheManager：缓存控制器，来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能 Cryptography：密码模块，Shiro 提高了一些常见的加密组件用于如密码加密 / 解密的。 18.2、快速开始 查看官网文档：http://shiro.apache.org/tutorial.html 官方的quickstart：https://github.com/apache/shiro/tree/master/samples/quickstart 创建一个maven父工程，用于学习shiro，删掉src 创建一个普通的maven子工程：shiro-01-helloworld 根据官方文档，导入Shiro的依赖 更改细节 123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- configure logging --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt; &lt;version&gt;1.7.21&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.21&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; log4j.properties 123456789101112131415161718log4j.rootLogger=INFO, stdoutlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m %n# General Apache librarieslog4j.logger.org.apache=WARN# Springlog4j.logger.org.springframework=WARN# Default Shiro logginglog4j.logger.org.apache.shiro=INFO# Disable verbose logginglog4j.logger.org.apache.shiro.util.ThreadContext=WARNlog4j.logger.org.apache.shiro.cache.ehcache.EhCache=WARN shiro.ini 123456789101112131415161718192021222324252627[users]# user &#x27;root&#x27; with password &#x27;secret&#x27; and the &#x27;admin&#x27; roleroot = secret, admin# user &#x27;guest&#x27; with the password &#x27;guest&#x27; and the &#x27;guest&#x27; roleguest = guest, guest# user &#x27;presidentskroob&#x27; with password &#x27;12345&#x27; (&quot;That&#x27;s the same combination on# my luggage!!!&quot; ;)), and role &#x27;president&#x27;presidentskroob = 12345, president# user &#x27;darkhelmet&#x27; with password &#x27;ludicrousspeed&#x27; and roles &#x27;darklord&#x27; and &#x27;schwartz&#x27;darkhelmet = ludicrousspeed, darklord, schwartz# user &#x27;lonestarr&#x27; with password &#x27;vespa&#x27; and roles &#x27;goodguy&#x27; and &#x27;schwartz&#x27;lonestarr = vespa, goodguy, schwartz# -----------------------------------------------------------------------------# Roles with assigned permissions# # Each line conforms to the format defined in the# org.apache.shiro.realm.text.TextConfigurationRealm#setRoleDefinitions JavaDoc# -----------------------------------------------------------------------------[roles]# &#x27;admin&#x27; role has all permissions, indicated by the wildcard &#x27;*&#x27;admin = *# The &#x27;schwartz&#x27; role can do anything (*) with any lightsaber:schwartz = lightsaber:*# The &#x27;goodguy&#x27; role is allowed to &#x27;drive&#x27; (action) the winnebago (type) with# license plate &#x27;eagle5&#x27; (instance specific id)goodguy = winnebago:drive:eagle5 QuickStart.java --了解方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//获得当前用户Subject currentUser = SecurityUtils.getSubject();//通过当前用户获取session 脱离web存取值Session session = currentUser.getSession();session.setAttribute(&quot;someKey&quot;, &quot;aValue&quot;);String value = (String) session.getAttribute(&quot;someKey&quot;);if (value.equals(&quot;aValue&quot;)) &#123;log.info(&quot;Subject-&gt;session [&quot; + value + &quot;]&quot;);&#125;//判断当前用户是否被认证if (!currentUser.isAuthenticated()) &#123;//Token:令牌UsernamePasswordToken token = new UsernamePasswordToken(&quot;lonestarr&quot;, &quot;vespa&quot;);token.setRememberMe(true);//记住我try &#123;currentUser.login(token);//登录操作，有异常报错&#125; catch (UnknownAccountException uae) &#123;log.info(&quot;There is no user with username of &quot; + token.getPrincipal());&#125; catch (IncorrectCredentialsException ice) &#123;log.info(&quot;Password for account &quot; + token.getPrincipal() + &quot; was incorrect!&quot;);&#125; catch (LockedAccountException lae) &#123;log.info(&quot;The account for username &quot; + token.getPrincipal() + &quot; is locked. &quot; +&quot;Please contact your administrator to unlock it.&quot;);&#125;catch (AuthenticationException ae) &#123;&#125;&#125;//当前用户认证log.info(&quot;User [&quot; + currentUser.getPrincipal() + &quot;] logged in successfully.&quot;);//test a role:if (currentUser.hasRole(&quot;schwartz&quot;)) &#123;log.info(&quot;May the Schwartz be with you!&quot;);&#125; else &#123;log.info(&quot;Hello, mere mortal.&quot;);&#125;//简单权限if (currentUser.isPermitted(&quot;lightsaber:wield&quot;)) &#123;log.info(&quot;You may use a lightsaber ring. Use it wisely.&quot;);&#125; else &#123;log.info(&quot;Sorry, lightsaber rings are for schwartz masters only.&quot;);&#125;//细粒度的权限if (currentUser.isPermitted(&quot;winnebago:drive:eagle5&quot;)) &#123;log.info(&quot;You are permitted to &#x27;drive&#x27; the winnebago with license plate (id) &#x27;eagle5&#x27;. &quot; +&quot;Here are the keys - have fun!&quot;);&#125; else &#123;log.info(&quot;Sorry, you aren&#x27;t allowed to drive the &#x27;eagle5&#x27; winnebago!&quot;);&#125;//注销currentUser.logout();System.exit(0); 结合ini文件查看当前用户 18.3、SpringBoot整合Shiro环境搭建 新建SpringBoot项目,勾选web和thymeleaf 保持项目清洁,删除 templates下新建 index.html 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;https://www.thymeleaf.org&quot; xmlns:shiro=&quot;https://www.thymeleaf.org/thymeleaf-extras-shiro&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;首页&lt;/h1&gt;&lt;p th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 123456789@Controllerpublic class MyController &#123; @RequestMapping(&#123;&quot;/&quot;,&quot;/index&quot;&#125;) public String toIndex(Model model)&#123; model.addAttribute(&quot;msg&quot;,&quot;hello,shiro&quot;); return &quot;index&quot;; &#125;&#125; 测试 让我们继续 Subject用户 SecurityManager管理所有用户 Realm连接数据 maven 123456&lt;!--shiro--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt;&lt;/dependency&gt; UserRealm 1234567891011121314public class UserRealm extends AuthorizingRealm &#123; //授权 @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; System.out.println(&quot;执行了=&gt;授权AuthorizationInfo&quot;); return null; &#125; //认证 @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; System.out.println(&quot;执行了=&gt;认证AuthenticationInfo&quot;); return null; &#125;&#125; ShrioConfig.java 12345678910111213141516171819202122//ShiroFactoryBean@Beanpublic ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(&quot;securityMannager&quot;) DefaultWebSecurityManager defaultWebSecurityManager)&#123; ShiroFilterFactoryBean bean=new ShiroFilterFactoryBean(); bean.setSecurityManager(defaultWebSecurityManager); return bean;&#125;//DafaultWebSecurityMannager:2@Bean(name=&quot;securityMannager&quot;)public DefaultWebSecurityManager getDefaultWebSecurityMannager(@Qualifier(&quot;userRealm&quot;) UserRealm userRealm)&#123; DefaultWebSecurityManager securityManager=new DefaultWebSecurityManager(); //关联UserRealm securityManager.setRealm(userRealm); return securityManager;&#125;//创建realm对象@Beanpublic UserRealm userRealm()&#123; return new UserRealm();&#125; 修改ShiroConfig.java 1234567891011121314151617181920212223242526272829@Beanpublic ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(&quot;securityManager&quot;) DefaultWebSecurityManager defaultWebSecurityManager) &#123; ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean(); /*设置安全管理器*/ bean.setSecurityManager(defaultWebSecurityManager); /*添加shiro的内置过滤器 * anon 无需认证就能访问 * authc 必须认证了才能访问 * user 必须拥有记住我才能访问 * perms 拥有对某个资源的权限才能访问 * role 拥有某个角色权限才能访问 * */ /* filterMap.put(&quot;/user/add&quot;,&quot;anon&quot;); filterMap.put(&quot;/user/update&quot;,&quot;authc&quot;);*/ Map&lt;String, String&gt; filterMap = new LinkedHashMap&lt;&gt;(); /*访问/user/add，需要user:add权限*/ filterMap.put(&quot;/user/add&quot;, &quot;perms[user:add]&quot;); filterMap.put(&quot;/user/update&quot;, &quot;perms[user:update]&quot;); /*可以使用通配符*/ filterMap.put(&quot;/user/*&quot;, &quot;authc&quot;); bean.setFilterChainDefinitionMap(filterMap); /*设置登录请求*/ bean.setLoginUrl(&quot;/toLogin&quot;); return bean;&#125; MyController.java 1234@RequestMapping(&quot;/toLogin&quot;)public String toLogin()&#123; return &quot;login&quot;;&#125; 增加login.html 12345&lt;form action=&quot;&quot;&gt; &lt;p&gt;用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/p&gt; &lt;p&gt;密码：&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/p&gt;&lt;/form&gt; 实现用户认证 基于shiro的Quickstart，Controller和UserRealm类联动 MyController.java 1234567891011121314151617@RequestMapping(&quot;/login&quot;)public String login(String username,String password,Model model)&#123; //设置当前用户 Subject subject= SecurityUtils.getSubject(); //封装用户的登录数据 UsernamePasswordToken token=new UsernamePasswordToken(username,password); try &#123; /*执行登录的方法，如有有异常需要捕获*/ subject.login(token); return &quot;index&quot;; &#125; catch (UnknownAccountException e) &#123;/*用户名不存在*/ model.addAttribute(&quot;msg&quot;,&quot;用户名错误&quot;); return &quot;login&quot;; &#125; catch (IncorrectCredentialsException e)&#123;/*密码不存在*/ model.addAttribute(&quot;msg&quot;,&quot;密码错误&quot;); return &quot;login&quot;; &#125; ShiroConfig.java 123456789101112131415161718//认证@Overrideprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; System.out.println(&quot;执行了=&gt;认证AuthenticationInfo&quot;); //用户名、密码 String name=&quot;root&quot;; String password=&quot;root&quot;; UsernamePasswordToken userToken=(UsernamePasswordToken) authenticationToken; if(!userToken.getUsername().equals(name))&#123; return null;//抛出异常 UnknowAccountException &#125; //密码认证Shiro自动帮我们完成 return new SimpleAuthenticationInfo(&quot;&quot;,password,&quot;&quot;);&#125; 18.4、shiro整合mybatis 123456789101112131415161718192021&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.12&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt; 编写application.yaml 123456789101112131415161718192021222324252627282930313233spring: datasource: username: root password: root url: jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=UTF-8&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource #Spring Boot 默认是不注入这些属性值的，需要自己绑定 #druid 数据源专有配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入 #如果允许时报错 java.lang.ClassNotFoundException: org.apache.log4j.Priority #则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500#配置mybatismybatis: type-aliases-package: com.huang.pojo mapper-locations: classpath:mybatis/mapper/*.xml 编写实体类 导入lombok User 123456789101112131415161718192021222324@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private int id; private String name; private String pwd; private String perms;&#125;@Mapper//这个注解表示了这是一个mybatis的mapper类@Repositorypublic interface UserMapper &#123; List&lt;User&gt; queryUserList(); User queryUserById(int id); int addUser(User user); int updateUser(User user); int deleteUser(int id);&#125; UserMapper.xml 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.huang.mapper.UserMapper&quot;&gt; &lt;select id=&quot;queryUserList&quot; resultType=&quot;User&quot;&gt; select * from user; &lt;/select&gt; &lt;select id=&quot;queryUserByName&quot; resultType=&quot;User&quot; parameterType=&quot;String&quot;&gt; select * from user where name=#&#123;name&#125; &lt;/select&gt;&lt;/mapper&gt; service层 UserService接口 12345import com.huang.pojo.User;public interface UserService &#123; User queryUserByName(String name);&#125; UserServiceImpl 123456789@Servicepublic class UserServiceImpl implements UserService&#123; @Autowired UserMapper userMapper; @Override public User queryUserByName(String name) &#123; return userMapper.queryUserByName(name); &#125;&#125; ShiroSpringbootApplicationTests中进行测试 1234567891011121314import com.huang.service.UserServiceImpl;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclass ShiroSpringbootApplicationTests &#123; @Autowired UserServiceImpl userService; @Test void contextLoads() &#123; System.out.println(userService.queryUserByName(&quot;张三&quot;)); &#125;&#125; 测试成功 用户授权 需要权限才能访问 新增未授权页面 UserRealm.java 12345678910111213@Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; System.out.println(&quot;执行了=&gt;授权AuthorizationInfo&quot;); SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();=new SimpleAuthorizationInfo(); //经过请求就加权限 //info.addStringPermission(&quot;user:add&quot;); //拿到当前用户登陆对象 Subject subject= SecurityUtils.getSubject(); User currentUser= (User) subject.getPrincipal();//拿到User对象 info.addStringPermission(currentUser.getPerms());//设置当前用户对象 return info; &#125; 18.5、Shiro整合Thymeleaf 123456&lt;!--shiro--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt;&lt;/dependency&gt; ShiroConfig 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@Configurationpublic class ShiroConfig &#123; //ShiroFilterBean @Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(&quot;getDefaultWebSecurityManager&quot;) DefaultWebSecurityManager defaultWebSecurityManager)&#123; ShiroFilterFactoryBean bean=new ShiroFilterFactoryBean(); //设置安全管理器 bean.setSecurityManager(defaultWebSecurityManager); //添加shiro的内置过滤器 /* anon:无需认证就能访问 authc:必须认证才能访问 user:必须拥有记住我功能才能访问 perms:拥有某个资源的权限才能访问 role:拥有某个角色权限才能访问 */ //拦截 Map&lt;String,String&gt; filterMap =new LinkedHashMap&lt;&gt;(); //授权 filterMap.put(&quot;/user/add&quot;,&quot;perms[user:add]&quot;); filterMap.put(&quot;/user/update&quot;,&quot;perms[user:update]&quot;); //filterMap.put(&quot;/user/add&quot;,&quot;authc&quot;); //filterMap.put(&quot;/user/update&quot;,&quot;authc&quot;); //设置登陆的请求 bean.setLoginUrl(&quot;/toLogin&quot;); //设置未授权的请求 bean.setUnauthorizedUrl(&quot;/noauth&quot;); bean.setFilterChainDefinitionMap(filterMap); return bean; &#125; //DefaultWebSecurityManager @Bean public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(&quot;userRealm&quot;) UserRealm userRealm)&#123; DefaultWebSecurityManager securityManager=new DefaultWebSecurityManager(); //关联UserRealm securityManager.setRealm(userRealm); return securityManager; &#125; //创建realm对象 @Bean public UserRealm userRealm()&#123; return new UserRealm(); &#125; //整合shiroDialect:用来整合shiro thymeleaf @Bean public ShiroDialect getShiroDialect()&#123; return new ShiroDialect(); &#125;&#125; UserRealm 12345678910111213141516171819202122232425262728293031323334353637383940public class UserRealm extends AuthorizingRealm &#123; @Autowired UserService userService; //授权 @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; System.out.println(&quot;执行了授权&quot;); SimpleAuthorizationInfo info=new SimpleAuthorizationInfo(); //info.addStringPermission(&quot;user:add&quot;); //拿到当前用户登陆对象 Subject subject= SecurityUtils.getSubject(); User currentUser= (User) subject.getPrincipal();//拿到User对象 info.addStringPermission(currentUser.getPerms());//设置当前用户对象 return info; &#125; //认证 @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; System.out.println(&quot;执行了认证&quot;); //用户名，密码，数据库中获取 UsernamePasswordToken userToken=(UsernamePasswordToken) authenticationToken; User user=userService.queryUserByName(userToken.getUsername());//获取用户名 String name=user.getName(); String password=user.getPwd(); if(user==null)&#123;//说明查无此人 return null; &#125; //密码认证,shiro做 return new SimpleAuthenticationInfo(user,password,&quot;&quot;);//放入User对象 &#125;&#125; MyController 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.huang.controller;import org.apache.catalina.security.SecurityUtil;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.IncorrectCredentialsException;import org.apache.shiro.authc.UnknownAccountException;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.subject.Subject;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpSession;@Controllerpublic class MyController &#123; @RequestMapping(&#123;&quot;/&quot;,&quot;/index&quot;&#125;) public String toIndex(Model model)&#123; model.addAttribute(&quot;msg&quot;,&quot;hello,shiro&quot;); return &quot;index&quot;; &#125; @RequestMapping(&quot;/user/add&quot;) public String add()&#123; return &quot;user/add&quot;; &#125; @RequestMapping(&quot;/user/update&quot;) public String update()&#123; return &quot;user/update&quot;; &#125; @RequestMapping(&quot;/toLogin&quot;) public String toLogin()&#123; return &quot;login&quot;; &#125; @RequestMapping(&quot;/login&quot;) public String login(String username, String password, Model model, HttpSession session)&#123; //获取当前用户 Subject subject= SecurityUtils.getSubject(); //封装用户的登陆数据 UsernamePasswordToken token=new UsernamePasswordToken(username,password); try&#123; subject.login(token);//执行登陆的方法 session.setAttribute(&quot;loginUser&quot;,username);//设置session return &quot;index&quot;; &#125;catch (UnknownAccountException e)&#123;//用户名不存在 model.addAttribute(&quot;msg&quot;,&quot;用户名错误&quot;); return &quot;login&quot;; &#125;catch (IncorrectCredentialsException e)&#123;//密码不存在 model.addAttribute(&quot;msg&quot;,&quot;密码错误&quot;); return &quot;login&quot;; &#125; &#125; @RequestMapping(&quot;/noauth&quot;) @ResponseBody public String unauthorized()&#123; return &quot;未经授权禁止访问&quot;; &#125;&#125; UserMapper 12345678910111213141516@Mapper@Repositorypublic interface UserMapper &#123; User queryUserByName(String name); List&lt;User&gt; queryUserList(); User queryUserById(int id); int addUser(User user); int updateUser(User user); int deleteUser(int id);&#125; pojo user 12345678910@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private int id; private String name; private String pwd; private String perms;&#125; UserService 123public interface UserService &#123; User queryUserByName(String name);&#125; UserServiceImpl 12345678910@Servicepublic class UserServiceImpl implements UserService&#123; @Autowired UserMapper userMapper; @Override public User queryUserByName(String name) &#123; return userMapper.queryUserByName(name); &#125;&#125; UserMapper.xml 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.huang.mapper.UserMapper&quot;&gt; &lt;select id=&quot;queryUserList&quot; resultType=&quot;User&quot;&gt; select * from user; &lt;/select&gt; &lt;select id=&quot;queryUserByName&quot; resultType=&quot;User&quot; parameterType=&quot;String&quot;&gt; select * from user where name=#&#123;name&#125; &lt;/select&gt;&lt;/mapper&gt; add.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;添加一个用户&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;-----------------------------------------------&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;修改一个用户&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;-----------------------------------------------&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;https://www.thymeleaf.org&quot; xmlns:shiro=&quot;https://www.thymeleaf.org/thymeleaf-extras-shiro&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;首页&lt;/h1&gt;&lt;p th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/p&gt;&lt;hr&gt;&lt;div th:if=&quot;$&#123;session.loginUser==null&#125;&quot;&gt; &lt;a th:href=&quot;@&#123;/toLogin&#125;&quot;&gt;登陆&lt;/a&gt;&lt;/div&gt;&lt;div shiro:hasPermission=&quot;user:add&quot;&gt; &lt;a th:href=&quot;@&#123;/user/add&#125;&quot;&gt;add&lt;/a&gt;&lt;/div&gt;&lt;div shiro:hasPermission=&quot;user:update&quot;&gt; &lt;a th:href=&quot;@&#123;/user/update&#125;&quot;&gt;update&lt;/a&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;-----------------------------------------------&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;https://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;登陆&lt;/h1&gt;&lt;hr&gt;&lt;p style=&quot;color: red&quot; th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/p&gt;&lt;form th:action=&quot;@&#123;/login&#125;&quot;&gt; &lt;p&gt;用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/p&gt; &lt;p&gt;密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/p&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; application.yaml 1234567891011121314151617181920212223242526272829303132spring: datasource: username: root password: jia5211314 url: jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=UTF-8&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource #Spring Boot 默认是不注入这些属性值的，需要自己绑定 #druid 数据源专有配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入 #如果允许时报错 java.lang.ClassNotFoundException: org.apache.log4j.Priority #则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500mybatis: type-aliases-package: com.huang.pojo mapper-locations: classpath:mybatis/mapper/*.xml pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/com.github.theborakompanioni/thymeleaf-extras-shiro --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Subject 用户 SecurityManager 管理所有用户 Realm 连接数据 --&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.19&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--lombok--&gt; &lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.10&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--shiro--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--thymeleaf模板--&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-java8time&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 20、异步、定时、邮件任务 在我们的工作中，常常会用到异步处理任务，比如我们在网站上发送邮件，后台会去发送邮件，此时前台会造成响应不动，直到邮件发送完毕，响应才会成功，所以我们一般会采用多线程的方式去处理这些任务。还有一些定时任务，比如需要在每天凌晨的时候，分析一次前一天的日志信息。还有就是邮件的发送，微信的前身也是邮件服务呢？这些东西都是怎么实现的呢？其实SpringBoot都给我们提供了对应的支持，我们上手使用十分的简单，只需要开启一些注解支持，配置一些配置文件即可！那我们来看看吧~ 20.1、异步任务 1、创建一个service包 2、创建一个类AsyncService 异步处理还是非常常用的，比如我们在网站上发送邮件，后台会去发送邮件，此时前台会造成响应不动，直到邮件发送完毕，响应才会成功，所以我们一般会采用多线程的方式去处理这些任务。 编写方法，假装正在处理数据，使用线程设置一些延时，模拟同步等待的情况； 1234567891011@Servicepublic class AsyncService &#123; public void hello()&#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;业务进行中....&quot;); &#125;&#125; 3、编写controller包 4、编写AsyncController类 我们去写一个Controller测试一下 12345678910@RestControllerpublic class AsyncController &#123; @Autowired AsyncService asyncService; @GetMapping(&quot;/hello&quot;) public String hello()&#123; asyncService.hello(); return &quot;success&quot;; &#125;&#125; 5、访问http://localhost:8080/hello进行测试，3秒后出现success，这是同步等待的情况。 问题：我们如果想让用户直接得到消息，就在后台使用多线程的方式进行处理即可，但是每次都需要自己手动去编写多线程的实现的话，太麻烦了，我们只需要用一个简单的办法，在我们的方法上加一个简单的注解即可，如下： 6、给hello方法添加@Async注解； 12345678910//告诉Spring这是一个异步方法@Asyncpublic void hello()&#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;业务进行中....&quot;);&#125; SpringBoot就会**自己开一个线程池，进行调用！**但是要让这个注解生效，我们还需要在主程序上添加一个注解@EnableAsync ，开启异步注解功能； 123456789@EnableAsync //开启异步注解功能@SpringBootApplicationpublic class SpringbootTaskApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootTaskApplication.class, args); &#125;&#125; 7、重启测试，网页瞬间响应，后台代码依旧执行！ 20.3、定时任务 项目开发中经常需要执行一些定时任务，比如需要在每天凌晨的时候，分析一次前一天的日志信息，Spring为我们提供了异步执行任务调度的方式，提供了两个接口。 TaskExecutor接口 TaskScheduler接口 两个注解： @EnableScheduling（开启定时功能） @Scheduled（什么时候执行） cron表达式： corn从左到右（用空格隔开）：秒 分 小时 月份中的日期 月份 星期中的日期 年份 字段 允许值 允许的特殊字符 秒（Seconds） 0~59的整数 , - * / 四个字符 分（Minutes） 0~59的整数 , - * / 四个字符 小时（Hours） 0~23的整数 , - * / 四个字符 日期（DayofMonth） 1~31的整数（但是你需要考虑你月的天数） ,- * ? / L W C 八个字符 月份（Month） 1~12的整数或者 JAN-DEC , - * / 四个字符 星期（DayofWeek） 1~7的整数或者 SUN-SAT （1=SUN） , - * ? / L C # 八个字符 年(可选，留空)（Year） 1970~2099 , - * / 四个字符 特殊字符 代表含义 , 枚举 在Minutes域使用5,20，则意味着在5和20分每分钟触发一次。 - 表示范围 例如在Minutes域使用5-20，表示从5分到20分钟每分钟触发一次 * 任意 / 表示起始时间开始触发，然后每隔固定时间触发一次， ? 日/星期冲突匹配 只能用在DayofMonth和DayofWeek两个域 L 最后 如果在DayofWeek域使用5L,意味着在最后的一个星期四触发。 W 工作日 C 和calendar联系后计算过的值 # 用于确定每个月第几个星期几，4#2 某月的第二个星期三 测试步骤： 1、创建一个ScheduledService 我们里面存在一个hello方法，他需要定时执行，怎么处理呢？ @Service 12345678910@Servicepublic class ScheduledService &#123; //秒 分 时 日 月 周几 //0 * * * * MON-FRI //注意cron表达式的用法； @Scheduled(cron = &quot;0 * * * * 0-7&quot;) public void hello()&#123; System.out.println(&quot;hello.....&quot;); &#125;&#125; 2、这里写完定时任务之后，我们需要在主程序上增加@EnableScheduling 开启定时任务功能 12345678@EnableAsync //开启异步注解功能@EnableScheduling //开启基于注解的定时任务@SpringBootApplicationpublic class SpringbootTaskApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootTaskApplication.class, args); &#125;&#125; 3、我们来详细了解下cron表达式； http://www.bejson.com/othertools/cron/ 4、常用的表达式 123456789101112131415161718192021222324（1）0&#x2F;2 * * * * ? 表示每2秒 执行任务（1）0 0&#x2F;2 * * * ? 表示每2分钟 执行任务（1）0 0 2 1 * ? 表示在每月的1日的凌晨2点调整任务（2）0 15 10 ? * MON-FRI 表示周一到周五每天上午10:15执行作业（3）0 15 10 ? 6L 2002-2006 表示2002-2006年的每个月的最后一个星期五上午10:15执行作（4）0 0 10,14,16 * * ? 每天上午10点，下午2点，4点（5）0 0&#x2F;30 9-17 * * ? 朝九晚五工作时间内每半小时（6）0 0 12 ? * WED 表示每个星期三中午12点（7）0 0 12 * * ? 每天中午12点触发（8）0 15 10 ? * * 每天上午10:15触发（9）0 15 10 * * ? 每天上午10:15触发（10）0 15 10 * * ? 每天上午10:15触发（11）0 15 10 * * ? 2005 2005年的每天上午10:15触发（12）0 * 14 * * ? 在每天下午2点到下午2:59期间的每1分钟触发（13）0 0&#x2F;5 14 * * ? 在每天下午2点到下午2:55期间的每5分钟触发（14）0 0&#x2F;5 14,18 * * ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发（15）0 0-5 14 * * ? 在每天下午2点到下午2:05期间的每1分钟触发（16）0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发（17）0 15 10 ? * MON-FRI 周一至周五的上午10:15触发（18）0 15 10 15 * ? 每月15日上午10:15触发（19）0 15 10 L * ? 每月最后一日的上午10:15触发（20）0 15 10 ? * 6L 每月的最后一个星期五上午10:15触发（21）0 15 10 ? * 6L 2002-2005 2002年至2005年的每月的最后一个星期五上午10:15触发（22）0 15 10 ? * 6#3 每月的第三个星期五上午10:15触发 20.3、邮件任务 邮件发送，在我们的日常开发中，也非常的多，Springboot也帮我们做了支持 邮件发送需要引入spring-boot-start-mail(导入启动项) SpringBoot 自动配置MailSenderAutoConfiguration 定义MailProperties内容，配置在application.yml中 自动装配JavaMailSender 测试邮件发送 测试： 1、引入pom依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt; 看它引入的依赖，可以看到 jakarta.mail 123456&lt;dependency&gt; &lt;groupId&gt;com.sun.mail&lt;/groupId&gt; &lt;artifactId&gt;jakarta.mail&lt;/artifactId&gt; &lt;version&gt;1.6.4&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; 2、查看自动配置类：MailSenderAutoConfiguration 这个类中存在bean，JavaMailSenderImpl 然后我们去看下配置文件 1234567891011121314@ConfigurationProperties( prefix = &quot;spring.mail&quot;)public class MailProperties &#123; private static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8; private String host; private Integer port; private String username; private String password; private String protocol = &quot;smtp&quot;; private Charset defaultEncoding; private Map&lt;String, String&gt; properties; private String jndiName;&#125; 3、配置文件： 12345spring.mail.username=24736743@qq.comspring.mail.password=你的qq授权码spring.mail.host=smtp.qq.com# qq需要配置sslspring.mail.properties.mail.smtp.ssl.enable=true 获取授权码：在QQ邮箱中的设置-&gt;账户-&gt;开启pop3和smtp服务 4、Spring单元测试 123456789101112131415161718192021222324252627282930313233@AutowiredJavaMailSenderImpl mailSender;@Testpublic void contextLoads() &#123; //邮件设置1：一个简单的邮件 SimpleMailMessage message = new SimpleMailMessage(); message.setSubject(&quot;通知-明天来狂神这听课&quot;); message.setText(&quot;今晚7:30开会&quot;); message.setTo(&quot;24736743@qq.com&quot;); message.setFrom(&quot;24736743@qq.com&quot;); mailSender.send(message);&#125;@Testpublic void contextLoads2() throws MessagingException &#123; //邮件设置2：一个复杂的邮件 MimeMessage mimeMessage = mailSender.createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true); helper.setSubject(&quot;通知-明天来狂神这听课&quot;); helper.setText(&quot;&lt;b style=&#x27;color:red&#x27;&gt;今天 7:30来开会&lt;/b&gt;&quot;,true); //发送附件 helper.addAttachment(&quot;1.jpg&quot;,new File(&quot;&quot;)); helper.addAttachment(&quot;2.jpg&quot;,new File(&quot;&quot;)); helper.setTo(&quot;24736743@qq.com&quot;); helper.setFrom(&quot;24736743@qq.com&quot;); mailSender.send(mimeMessage);&#125; 查看邮箱，邮件接收成功！ 我们只需要使用Thymeleaf进行前后端结合即可开发自己网站邮件收发功能了！ 封装工具类： 1234567891011121314151617181920212223/** * * @param html: 是否开启html * @param subject 邮件标题 * @param text 邮件内容 * @throws Exception */@Testpublic void sendMail(Boolean html, String subject, String text) throws Exception &#123; //邮件设置2：一个复杂的邮件 MimeMessage mimeMessage = mailSender.createMimeMessage(); //组装 MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, html); helper.setSubject(subject); helper.setText(text,true); //可以解析html标签，css //添加文件等 help.addAttachment(&quot;1.jpg&quot;,new File(&quot;&quot;)); helper.setTo(&quot;24736743@qq.com&quot;); helper.setFrom(&quot;24736743@qq.com&quot;); mailSender.send(mimeMessage);&#125; 21、集成Rides（见Redis部分笔记） SpringBoot 操作数据: spring-data jpa jdbc mongodb redis ! SpringData也是和SpringBoot齐名的项目! 说明︰在SpringBoot2.x之后，原来使用的jedis被替换为了lettuce? jedis：采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全的，使用jedis pool连接池！更像BIO模式 lettuce：采用netty，实例可以再多个线程中进行共享，不存在线程不安全的情况!可以减少线程数据了，更像 NIO模式 源码分析 1234567891011121314151617181920public class RedisAutoConfiguration &#123; @Bean @ConditionalOnMissingBean(name = &quot;redisTemplate&quot;) //我们可以自定义一个RedisTemplate 来替换这个默认的 @ConditionalOnSingleCandidate(RedisConnectionFactory.class) public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123; //默认的RedisTemplate 没有过的这只，redis对象都是需要序列化的 // 两个泛型都是 Object, Object 的类型，我们后使用需要强制转换&lt;String, Obkect&gt; RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory); return template; &#125; @Bean @ConditionalOnMissingBean //由于String 是人跌势中最常使用的类型，所以说单独提出来了一个bean @ConditionalOnSingleCandidate(RedisConnectionFactory.class) public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) &#123; StringRedisTemplate template = new StringRedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; &#125;&#125; 测试： 需要安装Redis才可以 导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt; &lt;version&gt;1.4.7.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置连接 123456789101112131415# REDIS (RedisProperties)spring.redis.host=127.0.0.1spring.redis.port=6379# Redis数据库索引（默认为0）spring.redis.database=0# 连接池最大连接数（使用负值表示没有限制）spring.redis.jedis.pool.max-active=8# 连接池最大阻塞等待时间（使用负值表示没有限制）spring.redis.jedis.pool.max-wait=-1# 连接池中的最大空闲连接spring.redis.jedis.pool.max-idle=8# 连接池中的最小空闲连接spring.redis.jedis.pool.min-idle=0# 连接超时时间（毫秒）spring.redis.timeout=5000 测试！ 21.2、自定义Redis Template 22、Dubbo和Zookeeper集成 22.1、什么是分布式系统？ 在《分布式系统原理与范型》一书中有如下定义：“分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统”； 分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。其目的是利用更多的机器，处理更多的数据。 代理服务器横向扩展 分布式系统（distributed system）是建立在网络之上的软件系统。 首先需要明确的是，只有当单个节点的处理能力无法满足日益增长的计算、存储任务的时候，且硬件的提升（加内存、加磁盘、使用更好的CPU）高昂到得不偿失的时候，应用程序也不能进一步优化的时候，我们才需要考虑分布式系统。因为，分布式系统要解决的问题本身就是和单机系统一样的，而由于分布式系统多节点、通过网络通信的拓扑结构，会引入很多单机系统没有的问题，为了解决这些问题又会引入更多的机制、协议，带来更多的问题。。。 22.2、Dubbo文档 随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，急需一个治理系统确保架构有条不紊的演进。 在Dubbo的官网文档有这样一张图 单机器-&gt;MVC-&gt;远程功能调用-&gt;上云 单一应用架构 当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。 适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。 缺点： 1、性能扩展比较难 2、协同开发问题 3、不利于升级维护 垂直应用架构 当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。 通过切分业务来实现各个模块独立部署，降低了维护和部署的难度，团队各司其职更易管理，性能扩展也更方便，更有针对性。 缺点：公用模块无法重复利用，开发性的浪费 分布式服务架构 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的**分布式服务框架(RPC)**是关键。 流动计算架构 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)[ Service Oriented Architecture]是关键。 什么是RPC RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。 也就是说两台服务器A，B，**一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，**由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据(网络不可靠)。为什么要用RPC呢？就是无法在一个进程内，甚至一个计算机内通过本地调用的方式完成的需求，比如不同的系统间的通讯，甚至不同的组织间的通讯，由于计算能力需要横向扩展，需要在多台机器组成的集群上部署应用。RPC就是要像调用本地的函数一样去调远程函数； 推荐阅读文章：https://www.jianshu.com/p/2accc2840a1b RPC基本原理 步骤解析： RPC两个核心模块：通讯（传输），序列化。 测试环境搭建 22.3、Dubbo Apache Dubbo |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。 dubbo官网 https://dubbo.gitbooks.io/dubbo-user-book/content/quick-start.html 1.了解Dubbo的特性 2.查看官方文档 dubbo基本概念 服务提供者（Provider）：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者（Consumer）：调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 注册中心（Registry）：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者 监控中心（Monitor）：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心 调用关系说明 l 服务容器负责启动，加载，运行服务提供者。 l 服务提供者在启动时，向注册中心注册自己提供的服务。 l 服务消费者在启动时，向注册中心订阅自己所需的服务。 l 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 l 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 l 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 22.4、Dubbo环境搭建 点进dubbo官方文档，推荐我们使用Zookeeper 注册中心 什么是zookeeper呢？（动物的管理者）可以查看官方文档 Window下安装zookeeper-2181 1、下载zookeeper ：地址， 我们下载3.4.14 ， 最新版！解压zookeeper 2、运行/bin/zkServer.cmd ，初次运行会报错，没有zoo.cfg配置文件； 可能遇到问题：闪退 ! 解决方案：编辑zkServer.cmd文件末尾添加pause 。这样运行出错就不会退出，会提示错误信息，方便找到原因。 3、修改zoo.cfg配置文件 将conf文件夹下面的zoo_sample.cfg复制一份改名为zoo.cfg即可。 注意几个重要位置： dataDir=./ 临时数据存储的目录（可写相对路径） clientPort=2181 zookeeper的端口号 修改完成后再次启动zookeeper 4、使用zkCli.cmd测试（都要求管理员权限开启服务） ls /：列出zookeeper根下保存的所有节点 12[zk: 127.0.0.1:2181(CONNECTED) 4] ls /[zookeeper] create –e /kuangshen 123：创建一个kuangshen节点，值为123 get /kuangshen：获取/kuangshen节点的值 我们再来查看一下节点 window下安装dubbo-admin-7001 dubbo本身并不是一个服务软件。它其实就是一个jar包是一个监控管理后台，能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。 但是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序dubbo-admin，不过这个监控即使不装也不影响使用。 我们这里来安装一下： 1、下载dubbo-admin 地址 ：https://github.com/apache/dubbo-admin/tree/master 2、解压进入目录 修改 dubbo-admin\\src\\main\\resources \\application.properties 指定zookeeper地址 12345678910server.port=7001spring.velocity.cache=falsespring.velocity.charset=UTF-8spring.velocity.layout-url=/templates/default.vmspring.messages.fallback-to-system-locale=falsespring.messages.basename=i18n/messagespring.root.password=rootspring.guest.password=guest#注册中心的地址dubbo.registry.address=zookeeper://127.0.0.1:2181 3、在项目目录下打包dubbo-admin 变成dubbo-admin\\target 下的dubbo-admin-0.0.1-SNAPSHOT.jar 1mvn clean package -Dmaven.test.skip&#x3D;true 第一次打包的过程有点慢，需要耐心等待！直到成功！ 4、执行 dubbo-admin\\target 下的dubbo-admin-0.0.1-SNAPSHOT.jar 1java -jar dubbo-admin-0.0.1-SNAPSHOT.jar 【注意：zookeeper的服务一定要打开！】 执行完毕，我们去访问一下 http://localhost:7001/ ， 这时候我们需要输入登录账户和密码，我们都是默认的root-root； 登录成功后，查看界面 安装完成！ 22.5、SpringBoot + Dubbo + zookeeper 框架搭建 1. 启动zookeeper ！ 2. IDEA创建一个空项目； 3.创建一个模块，实现服务提供者：provider-server ， 选择web依赖即可 4.项目创建完毕，我们写一个服务，比如卖票的服务； 编写接口 12345package com.kuang.provider.service;public interface TicketService &#123; public String getTicket();&#125; 编写实现类 12345678package com.kuang.provider.service;public class TicketServiceImpl implements TicketService &#123; @Override public String getTicket() &#123; return &quot;《狂神说Java》&quot;; &#125;&#125; 5.创建一个模块，实现服务消费者：consumer-server ， 选择web依赖即可 6.项目创建完毕，我们写一个服务，比如用户的服务； 编写service 12345package com.kuang.consumer.service;public class UserService &#123; //我们需要去拿去注册中心的服务&#125; 需求：现在我们的用户想使用买票的服务，这要怎么弄呢 ？ 22.6、服务提供者 1、将服务提供者注册到注册中心，我们需要整合Dubbo和zookeeper，所以需要导包 我们从dubbo官网进入github，看下方的帮助文档，找到dubbo-springboot，找到依赖包 123456&lt;!-- Dubbo Spring Boot Starter --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt;&lt;/dependency&gt; zookeeper的包我们去maven仓库下载，zkclient； 123456&lt;!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt;&lt;/dependency&gt; 【新版的坑】zookeeper及其依赖包，解决日志冲突，还需要剔除日志依赖； 1234567891011121314151617181920212223&lt;!-- 引入zookeeper --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.14&lt;/version&gt; &lt;!--排除这个slf4j-log4j12--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 2、在springboot配置文件中配置dubbo相关属性！ 123456#当前应用名字dubbo.application.name=provider-server#注册中心地址dubbo.registry.address=zookeeper://127.0.0.1:2181#扫描指定包下服务dubbo.scan.base-packages=com.kuang.provider.service 3、在service的实现类中配置服务注解，发布服务！注意导包问题 1234567891011import org.apache.dubbo.config.annotation.Service;import org.springframework.stereotype.Component;@Service //将服务发布出去@Component //放在容器中public class TicketServiceImpl implements TicketService &#123; @Override public String getTicket() &#123; return &quot;《狂神说Java》&quot;; &#125;&#125; 逻辑理解 ：应用启动起来，dubbo就会扫描指定的包下带有@component注解的服务，将它发布在指定的注册中心中！ 22.7、服务消费者 1、导入依赖，和之前的依赖一样； 12345678910111213141516171819202122232425262728293031323334353637&lt;!--dubbo--&gt;&lt;!-- Dubbo Spring Boot Starter --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt;&lt;/dependency&gt;&lt;!--zookeeper--&gt;&lt;!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 引入zookeeper --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.14&lt;/version&gt; &lt;!--排除这个slf4j-log4j12--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 2、配置参数 1234#当前应用名字dubbo.application.name=consumer-server#注册中心地址dubbo.registry.address=zookeeper://127.0.0.1:2181 3. 本来正常步骤是需要将服务提供者的接口打包，然后用pom文件导入，我们这里使用简单的方式，直接将服务的接口拿过来，路径必须保证正确，即和服务提供者相同； providerTicker的 4. 完善消费者的服务类 123456789101112131415161718package com.kuang.consumer.service;import com.kuang.provider.service.TicketService;import org.apache.dubbo.config.annotation.Reference;import org.springframework.stereotype.Service;@Service //注入到容器中public class UserService &#123; @Reference //远程引用指定的服务，他会按照全类名进行匹配，看谁给注册中心注册了这个全类名 TicketService ticketService; public void bugTicket()&#123; String ticket = ticketService.getTicket(); System.out.println(&quot;在注册中心买到&quot;+ticket); &#125;&#125; 5. 测试类编写； 1234567891011@RunWith(SpringRunner.class)@SpringBootTestpublic class ConsumerServerApplicationTests &#123; @Autowired UserService userService; @Test public void contextLoads() &#123; userService.bugTicket(); &#125;&#125; 22.8、启动测试 1. 开启zookeeper 2. 打开dubbo-admin实现监控【可以不用做】 3. 开启服务者 导入依赖 配置注册中心地址，以及服务发现名和要扫描的包 在想要被注册的服务商加注解@Service 4. 消费者消费测试，结果： 导入依赖 配置注册中心地址 从远程注入服务@Reference简单的要求路径相同 监控中心 ： ok , 这就是SpingBoot + dubbo + zookeeper实现分布式开发的应用，其实就是一个服务拆分的思想； 23、富文本编辑器 23.1、简介 思考：我们平时在博客园，或者CSDN等平台进行写作的时候，有同学思考过他们的编辑器是怎么实现的吗？ 在博客园后台的选项设置中，可以看到一个文本编辑器的选项： 其实这个就是富文本编辑器，市面上有许多非常成熟的富文本编辑器，比如： Editor.md——功能非常丰富的编辑器，左端编辑，右端预览，非常方便，完全免费 官网：https://pandao.github.io/editor.md/ wangEditor——基于javascript和css开发的 Web富文本编辑器， 轻量、简洁、界面美观、易用、开源免费。 官网：http://www.wangeditor.com/ TinyMCE——TinyMCE是一个轻量级的基于浏览器的所见即所得编辑器，由JavaScript写成。它对IE6+和Firefox1.5+都有着非常良好的支持。功能齐全，界面美观，就是文档是英文的，对开发人员英文水平有一定要求。 官网：https://www.tiny.cloud/docs/demo/full-featured/ 博客园 百度ueditor——UEditor是由百度web前端研发部开发所见即所得富文本web编辑器，具有轻量，功能齐全，可定制，注重用户体验等特点，开源基于MIT协议，允许自由使用和修改代码，缺点是已经没有更新了 官网：https://ueditor.baidu.com/website/onlinedemo.html kindeditor——界面经典。 官网：http://kindeditor.net/demo.php Textbox——Textbox是一款极简但功能强大的在线文本编辑器，支持桌面设备和移动设备。主要功能包含内置的图像处理和存储、文件拖放、拼写检查和自动更正。此外，该工具还实现了屏幕阅读器等辅助技术，并符合WAI-ARIA可访问性标准。 官网：https://textbox.io/ CKEditor——国外的，界面美观。 官网：https://ckeditor.com/ckeditor-5/demo/ quill——功能强大，还可以编辑公式等 官网：https://quilljs.com/ simditor——界面美观，功能较全。 官网：https://simditor.tower.im/ summernote——UI好看，精美 官网：https://summernote.org/ jodit——功能齐全 官网：https://xdsoft.net/jodit/ froala Editor——界面非常好看，功能非常强大，非常好用（非免费） 官网：https://www.froala.com/wysiwyg-editor 总之，目前可用的富文本编辑器有很多…这只是其中的一部分 23.2、Editor.md 我这里使用的就是Editor.md，作为一个资深码农，Mardown必然是我们程序猿最喜欢的格式，看下面，就爱上了！ 我们可以在官网下载它：https://pandao.github.io/editor.md/ ， 得到它的压缩包！ 解压以后，在examples目录下面，可以看到他的很多案例使用！学习，其实就是看人家怎么写的，然后进行模仿就好了！ 我们可以将整个解压的文件倒入我们的项目，将一些无用的测试和案例删掉即可！ 23.3、基础工程搭建 数据库设计 article：文章表 字段 备注 id int 文章的唯一ID author varchar 作者 title varchar 标题 content longtext 文章的内容 建表SQL： 1234567CREATE TABLE `article` (`id` int(10) NOT NULL AUTO_INCREMENT COMMENT &#x27;int文章的唯一ID&#x27;,`author` varchar(50) NOT NULL COMMENT &#x27;作者&#x27;,`title` varchar(100) NOT NULL COMMENT &#x27;标题&#x27;,`content` longtext NOT NULL COMMENT &#x27;文章的内容&#x27;,PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 基础项目搭建 1、建一个SpringBoot项目配置 12345678910111213141516spring:datasource: username: root password: 123456 #?serverTimezone=UTC解决时区的报错 url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Driver&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt;&lt;/resources&gt; 2、实体类： 123456789101112//文章类@Data@NoArgsConstructor@AllArgsConstructorpublic class Article implements Serializable &#123; private int id; //文章的唯一ID private String author; //作者名 private String title; //标题 private String content; //文章的内容&#125; 3、mapper接口： 12345678910111213141516171819202122232425262728293031323334353637383940@Mapper@Repositorypublic interface ArticleMapper &#123; //查询所有的文章 List&lt;Article&gt; queryArticles(); //新增一个文章 int addArticle(Article article); //根据文章id查询文章 Article getArticleById(int id); //根据文章id删除文章 int deleteArticleById(int id);&#125;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.kuang.mapper.ArticleMapper&quot;&gt; &lt;select id=&quot;queryArticles&quot; resultType=&quot;Article&quot;&gt; select * from article &lt;/select&gt; &lt;select id=&quot;getArticleById&quot; resultType=&quot;Article&quot;&gt; select * from article where id = #&#123;id&#125; &lt;/select&gt; &lt;insert id=&quot;addArticle&quot; parameterType=&quot;Article&quot;&gt; insert into article (author,title,content) values (#&#123;author&#125;,#&#123;title&#125;,#&#123;content&#125;); &lt;/insert&gt; &lt;delete id=&quot;deleteArticleById&quot; parameterType=&quot;int&quot;&gt; delete from article where id = #&#123;id&#125; &lt;/delete&gt; &lt;/mapper&gt;123456789101112131415161718192021222324252627282930313233343536373839 既然已经提供了 myBatis 的映射配置文件，自然要告诉 spring boot 这些文件的位置 1234mybatis:mapper-locations: classpath:com/kuang/mapper/*.xmltype-aliases-package: com.kuang.pojo123 编写一个Controller测试下，是否ok； 23.4、文章编辑整合（重点） 1、导入 editor.md 资源 ，删除多余文件 2、编辑文章页面 editor.html、需要引入 jQuery； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;!DOCTYPE html&gt;&lt;html class=&quot;x-admin-sm&quot; lang=&quot;zh&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;秦疆&#x27;Blog&lt;/title&gt; &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,user-scalable=yes, minimum-scale=0.4, initial-scale=0.8,target-densitydpi=low-dpi&quot; /&gt; &lt;!--Editor.md--&gt; &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/editormd/css/editormd.css&#125;&quot;/&gt; &lt;link rel=&quot;shortcut icon&quot; href=&quot;https://pandao.github.io/editor.md/favicon.ico&quot; type=&quot;image/x-icon&quot; /&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;layui-fluid&quot;&gt; &lt;div class=&quot;layui-row layui-col-space15&quot;&gt; &lt;div class=&quot;layui-col-md12&quot;&gt; &lt;!--博客表单--&gt; &lt;form name=&quot;mdEditorForm&quot;&gt; &lt;div&gt; 标题：&lt;input type=&quot;text&quot; name=&quot;title&quot;&gt; &lt;/div&gt; &lt;div&gt; 作者：&lt;input type=&quot;text&quot; name=&quot;author&quot;&gt; &lt;/div&gt; &lt;div id=&quot;article-content&quot;&gt; &lt;textarea name=&quot;content&quot; id=&quot;content&quot; style=&quot;display:none;&quot;&gt; &lt;/textarea&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;!--editormd--&gt;&lt;script th:src=&quot;@&#123;/editormd/lib/jquery.min.js&#125;&quot;&gt;&lt;/script&gt;&lt;script th:src=&quot;@&#123;/editormd/editormd.js&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var testEditor; //window.onload = function()&#123; &#125; $(function() &#123; testEditor = editormd(&quot;article-content&quot;, &#123; width : &quot;95%&quot;, height : 400, syncScrolling : &quot;single&quot;, path : &quot;../editormd/lib/&quot;, saveHTMLToTextarea : true, // 保存 HTML 到 Textarea emoji: true, theme: &quot;dark&quot;,//工具栏主题 previewTheme: &quot;dark&quot;,//预览主题 editorTheme: &quot;pastel-on-dark&quot;,//编辑主题 tex : true, // 开启科学公式TeX语言支持，默认关闭 flowChart : true, // 开启流程图支持，默认关闭 sequenceDiagram : true, // 开启时序/序列图支持，默认关闭, //图片上传 imageUpload : true, imageFormats : [&quot;jpg&quot;, &quot;jpeg&quot;, &quot;gif&quot;, &quot;png&quot;, &quot;bmp&quot;, &quot;webp&quot;], imageUploadURL : &quot;/article/file/upload&quot;, onload : function() &#123; console.log(&#x27;onload&#x27;, this); &#125;, /*指定需要显示的功能按钮*/ toolbarIcons : function() &#123; return [&quot;undo&quot;,&quot;redo&quot;,&quot;|&quot;, &quot;bold&quot;,&quot;del&quot;,&quot;italic&quot;,&quot;quote&quot;,&quot;ucwords&quot;,&quot;uppercase&quot;,&quot;lowercase&quot;,&quot;|&quot;, &quot;h1&quot;,&quot;h2&quot;,&quot;h3&quot;,&quot;h4&quot;,&quot;h5&quot;,&quot;h6&quot;,&quot;|&quot;, &quot;list-ul&quot;,&quot;list-ol&quot;,&quot;hr&quot;,&quot;|&quot;, &quot;link&quot;,&quot;reference-link&quot;,&quot;image&quot;,&quot;code&quot;,&quot;preformatted-text&quot;, &quot;code-block&quot;,&quot;table&quot;,&quot;datetime&quot;,&quot;emoji&quot;,&quot;html-entities&quot;,&quot;pagebreak&quot;,&quot;|&quot;, &quot;goto-line&quot;,&quot;watch&quot;,&quot;preview&quot;,&quot;fullscreen&quot;,&quot;clear&quot;,&quot;search&quot;,&quot;|&quot;, &quot;help&quot;,&quot;info&quot;,&quot;releaseIcon&quot;, &quot;index&quot;] &#125;, /*自定义功能按钮，下面我自定义了2个，一个是发布，一个是返回首页*/ toolbarIconTexts : &#123; releaseIcon : &quot;&lt;span bgcolor=\\&quot;gray\\&quot;&gt;发布&lt;/span&gt;&quot;, index : &quot;&lt;span bgcolor=\\&quot;red\\&quot;&gt;返回首页&lt;/span&gt;&quot;, &#125;, /*给自定义按钮指定回调函数*/ toolbarHandlers:&#123; releaseIcon : function(cm, icon, cursor, selection) &#123; //表单提交 mdEditorForm.method = &quot;post&quot;; mdEditorForm.action = &quot;/article/addArticle&quot;;//提交至服务器的路径 mdEditorForm.submit(); &#125;, index : function()&#123; window.location.href = &#x27;/&#x27;; &#125;, &#125; &#125;); &#125;);&lt;/script&gt;&lt;/html&gt; 3、编写Controller，进行跳转，以及保存文章 1234567891011121314151617@Controller@RequestMapping(&quot;/article&quot;)public class ArticleController &#123; @GetMapping(&quot;/toEditor&quot;) public String toEditor()&#123; return &quot;editor&quot;; &#125; @PostMapping(&quot;/addArticle&quot;) public String addArticle(Article article)&#123; articleMapper.addArticle(article); return &quot;editor&quot;; &#125; &#125;12345678910111213141516 图片上传问题 1、前端js中添加配置 12345//图片上传imageUpload : true,imageFormats : [&quot;jpg&quot;, &quot;jpeg&quot;, &quot;gif&quot;, &quot;png&quot;, &quot;bmp&quot;, &quot;webp&quot;],imageUploadURL : &quot;/article/file/upload&quot;, // //这个是上传图片时的访问地址1234 2、后端请求，接收保存这个图片, 需要导入 FastJson 的依赖！ 1234567891011121314151617181920212223242526272829303132333435//博客图片上传问题@RequestMapping(&quot;/file/upload&quot;)@ResponseBodypublic JSONObject fileUpload(@RequestParam(value = &quot;editormd-image-file&quot;, required = true) MultipartFile file, HttpServletRequest request) throws IOException &#123; //上传路径保存设置 //获得SpringBoot当前项目的路径：System.getProperty(&quot;user.dir&quot;) String path = System.getProperty(&quot;user.dir&quot;)+&quot;/upload/&quot;; //按照月份进行分类： Calendar instance = Calendar.getInstance(); String month = (instance.get(Calendar.MONTH) + 1)+&quot;月&quot;; path = path+month; File realPath = new File(path); if (!realPath.exists())&#123; realPath.mkdir(); &#125; //上传文件地址 System.out.println(&quot;上传文件保存地址：&quot;+realPath); //解决文件名字问题：我们使用uuid; String filename = &quot;ks-&quot;+UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;); //通过CommonsMultipartFile的方法直接写文件（注意这个时候） file.transferTo(new File(realPath +&quot;/&quot;+ filename)); //给editormd进行回调 JSONObject res = new JSONObject(); res.put(&quot;url&quot;,&quot;/upload/&quot;+month+&quot;/&quot;+ filename); res.put(&quot;success&quot;, 1); res.put(&quot;message&quot;, &quot;upload success!&quot;); return res;&#125; 3、解决文件回显显示的问题，设置虚拟目录映射！在我们自己拓展的MvcConfig中进行配置即可！ 12345678910111213@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123; // 文件保存在真实目录/upload/下， // 访问的时候使用虚路径/upload，比如文件名为1.png，就直接/upload/1.png就ok了。 @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(&quot;/upload/**&quot;) .addResourceLocations(&quot;file:&quot;+System.getProperty(&quot;user.dir&quot;)+&quot;/upload/&quot;); &#125;&#125;123456789101112 表情包问题 自己手动下载，emoji 表情包，放到图片路径下： 修改editormd.js文件 12345// Emoji graphics files url patheditormd.emoji = &#123; path : &quot;../editormd/plugins/emoji-dialog/emoji/&quot;, ext : &quot;.png&quot;&#125;; 23.5、文章展示 1、Controller 中增加方法 123456@GetMapping(&quot;/&#123;id&#125;&quot;)public String show(@PathVariable(&quot;id&quot;) int id,Model model)&#123; Article article = articleMapper.getArticleById(id); model.addAttribute(&quot;article&quot;,article); return &quot;article&quot;;&#125; 2、编写页面 article.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt; &lt;title th:text=&quot;$&#123;article.title&#125;&quot;&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;!--文章头部信息：标题，作者，最后更新日期，导航--&gt; &lt;h2 style=&quot;margin: auto 0&quot; th:text=&quot;$&#123;article.title&#125;&quot;&gt;&lt;/h2&gt; 作者：&lt;span style=&quot;float: left&quot; th:text=&quot;$&#123;article.author&#125;&quot;&gt;&lt;/span&gt; &lt;!--文章主体内容--&gt; &lt;div id=&quot;doc-content&quot;&gt; &lt;textarea style=&quot;display:none;&quot; placeholder=&quot;markdown&quot; th:text=&quot;$&#123;article.content&#125;&quot;&gt;&lt;/textarea&gt; &lt;/div&gt;&lt;/div&gt;&lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/editormd/css/editormd.preview.css&#125;&quot; /&gt;&lt;script th:src=&quot;@&#123;/editormd/lib/jquery.min.js&#125;&quot;&gt;&lt;/script&gt;&lt;script th:src=&quot;@&#123;/editormd/lib/marked.min.js&#125;&quot;&gt;&lt;/script&gt;&lt;script th:src=&quot;@&#123;/editormd/lib/prettify.min.js&#125;&quot;&gt;&lt;/script&gt;&lt;script th:src=&quot;@&#123;/editormd/lib/raphael.min.js&#125;&quot;&gt;&lt;/script&gt;&lt;script th:src=&quot;@&#123;/editormd/lib/underscore.min.js&#125;&quot;&gt;&lt;/script&gt;&lt;script th:src=&quot;@&#123;/editormd/lib/sequence-diagram.min.js&#125;&quot;&gt;&lt;/script&gt;&lt;script th:src=&quot;@&#123;/editormd/lib/flowchart.min.js&#125;&quot;&gt;&lt;/script&gt;&lt;script th:src=&quot;@&#123;/editormd/lib/jquery.flowchart.min.js&#125;&quot;&gt;&lt;/script&gt;&lt;script th:src=&quot;@&#123;/editormd/editormd.js&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var testEditor; $(function () &#123; testEditor = editormd.markdownToHTML(&quot;doc-content&quot;, &#123;//注意：这里是上面DIV的id htmlDecode: &quot;style,script,iframe&quot;, emoji: true, taskList: true, tocm: true, tex: true, // 默认不解析 flowChart: true, // 默认不解析 sequenceDiagram: true, // 默认不解析 codeFold: true &#125;);&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 重启项目，访问进行测试！大功告成！ 小结： 有了富文本编辑器，我们网站的功能就会又多一项，大家到了这里完全可以有时间写一个属于自己的博客网站了，根据所学的知识是完全没有任何问题的！ 24.Spring Boot中通过CORS解决跨域问题 今天和小伙伴们来聊一聊通过CORS解决跨域问题。 同源策略 很多人对跨域有一种误解，以为这是前端的事，和后端没关系，其实不是这样的，说到跨域，就不得不说说浏览器的同源策略。 同源策略是由Netscape提出的一个著名的安全策略，它是浏览器最核心也最基本的安全功能，现在所有支持JavaScript的浏览器都会使用这个策略。所谓同源是指协议、域名以及端口要相同。同源策略是基于安全方面的考虑提出来的，这个策略本身没问题，但是我们在实际开发中，由于各种原因又经常有跨域的需求，传统的跨域方案是JSONP(前端)，JSONP虽然能解决跨域但是有一个很大的局限性，那就是只支持GET请求，不支持其他类型的请求，而今天我们说的CORS（跨域源资源共享）（CORS，Cross-origin resource sharing）是一个W3C标准，它是一份浏览器技术的规范，提供了Web服务从不同网域传来沙盒脚本的方法，以避开浏览器的同源策略，这是JSONP模式的现代版。 在Spring框架中，对于CORS也提供了相应的解决方案，今天我们就来看看SpringBoot中如何实现CORS。 实践 接下来我们就来看看Spring Boot中如何实现这个东西。 首先创建两个普通的SpringBoot项目，这个就不用我多说，第一个命名为provider提供服务，第二个命名为consumer消费服务，第一个配置端口为8080，第二个配置配置为8081，然后在provider上提供两个hello接口，一个get，一个post，如下： 1234567891011@RestControllerpublic class HelloController &#123; @GetMapping(&quot;/hello&quot;) public String hello() &#123; return &quot;hello&quot;; &#125; @PostMapping(&quot;/hello&quot;) public String hello2() &#123; return &quot;post hello&quot;; &#125;&#125; 在consumer的resources/static目录下创建一个html文件，发送一个简单的ajax请求，如下： 12345678910111213141516&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;input type=&quot;button&quot; onclick=&quot;btnClick()&quot; value=&quot;get_button&quot;&gt;&lt;input type=&quot;button&quot; onclick=&quot;btnClick2()&quot; value=&quot;post_button&quot;&gt;&lt;script&gt; function btnClick() &#123; $.get(&#x27;http://localhost:8080/hello&#x27;, function (msg) &#123; $(&quot;#app&quot;).html(msg); &#125;); &#125; function btnClick2() &#123; $.post(&#x27;http://localhost:8080/doput&#x27;, function (msg) &#123; $(&quot;#app&quot;).html(msg); &#125;); &#125;&lt;/script&gt; 然后分别启动两个项目，发送请求按钮，观察浏览器控制台如下： 1Access to XMLHttpRequest at &#39;http:&#x2F;&#x2F;localhost:8080&#x2F;hello&#39; from origin &#39;http:&#x2F;&#x2F;localhost:8081&#39; has been blocked by CORS policy: No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource. 可以看到，由于同源策略的限制，请求无法发送成功。没有请求头 使用CORS可以在前端代码不做任何修改的情况下，实现跨域，那么接下来看看在provider中如何配置。首先可以通过@CrossOrigin注解配置某一个方法接受某一个域的请求，如下： 1234567891011121314@RestControllerpublic class HelloController &#123; @CrossOrigin(value = &quot;http://localhost:8081&quot;) //愿意接受请求 @GetMapping(&quot;/hello&quot;) public String hello() &#123; return &quot;hello&quot;; &#125; @CrossOrigin(value = &quot;http://localhost:8081&quot;) @PostMapping(&quot;/hello&quot;) public String hello2() &#123; return &quot;post hello&quot;; &#125;&#125; 这个注解表示这两个接口接受来自http://localhost:8081地址的请求，配置完成后，重启provider，再次发送请求，浏览器控制台就不会报错了，consumer也能拿到数据了。 此时观察浏览器请求网络控制台，可以看到响应头中多了如下信息： 这个表示服务端愿意接收来自http://localhost:8081的请求，拿到这个信息后，浏览器就不会再去限制本次请求的跨域了。 provider上，每一个方法上都去加注解未免太麻烦了，在Spring Boot中，还可以通过全局配置一次性解决这个问题，全局配置只需要在配置类中重写addCorsMappings方法即可，如下： 12345678910@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/**&quot;) //允许所有接口跨域 .allowedOrigins(&quot;http://localhost:8081&quot;) .allowedMethods(&quot;*&quot;) //允许通过的方法 .allowedHeaders(&quot;*&quot;);//允许通过的请求头 &#125;&#125; /**表示本应用的所有方法都会去处理跨域请求，allowedMethods表示允许通过的请求数，allowedHeaders则表示允许的请求头。经过这样的配置之后，就不必在每个方法上单独配置跨域了。 之后请求会向浏览器发送两次，第一次为探测请求 存在的问题 了解了整个CORS的工作过程之后，我们通过Ajax发送跨域请求，虽然用户体验提高了，但是也有潜在的威胁存在，常见的就是CSRF（Cross-site request forgery）跨站请求伪造。跨站请求伪造也被称为one-click attack 或者 session riding，通常缩写为CSRF或者XSRF，是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法，举个例子： 假如一家银行用以运行转账操作的URL地址如下：http://icbc.com/aa?bb=cc，那么，一个恶意攻击者可以在另一个网站上放置如下代码：&lt;img src=&quot;http://icbc.com/aa?bb=cc&quot;&gt;，如果用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会遭受损失。 基于此，浏览器在实际操作中，会对请求进行分类，分为简单请求，预先请求，带凭证的请求等，预先请求会首先发送一个options探测请求，和浏览器进行协商是否接受请求。默认情况下跨域请求是不需要凭证的，但是服务端可以配置要求客户端提供凭证，这样就可以有效避免csrf攻击。 好了，这个问题就说这么多。","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"后端学习","slug":"后端学习","permalink":"http://example.com/tags/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"狂神说Springboot1","slug":"狂神说Springboot1","date":"2021-04-01T02:58:10.000Z","updated":"2021-04-02T07:23:55.305Z","comments":true,"path":"2021/04/01/狂神说Springboot1/","link":"","permalink":"http://example.com/2021/04/01/%E7%8B%82%E7%A5%9E%E8%AF%B4Springboot1/","excerpt":"","text":"SpringBoot 1、 SpringBoot简介 1.1、回顾什么是Spring Spring是一个开源框架，2003 年兴起的一个轻量级的Java 开发框架，作者：Rod Johnson 。 Spring是为了解决企业级应用开发的复杂性而创建的，简化开发。 1.2、Spring是如何简化Java开发的 为了降低Java开发的复杂性，Spring采用了以下4种关键策略： 1、基于POJO的轻量级和最小侵入性编程，所有东西都是bean； 2、通过IOC，依赖注入（DI）和面向接口实现松耦合； 3、基于切面（AOP）和惯例进行声明式编程； 4、通过切面和模版减少样式代码，RedisTemplate，xxxTemplate； 1.3、什么是SpringBoot 学过javaweb的同学就知道，开发一个web应用，从最初开始接触Servlet结合Tomcat, 跑出一个Hello Wolrld程序，是要经历特别多的步骤；后来就用了框架Struts，再后来是SpringMVC，到了现在的SpringBoot，过一两年又会有其他web框架出现；你们有经历过框架不断的演进，然后自己开发项目所有的技术也在不断的变化、改造吗？建议都可以去经历一遍； 言归正传，什么是SpringBoot呢，就是一个javaweb的开发框架，和SpringMVC类似，对比其他javaweb框架的好处，官方说是简化开发，约定大于配置， you can “just run”，能迅速的开发web应用，几行代码开发一个http接口。 所有的技术框架的发展似乎都遵循了一条主线规律：从一个复杂应用场景 衍生 一种规范框架，人们只需要进行各种配置而不需要自己去实现它，这时候强大的配置功能成了优点；发展到一定程度之后，人们根据实际生产应用情况，选取其中实用功能和设计精华，重构出一些轻量级的框架；之后为了提高开发效率，嫌弃原先的各类配置过于麻烦，于是开始提倡“约定大于配置”，进而衍生出一些一站式的解决方案。 是的这就是Java企业级应用-&gt;J2EE-&gt;spring-&gt;springboot的过程。 随着 Spring 不断的发展，涉及的领域越来越多，项目整合开发需要配合各种各样的文件，慢慢变得不那么易用简单，违背了最初的理念，甚至人称配置地狱。Spring Boot 正是在这样的一个背景下被抽象出来的开发框架，目的为了让大家更容易的使用 Spring 、更容易的集成各种常用的中间件、开源软件； Spring Boot 基于 Spring 开发，Spring Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以约定大于配置的核心思想，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用。 简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架 。 Spring Boot 出生名门，从一开始就站在一个比较高的起点，又经过这几年的发展，生态足够完善，Spring Boot 已经当之无愧成为 Java 领域最热门的技术。 Spring Boot的主要优点： 为所有Spring开发者更快的入门 开箱即用，提供各种默认配置来简化项目配置 内嵌式容器简化Web项目 没有冗余代码生成和XML配置的要求 真的很爽，我们快速去体验开发个接口的感觉吧！ 官方文档： https://spring.io/projects/spring-boot 中文文档： https://www.springcloud.cc/spring-boot.html 2、微服务介绍 2.1、什么是微服务 随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。 微服务是一种架构风格，他要求我们在开发一个应用的时候，这个应用必须构建成一系列小服务的组合；可以通过http的方式进行互通。要说微服务架构，先得说说过去的单体应用架构。 单一应用架构 所谓单体应用架构（all in one）是指，我们将一个应用的中的所有应用服务都封装在一个应用中。 无论是ERP.CRM或是其他什么系统，你都把数据库访问,web访问，等等各个功能放到一个war包内。 这样做的好处是，易于开发和测试；也十分方便部署；当需要扩展时，只需要将war复制多份，然后放到多个服务器上，再做个负载均衡就可以了。 单体应用架构的缺点是，哪怕我要修改一个非常小的地方，我都需要停掉整个服务，重新打包、部署这个应用war包。特别是对于一个大型应用，我们不可能吧所有内容都放在一个应用里面，我们如何维护、如何分工合作都是问题。 垂直应用架构 当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，提升效率的方法之一是将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。 分布式服务架构 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。 流动计算架构 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。 微服务架构 all in one的架构方式，我们把所有的功能单元放在一个应用里面。然后我们把整个应用部署到服务器上。如果负载能力不行，我们将整个应用进行水平复制，进行扩展，然后在负载均衡。 所谓微服务架构，就是打破之前all in one的架构方式，把每个功能元素独立出来。把独立出来的功能元素的动态组合，需要的功能元素才去拿来组合。需要多一些时可以整合多个功能元素。所以微服务架构是对功能元素进行复制,而没有对整个应用进行复制。 这样做的好处是： 节省了调用资源 每个功能元素的服务都度是一个可替换的、可独立升级的软件代码。 Martin Flower于 2014年 3月25日写的《Microservices》，详细的阐述了什么是微服务。 原文地址: https://www.martinfowler.com/articles/microservices.html 翻译: https://www.cnblogs.com/liuning8023/p/4493156.html 2.2、如何构建微服务 一个大型系统的微服务架构，就像一个复杂交织的神经网络，每一个神经元就是一个功能元素，它们各自完成自己的功能，然后通过http相互请求调用。比如一个电商系统，查缓存、连数据库、浏览页面、结账、支付等服务都是一个个独立的功能服务，都被微化了，它们作为一个个微服务共同构建了一个庞大的系统。如果修改其中的一个功能，只需要更新升级其中一个功能服务单元即可。 但是这种庞大的系统架构给部署和运维带来很大的难度。于是,spring为我们带来了构建大型分布式微服务的全套、全程产品: 构建一个个功能独立的微服务应用单元，可以使用springboot，可以帮我们快速构建一个应用; 大型分布式网络服务的调用，这部分由spring cloud来完成，实现分布式; 在分布式中间，进行流式数据计算、批处理，我们有spring cloud data flow, spring为我们想清楚了整个从开始构建应用到大型分布式应用全流程方案。 3、第一个SpringBoot程序 Spring官方提供了非常方便的工具让我们快速构建应用 Spring Initializr： https://start.spring.io/ 3.1、创建SpringBoot项目 **创建方式一：**使用Spring Initializr 的 Web页面创建项目 添加依赖，spring web框架 **创建方式二：**使用 IDEA 直接创建项目 3.2、解决idea2020.2版本创建SpringBoot项目卡死在Reading pom.xml 移除工程目录/.mvn/maven-wrapper.properties 文件， 删除项目目录下不需要的文件 重新打开idea，再根据路径open一下项目 但是感觉好麻烦！！！！ 找了解决方法： 找到 C:\\Users\\22315.m2\\wrapper\\dists 将maven换做自己的，并且配置阿里云镜像 补充： 后来发现创建创建项目时存放路径变了，还是会有同样的问题，所以建议换2019.3 或者 2020.1版本 启动后 启动成功后访问 localhost:8080 项目结构分析： 通过上面步骤完成了基础项目的创建。就会自动生成以下文件。 1、程序的主启动类 2、一个 application.properties 配置文件 3、一个 测试类 4、一个 pom.xml 所有的springboot依赖都是 spring-boot-start开头的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 父依赖 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.4.0&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;hello&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;hello&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- web场景启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- springboot单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- 打包插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 3.3、Hello World 在主程序的同级目录下，**新建一个controller包，一定要在同级目录下，**否则识别不到 12345678@RestControllerpublic class HelloSpringBoot &#123; //接口 http://localhost:8080/hello @RequestMapping(&quot;/hello&quot;) public String hello()&#123; return &quot;Hello World&quot;; &#125;&#125; 访问 http://localhost:8080/hello 3.4、将项目打成jar包 如果遇到 错误，可以配置打包时 跳过项目运行测试用例 12345678910111213&lt;!-- 在工作中,很多情况下我们打包是不想执行测试用例的 可能是测试用例不完事,或是测试用例会影响数据库数据 跳过测试用例执--&gt;&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!--跳过项目运行测试用例--&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt;&lt;/plugin&gt; 如果打包成功，则会在target目录下生成一个 jar 包 打成了jar包后，就可以在任何地方运行了！OK 3.5、彩蛋 1、修改项目的端口号 2、更改启动时显示的字符拼成的字母 只需一步：到项目下的 resources 目录下新建一个banner.txt 即可。 图案可以到：https://www.bootschool.net/ascii 这个网站生成，然后拷贝到文件中即可！ SpringBoot这么简单的东西背后一定有故事，我们一起去进行一波源码分析！ 4、运行原理初探 4.1、父依赖 其中它主要是依赖一个父项目，主要是管理项目的资源过滤及插件！ 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt; 点进去，发现还有一个父依赖 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt; 这里才是真正管理SpringBoot应用里面所有依赖版本的地方，SpringBoot的版本控制中心； 我们是写或者引入一些SpringBoot依赖的时候，不需要指定版本，因为有这些版本仓库 以后我们导入依赖默认是不需要写版本；但是如果导入的包没有在依赖中管理着就需要手动配置版本了； 4.2、启动器 spring-boot-starter 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 启动器：说白了就是SpringBoot的启动场景； springboot-boot-starter-xxx：就是spring-boot的场景启动器 spring-boot-starter-web：帮我们导入了web模块正常运行所依赖的组件； SpringBoot将所有的功能场景都抽取出来，做成一个个的starter （启动器），只需要在项目中引入这些starter即可，所有相关的依赖都会导入进来 ， 我们要用什么功能就导入什么样的场景启动器即可 ；我们未来也可以自己自定义 starter； 4.3、主启动类 默认的主启动类 12345678910//@SpringBootApplication 来标注一个主程序类//说明这是一个Spring Boot应用@SpringBootApplicationpublic class SpringbootApplication &#123; public static void main(String[] args) &#123; //以为是启动了一个方法，没想到启动了一个服务 SpringApplication.run(SpringbootApplication.class, args); &#125;&#125; 但是一个简单的启动类并不简单！ 1.@SpringBootApplication 作用**：标注在某个类上说明这个类是SpringBoot的主配置类** ， SpringBoot就应该运行这个类的main方法来启动SpringBoot应用； 进入这个注解：可以看到上面还有很多其他注解！ 1234567891011121314@SpringBootConfiguration @EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123; // ......&#125; @ComponentScan 这个注解在Spring中很重要 ,它对应XML配置中的元素。 作用：自动扫描并加载符合条件的组件或者bean ， 将这个bean定义加载到IOC容器中 @SpringBootConfiguration 作用：SpringBoot的配置类 ，标注在某个类上 ， 表示这是一个SpringBoot的配置类； 123456// 点进去得到下面的 @Component@Configurationpublic @interface SpringBootConfiguration &#123;&#125;@Component //说明这也是一个spring的组件public @interface Configuration &#123;&#125; 这里的 @Configuration标注在类上，相当于把该类作为spring的xml配置文件中的&lt;beans&gt;，作用为：配置spring容器(应用上下文) 里面的 @Component 这就说明，启动类本身也是Spring中的一个组件而已，负责启动应用！ @EnableAutoConfiguration 自动配置功能 以前我们需要自己配置的东西，而现在SpringBoot可以自动帮我们配置 ；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能，这样自动配置才能生效； 点进注解接续查看： @AutoConfigurationPackage ：自动配置包 12345@Import(&#123;Registrar.class&#125;) //导入选择器包注册public @interface AutoConfigurationPackage &#123; String[] basePackages() default &#123;&#125;; Class&lt;?&gt;[] basePackageClasses() default &#123;&#125;;&#125; @import ：Spring底层注解@import ， 给容器中导入一个组件 Registrar.class 作用：将主启动类的所在包及包下面所有子包里面的所有组件扫描到Spring容器 ； @Import({AutoConfigurationImportSelector.class}) ：给容器导入组件 ； AutoConfigurationImportSelector ：**自动配置导入选择器，**那么它会导入哪些组件的选择器呢？我们点击去这个类看源码： 1、这个类中有一个这样的方法 12345678// 获得候选的配置protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123; //这里的getSpringFactoriesLoaderFactoryClass（）方法 //返回的就是我们最开始看的启动自动导入配置文件的注解类；EnableAutoConfiguration List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader()); Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;); return configurations;&#125; 2、这个方法又调用了 SpringFactoriesLoader 类的静态方法！我们进入SpringFactoriesLoader类loadFactoryNames() 方法 12345public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) &#123; String factoryClassName = factoryClass.getName(); //这里它又调用了 loadSpringFactories 方法 return (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());&#125; 3、我们继续点击查看 loadSpringFactories 方法 1234567891011121314151617181920212223242526272829303132333435363738private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123; //获得classLoader ， 我们返回可以看到这里得到的就是EnableAutoConfiguration标注的类本身 MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader); if (result != null) &#123; return result; &#125; else &#123; try &#123; //去获取一个资源 &quot;META-INF/spring.factories&quot; Enumeration&lt;URL&gt; urls = classLoader != null ? classLoader.getResources(&quot;META-INF/spring.factories&quot;) : ClassLoader.getSystemResources(&quot;META-INF/spring.factories&quot;); LinkedMultiValueMap result = new LinkedMultiValueMap(); //将读取到的资源遍历，封装成为一个Properties while(urls.hasMoreElements()) &#123; URL url = (URL)urls.nextElement(); UrlResource resource = new UrlResource(url); Properties properties = PropertiesLoaderUtils.loadProperties(resource); Iterator var6 = properties.entrySet().iterator(); while(var6.hasNext()) &#123; Entry&lt;?, ?&gt; entry = (Entry)var6.next(); String factoryClassName = ((String)entry.getKey()).trim(); String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue()); int var10 = var9.length; for(int var11 = 0; var11 &lt; var10; ++var11) &#123; String factoryName = var9[var11]; result.add(factoryClassName, factoryName.trim()); &#125; &#125; &#125; cache.put(classLoader, result); return result; &#125; catch (IOException var13) &#123; throw new IllegalArgumentException(&quot;Unable to load factories from location [META-INF/spring.factories]&quot;, var13); &#125; &#125;&#125; 4、发现一个多次出现的文件：spring.factories，全局搜索它 spring.factories 我们根据源头打开spring.factories ， 看到了很多自动配置的文件；这就是自动配置根源所在！ WebMvcAutoConfiguration 我们在上面的自动配置类随便找一个打开看看，比如 ：WebMvcAutoConfiguration 可以看到这些一个个的都是JavaConfig配置类，而且都注入了一些Bean，可以找一些自己认识的类，看着熟悉一下！ 所以，自动配置真正实现是从classpath中搜寻所有的META-INF/spring.factories配置文件 ，并将其中对应的org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。 12Properties properties = PropertiesLoaderutils.loadProperties(resource);//所有的资源加载到配置类中 SpringBoot所有自动装配都是在启动的时候扫描并加载：spring.factories所有的自动配置类都在这里面，但是不一定生效，要判断条件是否成立，只要导入了对应的start，就有对应的启动器了，有了启动器，我们自动装配就会生效，然后就配置成功！ 结论： SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值 将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作（以前需要我们自动配置的东西，现在SpringBoot帮我们做了）； 整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中； 它会吧所有需要导入的组件，以类名的方式返回，这些组件就会被添加到容器 它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并配置好这些组件 ； 有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作； SpringApplication 不简单的方法 最初以为就是运行了一个main方法，没想到却开启了一个服务； 123456@SpringBootApplicationpublic class SpringbootApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootApplication.class, args); &#125;&#125; SpringApplication.run分析 分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行； SpringApplication 这个类主要做了以下四件事情： 1、推断应用的类型是普通的项目还是Web项目 2、查找并加载所有可用初始化器 ， 设置到initializers属性中 3、找出所有的应用程序监听器，设置到listeners属性中 4、推断并设置main方法的定义类，找到运行的主类 查看构造器： 1234567public SpringApplication(ResourceLoader resourceLoader, Class... primarySources) &#123; // ...... this.webApplicationType = WebApplicationType.deduceFromClasspath(); this.setInitializers(this.getSpringFactoriesInstances(); this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class)); this.mainApplicationClass = this.deduceMainApplicationClass();&#125; 4.4、run方法流程分析 5、yaml配置注入 5.1、配置文件 SpringBoot使用一个全局的配置文件 ， 配置文件名称是固定的 application.properties 语法结构 ：key=value application.yaml 语法结构 ：key：空格 value **配置文件的作用 ：**修改SpringBoot自动配置的默认值，因为SpringBoot在底层都给我们自动配置好了； 比如我们可以在配置文件中定制Tomcat 默认启动的端口号！测试一下！ 5.2、yaml概述 YAML是 “YAML Ain’t a Markup Language” （YAML不是一种标记语言）的递归缩写。在开发的这种语言时， YAML 的意思其实是：“Yet Another Markup Language”（仍是一种标记语言） 这种语言以数据作为中心，而不是以标记语言为重点！ 以前的配置文件，大多数都是使用xml来配置；比如一个简单的端口配置，我们来对比下yaml和xml 传统xml配置： 123&lt;server&gt; &lt;port&gt;8081&lt;port&gt;&lt;/server&gt; yaml配置： 1server： prot: 8080 5.2.1、yaml基础语法 说明：语法要求严格！ 1、空格不能省略 2、以缩进来控制层级关系，只要是左边对齐的一列数据都是同一个层级的。 3、属性和值的大小写都是十分敏感的。 字面量：普通的值 [ 数字，布尔值，字符串 ] 字面量直接写在后面就可以 ， 字符串默认不用加上双引号或者单引号； 1k: v 注意： “ ” 双引号，不会转义字符串里面的特殊字符 ， 特殊字符会作为本身想表示的意思； 比如 ：name: “kuang \\n shen” 输出 ：kuang 换行 shen ‘’ 单引号，会转义特殊字符 ， 特殊字符最终会变成和普通字符一样输出 比如 ：name: ‘kuang \\n shen’ 输出 ：kuang \\n shen 对象、Map（键值对） 1234#对象k、Map格式k: v1: v2: 在下一行来写对象的属性和值得关系，注意缩进；比如： 12345student: name: qinjiang age: 3 student: &#123;name: qinjiang,age: 3&#125; 数组（ List、set ） 用 - 值表示数组中的一个元素,比如： 1234pets: - cat - dog - pig 行内写法 12student: &#123;name: qinjiang,age: 3&#125;pets: [cat,dog,pig] 修改SpringBoot的默认端口号 配置文件中添加，端口号的参数，就可以切换端口； 12server: port: 8082 5.3、yaml注入配置文件 yaml文件更强大的地方在于，他可以给我们的实体类直接注入匹配值！ 1、在springboot项目中的resources目录下新建一个文件 application.yml 2、编写一个实体类 Dog； 123456789ackage com.kuang.springboot.pojo;@Component //注册bean到容器中public class Dog &#123; private String name; private Integer age; //有参无参构造、get、set方法、toString()方法 &#125; 3、思考，我们原来是如何给bean注入属性值的！@Value，给狗狗类测试一下： 1234567@Component //注册beanpublic class Dog &#123; @Value(&quot;阿黄&quot;) private String name; @Value(&quot;18&quot;) private Integer age;&#125; 4、原来：在SpringBoot的测试类下注入狗狗输出一下； 12345678910@SpringBootTestclass DemoApplicationTests &#123; @Autowired //将狗狗自动注入进来用来给指定的字段或方法注入所需的外部资源。 Dog dog; @Test public void contextLoads() &#123; System.out.println(dog); //打印看下狗狗对象 &#125;&#125; 结果成功输出，@Value注入成功，这是我们原来的办法。 5、我们在编写一个复杂一点的实体类：Person 类 1234567891011@Component //注册bean到容器中public class Person &#123; private String name; private Integer age; private Boolean happy; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; //有参无参构造、get、set方法、toString()方法 &#125; 6、我们来使用yaml配置的方式进行注入，大家写的时候注意区别和优势，我们编写一个yaml配置！ 12345678910111213person: name: qinjiang age: 3 happy: false birth: 2000/01/01 maps: &#123;k1: v1,k2: v2&#125; lists: - code - girl - music dog: name: 旺财 age: 1 7、我们刚才已经把person这个对象的所有值都写好了，我们现在来注入到我们的类中！ 1234567891011121314151617/*@ConfigurationProperties作用：将配置文件中配置的每一个属性的值，映射到这个组件中；告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定参数 prefix = “person” : 将配置文件中的person下面的所有属性一一对应*/@Component //注册bean@ConfigurationProperties(prefix = &quot;person&quot;)public class Person &#123; private String name; private Integer age; private Boolean happy; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog;&#125; 8、IDEA 提示，springboot配置注解处理器没有找到，让我们看文档，我们可以查看文档，找到一个依赖！ 123456&lt;!-- 导入配置文件处理器，配置文件进行绑定就会有提示，需要重启 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 9、确认以上配置都OK之后，我们去测试类中测试一下： 123456789101112@SpringBootTestclass DemoApplicationTests &#123; @Autowired Person person; //将person自动注入进来 @Test public void contextLoads() &#123; System.out.println(person); //打印person信息 &#125;&#125; 结果：所有值全部注入成功！不需要一个一个加value 运用mybatis等配置加入类 5.4、加载指定的配置文件 **@PropertySource ：**加载指定的配置文件； @configurationProperties：默认从全局配置文件中获取值； 1、我们去在resources目录下新建一个person.properties文件 1name=kuangshen 2、然后在我们的代码中指定加载person.properties文件 123456789@PropertySource(value = &quot;classpath:person.properties&quot;)//javaconfig 绑定我们的配置文件的值，可以采取这些方式！但是要value一个一个绑定@Component //注册beanpublic class Person &#123; @Value(&quot;$&#123;name&#125;&quot;) private String name; ...... &#125; 3、再次输出测试一下：指定配置文件绑定成功！ 可以不用@ConfigurationProperties(prefix = “person”)注解 的方式，使用@Value的方式注入属性值 @Value注解等价于： 以三个属性字段为例，我们既可以从配置文件取值，也可以通过字面量直接赋值，当属性值少的时候这种方式特别方便。 123456@Value(&quot;$&#123;person.lastName&#125;&quot;)private String lastName;@Value(&quot;$&#123;person.age&#125;&quot;)private Integer age;@Value(&quot;true&quot;)private Boolean boss; 5.5、yam配置文件占位符 配置文件还可以编写占位符生成随机数 random.uuid random.int 123456789101112131415person: name: qinjiang$&#123;random.uuid&#125; # 随机uuid age: $&#123;random.int&#125; # 随机int happy: false birth: 2000/01/01 maps: &#123;k1: v1,k2: v2&#125; lists: - code - girl - music dog: name: $&#123;person.hello:other&#125;_旺财 age: 1 #存在hello 输出name=&#x27;hacc_旺财&#x27; hello: hacc 测试一下！ 5.6、回顾properties配置 我们上面采用的yaml方法都是最简单的方式，开发中最常用的；也是springboot所推荐的！那我们来唠唠其他的实现方式，道理都是相同的；写还是那样写；配置文件除了yml还有我们之前常用的properties ， 我们没有讲，我们来唠唠！ 【注意】properties配置文件在写中文的时候，会有乱码 ， 我们需要去IDEA中设置编码格式为UTF-8； settings–&gt;FileEncodings 中配置； 测试步骤： 1、新建一个实体类User 123456@Component //注册beanpublic class User &#123; private String name; private int age; private String sex;&#125; 2、编辑配置文件 user.properties 123user1.name=kuangshenuser1.age=18user1.sex=男 3、我们在User类上使用@Value来进行注入！可以EL 1234567891011@Component //注册bean@PropertySource(value = &quot;classpath:user.properties&quot;)public class User &#123; //直接使用@value @Value(&quot;$&#123;user.name&#125;&quot;) //从配置文件中取值 private String name; @Value(&quot;#&#123;9*2&#125;&quot;) // #&#123;SPEL&#125; Spring表达式 private int age; @Value(&quot;男&quot;) // 字面量 private String sex;&#125; 4、Springboot测试 123456789@SpringBootTestclass DemoApplicationTests &#123; @Autowired User user; @Test public void contextLoads() &#123; System.out.println(user); &#125;&#125; 结果正常输出： 5.7、对比小结 @Value这个使用起来并不友好！我们需要为每个属性单独注解赋值，比较麻烦；我们来看个功能对比图 1、@ConfigurationProperties只需要写一次即可 ， @Value则需要每个字段都添加 2、松散绑定：这个什么意思呢? 比如我的yml中写的last-name，这个和lastName是一样的， - 后面跟着的字母默认是大写的。这就是松散绑定。可以测试一下驼峰和斜杠可以互相转化 3、JSR303数据校验 ， 这个就是我们可以在字段是增加一层过滤器验证 ， 可以保证数据的合法性 4、复杂类型封装，yml中可以封装对象 ， 使用value就不支持 5、EL表达式：${} 结论： 配置yml和配置properties都可以获取到值 ， 强烈推荐 yml； 如果我们在某个业务中，只需要获取配置文件中的某个值，可以使用一下 @value； 如果说，我们专门编写了一个JavaBean来和配置文件进行一一映射，就直接@configurationProperties，不要犹豫！ 6、JSR303数据校验 6.1、先看看如何使用 需要先导入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&lt;/dependency&gt; Springboot中可以用@validated来校验数据，如果数据异常则会统一抛出异常，方便异常中心统一处理。我们这里来写个注解让我们的name只能支持Email格式； 12345678@Component //注册bean@ConfigurationProperties(prefix = &quot;person&quot;)@Validated //数据校验public class Person &#123; @Email(message=&quot;邮箱错了&quot;) //name必须是邮箱格式 private String name;&#125; 使用数据校验，可以保证数据的正确性； 6.2、常见参数 核心：正则表达式 12345678910111213141516171819202122232425262728@NotNull(message=&quot;名字不能为空&quot;)private String userName;@Max(value=120,message=&quot;年龄最大不能查过120&quot;)private int age;@Email(message=&quot;邮箱格式错误&quot;)private String email;空检查@Null 验证对象是否为null@NotNull 验证对象是否不为null, 无法查检长度为0的字符串@NotBlank 检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格.@NotEmpty 检查约束元素是否为NULL或者是EMPTY. Booelan检查@AssertTrue 验证 Boolean 对象是否为 true @AssertFalse 验证 Boolean 对象是否为 false 长度检查@Size(min=, max=) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内 @Length(min=, max=) string is between min and max included.日期检查@Past 验证 Date 和 Calendar 对象是否在当前时间之前 @Future 验证 Date 和 Calendar 对象是否在当前时间之后 @Pattern 验证 String 对象是否符合正则表达式的规则.......等等除此以外，我们还可以自定义一些数据校验规则 7、 多环境切换 profile是Spring对不同环境提供不同配置功能的支持，可以通过激活不同的环境版本，实现快速切换环境； 7.1、多配置文件 我们在主配置文件编写的时候**，文件名可以是 application-{profile}.properties/yml , 用来指定多个环境版本**； 例如： application-test.properties 代表测试环境配置 application-dev.properties 代表开发环境配置 但是Springboot并不会直接启动这些配置文件，它默认使用application.properties主配置文件； 我们需要通过一个配置来选择需要激活的环境： 1234#比如在配置文件中指定使用dev环境，我们可以通过设置不同的端口号进行测试；#我们启动SpringBoot，就可以看到已经切换到dev下的配置了；spring.profiles.active=dev #springboot的多环境配置： 可以选择激活哪一个配置文件 是不是感觉很麻烦？？？，往下看！ 7.2、yaml的多文档模块 —多文档模式 和properties配置文件中一样，但是使用yml去实现不需要创建多个配置文件，更加方便了 ! 1234567891011121314151617181920server: port: 8081#选择要激活那个环境块spring: profiles: active: prod---server: port: 8083spring: profiles: dev #配置环境的名称---server: port: 8084spring: profiles: prod #配置环境的名称 注意：如果yml和properties同时都配置了端口，并且没有激活其他环境 ， 默认会使用properties配置文件的！ 7.3、配置文件加载位置 外部加载配置文件的方式十分多，我们选择最常用的即可，在开发的资源文件中进行配置！ 官方外部配置文件说明参考文档 springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件： 1234优先级1：项目路径下的config文件夹配置文件优先级2：项目路径下配置文件优先级3：资源路径下的config文件夹配置文件优先级4：资源路径下配置文件 优先级由高到底，高优先级的配置会覆盖低优先级的配置； 默认使用最低优先级的配置，我们写的都会覆盖默认配置。 SpringBoot会从这四个位置全部加载主配置文件；互补配置； 我们在最低级的配置文件中设置一个项目访问路径的配置来测试互补问题； 12#配置项目的访问路径server.servlet.context-path=/kuang 7.4、拓展，运维小技巧 指定位置加载配置文件 我们还可以通过spring.config.location来改变默认的配置文件位置 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；这种情况，一般是后期运维做的多，相同配置，外部指定的配置文件优先级最高 1java -jar spring-boot-config.jar --spring.config.location&#x3D;F:&#x2F;application.properties 8、自动配置原理 配置文件到底能写什么？怎么写？ SpringBoot官方文档中有大量的配置，我们无法全部记住 8.1、分析自动配置原理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//表示这是一个配置类，和以前编写的配置文件一样，也可以给容器中添加组件；@Configuration //启动指定类的ConfigurationProperties功能； //进入这个HttpProperties查看，将配置文件中对应的值和HttpProperties绑定起来； //并把HttpProperties加入到ioc容器中@EnableConfigurationProperties(&#123;HttpProperties.class&#125;) //Spring底层@Conditional注解 //根据不同的条件判断，如果满足指定的条件，整个配置类里面的配置就会生效； //这里的意思就是判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnWebApplication( type = Type.SERVLET)//判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;)//判断配置文件中是否存在某个配置：spring.http.encoding.enabled； //如果不存在，判断也是成立的 //即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；@ConditionalOnProperty( prefix = &quot;spring.http.encoding&quot;, value = &#123;&quot;enabled&quot;&#125;, matchIfMissing = true)public class HttpEncodingAutoConfiguration &#123; //他已经和SpringBoot的配置文件映射了 private final Encoding properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpProperties properties) &#123; this.properties = properties.getEncoding(); &#125; //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @Bean @ConditionalOnMissingBean //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE)); return filter; &#125;&#125; 一句话总结 ：根据当前不同的条件判断，决定这个配置类是否生效！ 一但这个配置类生效；这个配置类就会给容器中添加各种组件； 这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 所有在配置文件中能配置的属性都是在xxxxProperties类中封装着； 配置文件能配置什么就可以参照某个功能对应的这个属性类 12345//从配置文件中获取指定的值和bean的属性进行绑定@ConfigurationProperties(prefix = &quot;spring.http&quot;) public class HttpProperties &#123; // .....&#125; 我们去配置文件里面试试前缀，看提示！ 这就是自动装配的原理！ 8.2、精髓 1、SpringBoot启动会加载大量的自动配置类 2、我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中； 3、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件存在在其中，我们就不需要再手动配置了） 4、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们只需要在配置文件中指定这些属性的值即可； **xxxxAutoConfigurartion：自动配置类；**给容器中添加组件 xxxxProperties:封装配置文件中相关属性； 8.3、了解：@Conditional 了解完自动装配的原理后，我们来关注一个细节问题，自动配置类必须在一定的条件下才能生效； @Conditional派生注解（Spring注解版原生的@Conditional作用） 作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效； 那么多的自动配置类，必须在一定的条件下才能生效；也就是说，我们加载了这么多的配置类，但不是所有的都生效了。 我们怎么知道哪些自动配置类生效？ 我们可以通过启用 debug=true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效； 12#开启springboot的调试类debug=true Positive matches:（自动配置类启用的：正匹配） Negative matches:（没有启动，没有匹配成功的自动配置类：负匹配） Unconditional classes: （没有条件的类） 【演示：查看输出的日志】 掌握吸收理解原理，即可以不变应万变！ 9、自定义starter 9.1、说明 启动器模块是一个 空 jar 文件，仅提供辅助性依赖管理，这些依赖可能用于自动装配或者其他类库； 命名归约： 官方命名： 前缀：spring-boot-starter-xxx 比如：spring-boot-starter-web… 自定义命名： xxx-spring-boot-starter 比如：mybatis-spring-boot-starter 9.2、编写启动器 1、在IDEA中新建一个空项目 spring-boot-starter-diy 2、新建一个普通Maven模块：kuang-spring-boot-starter 3、新建一个Springboot模块：kuang-spring-boot-starter-autoconfigure 4、点击apply即可，基本结构 5、在我们的 starter 中 导入 autoconfigure 的依赖！ 123456789&lt;!-- 启动器 --&gt;&lt;dependencies&gt; &lt;!-- 引入自动配置模块 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.kuang&lt;/groupId&gt; &lt;artifactId&gt;kuang-spring-boot-starter-autoconfigure&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 6、将 autoconfigure 项目下多余的文件都删掉，Pom中只留下一个 starter，这是所有的启动器基本配置！ 7、我们编写一个自己的服务 12345678910111213141516public class HelloService &#123; HelloProperties helloProperties; public HelloProperties getHelloProperties() &#123; return helloProperties; &#125; public void setHelloProperties(HelloProperties helloProperties) &#123; this.helloProperties = helloProperties; &#125; public String sayHello(String name)&#123; return helloProperties.getPrefix() + name + helloProperties.getSuffix(); &#125;&#125; 8、编写HelloProperties 配置类 1234567891011121314151617181920212223// 前缀 kuang.hello@ConfigurationProperties(prefix = &quot;kuang.hello&quot;)public class HelloProperties &#123; private String prefix; private String suffix; public String getPrefix() &#123; return prefix; &#125; public void setPrefix(String prefix) &#123; this.prefix = prefix; &#125; public String getSuffix() &#123; return suffix; &#125; public void setSuffix(String suffix) &#123; this.suffix = suffix; &#125;&#125; 9、编写我们的自动配置类并注入bean，测试 12345678910111213141516@Configuration@ConditionalOnWebApplication //web应用生效@EnableConfigurationProperties(HelloProperties.class)public class HelloServiceAutoConfiguration &#123; @Autowired HelloProperties helloProperties; @Bean public HelloService helloService()&#123; HelloService service = new HelloService(); service.setHelloProperties(helloProperties); return service; &#125;&#125; 10、在resources编写一个自己的 META-INF\\spring.factories 123# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\com.kuang.HelloServiceAutoConfiguration 11、编写完成后，可以安装到maven仓库中！ 9.3、新建项目测试我们自己写的启动器 1、新建一个SpringBoot 项目 2、导入我们自己写的启动器 12345&lt;dependency&gt; &lt;groupId&gt;com.kuang&lt;/groupId&gt; &lt;artifactId&gt;kuang-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 3、编写一个 HelloController 进行测试我们自己的写的接口！ 1234567891011@RestControllerpublic class HelloController &#123; @Autowired HelloService helloService; @RequestMapping(&quot;/hello&quot;) public String hello()&#123; return helloService.sayHello(&quot;zxc&quot;); &#125;&#125; 4、编写配置文件 application.properties 123kuang.hello.prefix=&quot;ppp&quot;kuang.hello.suffix=&quot;sss&quot;12 5、启动项目进行测试，结果成功 ! 10、Web开发静态资源处理 接下来呢，开始学习SpringBoot与Web开发，其实SpringBoot的东西用起来非常简单，因为SpringBoot最大的特点就是自动装配。 使用SpringBoot的步骤： 1、创建一个SpringBoot应用，选择我们需要的模块，SpringBoot就会默认将我们的需要的模块自动配置好 2、手动在配置文件中配置部分配置项目就可以运行起来了 3、专注编写业务代码，不需要考虑以前那样一大堆的配置了。 要熟悉掌握开发，之前学习的自动配置的原理一定要搞明白！ 比如SpringBoot到底帮我们配置了什么？我们能不能修改？我们能修改哪些配置？我们能不能扩展？ 向容器中自动配置组件 ： Autoconfiguration 自动配置类，封装配置文件的内容：Properties 没事就找找类，看看自动装配原理！ 10.1、静态资源映射规则 webjars(不建议) public ,static，/**，resource 首先，我们搭建一个普通的SpringBoot项目，回顾一下HelloWorld程序！ 写请求非常简单，那我们要引入我们前端资源，我们项目中有许多的静态资源，比如css，js等文件，这个SpringBoot怎么处理呢？ 如果我们是一个web应用，我们的main下会有一个webapp，我们以前都是将所有的页面导在这里面的，对吧！但是我们现在的pom呢，打包方式是为jar的方式，那么这种方式SpringBoot能不能来给我们写页面呢？当然是可以的，但是SpringBoot对于静态资源放置的位置，是有规定的！ 我们先来聊聊这个静态资源映射规则： SpringBoot中，SpringMVC的web配置都在 WebMvcAutoConfiguration 这个配置类里面； 我们可以去看看 WebMvcAutoConfigurationAdapter 中有很多配置方法； 方法一：不常用 addResourceHandlers 添加资源处理 按照源码 123456789101112131415161718192021222324@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; // 已禁用默认资源处理 logger.debug(&quot;Default resource handling disabled&quot;); return; &#125; // 缓存控制 Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); // webjars 配置 if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) &#123; customizeResourceHandlerRegistration(registry.addResourceHandler(&quot;/webjars/**&quot;) .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;) .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; // 静态资源配置 String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern) .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations())) .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125;&#125; 读一下源代码：比如所有的 /webjars/** ， 都需要去 classpath:/META-INF/resources/webjars/ 找对应的资源； 什么是webjars 呢？ Webjars本质就是以jar包的方式引入我们的静态资源 ， 我们以前要导入一个静态资源文件，直接导入即可。 使用SpringBoot需要使用Webjars，我们可以去搜索一下： 网站：https://www.webjars.org 要使用jQuery，我们只要要引入jQuery对应版本的pom依赖即可！ 12345&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt; 导入完毕，查看webjars目录结构，并访问Jquery.js文件！ 访问：只要是静态资源，SpringBoot就会去对应的路径寻找资源，我们这里访问：http://localhost:8080/webjars/jquery/3.4.1/jquery.js 第二种静态资源映射规则 那我们项目中要是使用自己的静态资源该怎么导入呢？我们看下一行代码； 我们去找staticPathPattern发现第二种映射规则 ：/** , 访问当前的项目任意资源，它会去找 resourceProperties 这个类，我们可以点进去看一下分析： 12345678910111213// 进入方法public String[] getStaticLocations() &#123; return this.staticLocations;&#125;// 找到对应的值private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;// 找到路径private static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; &quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &#125;; ResourceProperties 可以设置和我们静态资源有关的参数；这里面指向了它会去寻找资源的文件夹，即上面数组的内容。 所以得出结论，以下四个目录存放的静态资源可以被我们识别： 1234&quot;classpath:/META-INF/resources/&quot;&quot;classpath:/resources/&quot;&quot;classpath:/static/&quot;&quot;classpath:/public/&quot; 我们可以在resources根目录下新建对应的文件夹，都可以存放我们的静态文件； 比如我们访问 http://localhost:8080/1.js , 他就会去这些文件夹中寻找对应的静态资源文件； 说明优先级：resources&gt;static&gt;public 自定义静态资源路径 我们也可以自己通过配置文件来指定一下，哪些文件夹是需要我们放静态资源文件的，在application.properties中配置； 1spring.resources.static-locations=classpath:/coding/,classpath:/kuang/ 一旦自己定义了静态文件夹的路径，原来的自动配置就都会失效了！ 10.2、首页处理 静态资源文件夹说完后，继续向下看源码！可以看到一个欢迎页的映射，就是我们的首页 12345678910@Bean//注入了public WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext, FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider) &#123; WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping( new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(), this.mvcProperties.getStaticPathPattern()); welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider)); welcomePageHandlerMapping.setCorsConfigurations(getCorsConfigurations()); return welcomePageHandlerMapping;&#125; 点进去继续看 123456789101112private Optional&lt;Resource&gt; getWelcomePage() &#123; String[] locations = getResourceLocations(this.resourceProperties.getStaticLocations()); // ::是java8 中新引入的运算符 // Class::function的时候function是属于Class的，应该是静态方法。 // this::function的funtion是属于这个对象的。 // 简而言之，就是一种语法糖而已，是一种简写 return Arrays.stream(locations).map(this::getIndexHtml).filter(this::isReadable).findFirst();&#125;// 欢迎页就是一个location下的的 index.html 而已private Resource getIndexHtml(String location) &#123; return this.resourceLoader.getResource(location + &quot;index.html&quot;);&#125; 跳转到templates页面下的目录 欢迎页，静态资源文件夹下的所有 index.html 页面；被 /** 映射。 比如我访问 http://localhost:8080/ ，就会找静态资源文件夹下的 index.html 新建一个 index.html ，在我们上面的3个目录中任意一个；然后访问测试 http://localhost:8080/ 看结果！ 关于网站图标说明： 与其他静态资源一样，Spring Boot在配置的静态内容位置中查找 favicon.ico。如果存在这样的文件，它将自动用作应用程序的favicon。 1、关闭SpringBoot默认图标 配置首页图标 12#关闭默认图标spring.mvc.favicon.enabled=false 2、自己放一个图标在静态资源目录下，我放在 public 目录下 3、清除浏览器缓存！刷新网页，发现图标已经变成自己的了！ 11、模板引擎 前端交给我们的页面，是html页面。如果是我们以前开发，我们需要把他们转成jsp页面，jsp好处就是当我们查出一些数据转发到JSP页面以后，我们可以用jsp轻松实现数据的显示，及交互等。 jsp支持非常强大的功能，包括能写Java代码，但是呢，我们现在的这种情况，SpringBoot这个项目首先是以jar的方式，不是war，像第二，我们用的还是嵌入式的Tomcat，所以呢，他现在默认是不支持jsp的。 那不支持jsp，如果我们直接用纯静态页面的方式，那给我们开发会带来非常大的麻烦，那怎么办呢？ SpringBoot推荐你可以来使用模板引擎： 模板引擎，我们其实大家听到很多，其实jsp就是一个模板引擎，还有用的比较多的freemarker，包括SpringBoot给我们推荐的Thymeleaf，模板引擎有非常多，但再多的模板引擎，他们的思想都是一样的，什么样一个思想呢我们来看一下这张图： 模板引擎的作用就是我们来写一个页面模板，比如有些值呢，是动态的，我们写一些表达式。而这些值，从哪来呢，就是我们在后台封装一些数据。然后把这个模板和这个数据交给我们模板引擎，模板引擎按照我们这个数据帮你把这表达式解析、填充到我们指定的位置，然后把这个数据最终生成一个我们想要的内容给我们写出去，这就是我们这个模板引擎，不管是jsp还是其他模板引擎，都是这个思想。只不过呢，就是说不同模板引擎之间，他们可能这个语法有点不一样。其他的我就不介绍了，我主要来介绍一下SpringBoot给我们推荐的Thymeleaf模板引擎，这模板引擎呢，是一个高级语言的模板引擎，他的这个语法更简单。而且呢，功能更强大。 我们呢，就来看一下这个模板引擎，那既然要看这个模板引擎。首先，我们来看SpringBoot里边怎么用。 11.1、引入Thymeleaf 怎么引入呢，对于springboot来说，什么事情不都是一个start的事情嘛，我们去在项目中引入一下。给大家三个网址： Thymeleaf 官网：https://www.thymeleaf.org/ Thymeleaf 在Github 的主页：https://github.com/thymeleaf/thymeleaf Spring官方文档：找到我们对应的版本 https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter 找到对应的pom依赖：可以适当点进源码看下本来的包！ 1234567891011121314&lt;!--thymeleaf--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-java8time&lt;/artifactId&gt;&lt;/dependency&gt; Maven会自动下载jar包，我们可以去看下下载的东西； 11.2、Thymeleaf分析 前面呢，我们已经引入了Thymeleaf，那这个要怎么使用呢？ 我们首先得按照SpringBoot的自动配置原理看一下我们这个Thymeleaf的自动配置规则，在按照那个规则，我们进行使用。 我们去找一下Thymeleaf的自动配置类：ThymeleafProperties 1234567891011121314@ConfigurationProperties( prefix = &quot;spring.thymeleaf&quot;)public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING; public static final String DEFAULT_PREFIX = &quot;classpath:/templates/&quot;; public static final String DEFAULT_SUFFIX = &quot;.html&quot;; private boolean checkTemplate = true; private boolean checkTemplateLocation = true; private String prefix = &quot;classpath:/templates/&quot;; private String suffix = &quot;.html&quot;; private String mode = &quot;HTML&quot;; private Charset encoding;&#125; 我们可以在其中看到默认的前缀和后缀！ 我们只需要把我们的html页面放在类路径下的templates下，thymeleaf就可以帮我们自动渲染了。 使用thymeleaf什么都不需要配置，只需要将他放在指定的文件夹下即可！ 11.3、测试 1、编写一个TestController 1234567@Controllerpublic class TestController &#123; @RequestMapping(&quot;/test&quot;) public String test()&#123; return &quot;test&quot;; &#125;&#125; 2、编写一个测试页面 test.html 放在 templates 目录下 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;首页&lt;/body&gt;&lt;/html&gt; 3、启动项目请求测试 小结： 只要需要使用thymeleaf，只需要导入对应的依赖就可以了，我们需要将html页面放在我们的templates目录下即可 11.4、Thymeleaf 语法学习 要学习语法，还是参考官网文档最为准确，我们找到对应的版本看一下； Thymeleaf 官网：https://www.thymeleaf.org/ ， 简单看一下官网！我们去下载Thymeleaf的官方文档！ 要使用thymeleaf，需要在html文件中导入命名空间的约束 1xmlns:th=&quot;http://www.thymeleaf.org&quot; 测试 1、修改测试请求，增加数据传输； 123456789@Controllerpublic class TestController &#123; @RequestMapping(&quot;/test&quot;) public String test(Model model)&#123; model.addAttribute(&quot;msg&quot;,&quot;hello springboot&quot;); return &quot;test&quot;; &#125;&#125; 2、编写下前端页面 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--注意： 所有的html元素都可以被thymeleaf替换接管； th: 元素名--&gt; &lt;!--th:text就是将div中的内容设置为它指定的值，和之前学习的Vue一样--&gt;&lt;div th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3、测试 来认真研习一下Thymeleaf的使用语法！ 1、我们可以使用任意的 th:attr 来替换Html中原生属性的值！ 2、我们能写哪些表达式呢？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364Simple expressions:（表达式语法）Variable Expressions: $&#123;...&#125;：获取变量值；OGNL； 1）、获取对象的属性、调用方法 2）、使用内置的基本对象：#18 #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. 3）、内置的一些工具对象： #execInfo : information about the template being processed. #uris : methods for escaping parts of URLs/URIs #conversions : methods for executing the configured conversion service (if any). #dates : methods for java.util.Date objects: formatting, component extraction, etc. #calendars : analogous to #dates , but for java.util.Calendar objects. #numbers : methods for formatting numeric objects. #strings : methods for String objects: contains, startsWith, prepending/appending, etc. #objects : methods for objects in general. #bools : methods for boolean evaluation. #arrays : methods for arrays. #lists : methods for lists. #sets : methods for sets. #maps : methods for maps. #aggregates : methods for creating aggregates on arrays or collections.================================================================================== Selection Variable Expressions: *&#123;...&#125;：选择表达式：和$&#123;&#125;在功能上是一样； Message Expressions: #&#123;...&#125;：获取国际化内容 Link URL Expressions: @&#123;...&#125;：定义URL； Fragment Expressions: ~&#123;...&#125;：片段引用表达式Literals（字面量） Text literals: &#x27;one text&#x27; , &#x27;Another one!&#x27; ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,… Text operations:（文本操作） String concatenation: + Literal substitutions: |The name is $&#123;name&#125;| Arithmetic operations:（数学运算） Binary operators: + , - , * , / , % Minus sign (unary operator): - Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , not Comparisons and equality:（比较运算） Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne ) Conditional operators:条件运算（三元运算符） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue) Special tokens: No-Operation: _ 测试： 1、编写一个Controller 12345678@RequestMapping(&quot;/t2&quot;)public String test2(Map&lt;String,Object&gt; map)&#123; //存入数据 map.put(&quot;msg&quot;,&quot;&lt;h1&gt;Hello&lt;/h1&gt;&quot;); map.put(&quot;users&quot;, Arrays.asList(&quot;qinjiang&quot;,&quot;kuangshen&quot;)); //classpath:/templates/test.html return &quot;test&quot;;&#125; 2、测试页面取出数据 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;狂神说&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;测试页面&lt;/h1&gt;&lt;div th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/div&gt;&lt;!--不转义--&gt;&lt;div th:utext=&quot;$&#123;msg&#125;&quot;&gt;&lt;/div&gt;&lt;!--遍历数据--&gt;&lt;!--th:each每次遍历都会生成当前这个标签：官网#9--&gt;&lt;h4 th:each=&quot;user :$&#123;users&#125;&quot; th:text=&quot;$&#123;user&#125;&quot;&gt;&lt;/h4&gt;&lt;h4&gt; &lt;!--行内写法：官网 不建议--&gt; &lt;span th:each=&quot;user:$&#123;users&#125;&quot;&gt;[[$&#123;user&#125;]]&lt;/span&gt;&lt;/h4&gt;&lt;/body&gt;&lt;/html&gt; 3、测试！ 12、MVC自动配置原理 12.1、官网阅读 在进行项目编写前，我们还需要知道一个东西，就是SpringBoot对我们的SpringMVC还做了哪些配置，包括如何扩展，如何定制。 只有把这些都搞清楚了，我们在之后使用才会更加得心应手。途径一：源码分析，途径二：官方文档！ 地址 ：https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration 123456789101112131415161718192021222324252627282930313233343536373839Spring MVC Auto-configuration// Spring Boot为Spring MVC提供了自动配置，它可以很好地与大多数应用程序一起工作。Spring Boot provides auto-configuration for Spring MVC that works well with most applications.// 自动配置在Spring默认设置的基础上添加了以下功能：The auto-configuration adds the following features on top of Spring’s defaults:// 包含视图解析器-Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.// 支持静态资源文件夹的路径，以及webjars-Support for serving static resources, including support for WebJars // 自动注册了Converter：// 转换器，这就是我们网页提交数据到后台自动封装成为对象的东西，比如把&quot;1&quot;字符串自动转换为int类型// Formatter：【格式化器，比如页面给我们了一个2019-8-10，它会给我们自动格式化为Date对象】-Automatic registration of Converter, GenericConverter, and Formatter beans.// HttpMessageConverters// SpringMVC用来转换Http请求和响应的的，比如我们要把一个User对象转换为JSON字符串，可以去看官网文档解释；-Support for HttpMessageConverters (covered later in this document).// 定义错误代码生成规则的-Automatic registration of MessageCodesResolver (covered later in this document).// 首页定制-Static index.html support.// 图标定制-Custom Favicon support (covered later in this document).// 初始化数据绑定器：帮我们把请求数据绑定到JavaBean中！-Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document)./*如果您希望保留Spring Boot MVC功能，并且希望添加其他MVC配置（拦截器、格式化程序、视图控制器和其他功能），则可以添加自己的@configuration类，类型为webmvcconfiguer，但不添加@EnableWebMvc。如果希望提供RequestMappingHandlerMapping、RequestMappingHandlerAdapter或ExceptionHandlerExceptionResolver的自定义实例，则可以声明WebMVCregistrationAdapter实例来提供此类组件。*/If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components.// 如果您想完全控制Spring MVC，可以添加自己的@Configuration，并用@EnableWebMvc进行注释。If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 12.2、ContentNegotiatingViewResolver 内容协商视图解析器 自动配置了ViewResolver，就是我们之前学习的SpringMVC的视图解析器； 即根据方法的返回值取得视图对象（View），然后由视图对象决定如何渲染（转发，重定向）。 我们去看看这里的源码：我们找到 WebMvcAutoConfiguration ， 然后搜索ContentNegotiatingViewResolver。找到如下方法！ 12345678910111213@Bean@ConditionalOnBean(&#123;ViewResolver.class&#125;)@ConditionalOnMissingBean( name = &#123;&quot;viewResolver&quot;&#125;, value = &#123;ContentNegotiatingViewResolver.class&#125;)public ContentNegotiatingViewResolver viewResolver(BeanFactory beanFactory) &#123; ContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver(); resolver.setContentNegotiationManager((ContentNegotiationManager)beanFactory.getBean(ContentNegotiationManager.class)); // ContentNegotiatingViewResolver使用所有其他视图解析器来定位视图，因此它应该具有较高的优先级 resolver.setOrder(Ordered.HIGHEST_PRECEDENCE); return resolver;&#125; 我们可以点进这类看看！找到对应的解析视图的代码； 12345678910111213141516@Nullable // 注解说明：@Nullable 即参数可为nullpublic View resolveViewName(String viewName, Locale locale) throws Exception &#123; RequestAttributes attrs = RequestContextHolder.getRequestAttributes(); Assert.state(attrs instanceof ServletRequestAttributes, &quot;No current ServletRequestAttributes&quot;); List&lt;MediaType&gt; requestedMediaTypes = this.getMediaTypes(((ServletRequestAttributes)attrs).getRequest()); if (requestedMediaTypes != null) &#123; // 获取候选的视图对象 List&lt;View&gt; candidateViews = this.getCandidateViews(viewName, locale, requestedMediaTypes); // 选择一个最适合的视图对象，然后把这个对象返回 View bestView = this.getBestView(candidateViews, requestedMediaTypes, attrs); if (bestView != null) &#123; return bestView; &#125; &#125; // .....&#125; 我们继续点进去看，他是怎么获得候选的视图的呢？ getCandidateViews中看到他是把所有的视图解析器拿来，进行while循环，挨个解析！ 1Iterator var5 = this.viewResolvers.iterator(); 所以得出结论：ContentNegotiatingViewResolver 这个视图解析器就是用来组合所有的视图解析器的 我们再去研究下他的组合逻辑，看到有个属性viewResolvers，看看它是在哪里进行赋值的！ 1234567891011protected void initServletContext(ServletContext servletContext) &#123; // 这里它是从beanFactory工具中获取容器中的所有视图解析器 // ViewRescolver.class 把所有的视图解析器来组合的 Collection&lt;ViewResolver&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(this.obtainApplicationContext(), ViewResolver.class).values(); ViewResolver viewResolver; if (this.viewResolvers == null) &#123; this.viewResolvers = new ArrayList(matchingBeans.size()); Iterator var3 = matchingBeans.iterator(); &#125; // ...............&#125; 既然它是在容器中去找视图解析器，我们是否可以猜想，我们就可以去实现一个视图解析器了呢？ 我们可以自己给容器中去添加一个视图解析器；这个类就会帮我们自动的将它组合进来；我们去实现一下 1、我们在我们的主程序中去写一个视图解析器来试试； 123456789101112131415161718// 如果 想DIY一些定制化的功能，只要写这个组件，然后将它交给springboot，springboot就会帮我们自动装配//扩展springmvc@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123; //ViewResolver 实现类视图解析器接口的类，我们就可以把它看做视图解析器 @Bean public ViewResolver myViewResolver()&#123; return new MyViewResolver(); &#125; //我们写一个静态内部类，视图解析器就需要实现ViewResolver接口 public static class MyViewResolver implements ViewResolver &#123; @Override public View resolveViewName(String s, Locale locale) throws Exception &#123; return null; &#125; &#125;&#125; 2、怎么看我们自己写的视图解析器有没有起作用呢？ 我们给 DispatcherServlet 中的 doDispatch方法 加个断点进行调试一下，因为所有的请求都会走到这个方法中 3、我们启动我们的项目，然后随便访问一个页面，看一下Debug信息； 找到this 找到视图解析器，我们看到我们自己定义的就在这里了； 所以说，我们如果想要使用自己定制化的东西，我们只需要给容器中添加这个组件就好了！剩下的事情SpringBoot就会帮我们做了！ 12.3、转换器和格式化器 在WebMvcAutoConfiguration中找到格式化转换器： 123456789@Bean@Overridepublic FormattingConversionService mvcConversionService() &#123; // 拿到配置文件中的格式化规则 WebConversionService conversionService = new WebConversionService(this.mvcProperties.getDateFormat()); addFormatters(conversionService); return conversionService;&#125; 点进去： 1234567public String getDateFormat() &#123; return this.dateFormat;&#125;/*** Date format to use. For instance, `dd/MM/yyyy`. 默认的 */private String dateFormat; 可以看到在我们的Properties文件中，我们可以进行自动配置它！ 如果配置了自己的格式化方式，就会注册到Bean中生效，我们可以在配置文件中配置日期格式化的规则： 12.4、修改SpringBoot的默认配置 这么多的自动配置，原理都是一样的，通过这个WebMVC的自动配置原理分析， 我们要学会一种学习方式，通过源码探究，得出结论；这个结论一定是属于自己的，而且一通百通。 SpringBoot的底层，大量用到了这些设计细节思想，所以，没事需要多阅读源码！得出结论； SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（如果用户自己配置@bean），如果有就用用户配置的，如果没有就用自动配置的； 如果有些组件可以存在多个，比如我们的视图解析器，就将用户配置的和自己默认的组合起来！ 扩展使用SpringMVC 官方文档如下： If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components. 我们要做的就是编写一个@Configuration注解类，并且**类型要为WebMvcConfigurer，还不能标注@EnableWebMvc注解；**我们去自己写一个；我们新建一个包叫config，写一个类MyMvcConfig； 12345678910//应为类型要求为WebMvcConfigurer，所以我们实现其接口//可以使用自定义类扩展MVC的功能@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // 浏览器发送/test ， 就会跳转到test页面； registry.addViewController(&quot;/test&quot;).setViewName(&quot;test&quot;); &#125;&#125; 我们去浏览器访问一下： 确实也跳转过来了！所以说，我们要扩展SpringMVC，官方就推荐我们这么去使用，既保SpringBoot留所有的自动配置，也能用我们扩展的配置！ 我们可以去分析一下原理： 1、WebMvcAutoConfiguration 是 SpringMVC的自动配置类，里面有一个类WebMvcAutoConfigurationAdapter 2、这个类上有一个注解@EnableWebMvc，在做其他自动配置时会导入：@Import(EnableWebMvcConfiguration.class) 3、我们点进EnableWebMvcConfiguration这个类看一下，它继承了一个父类：DelegatingWebMvcConfiguration 这个父类中有这样一段代码： 1234567891011public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123; private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); // 从容器中获取所有的webmvcConfigurer @Autowired(required = false) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123; if (!CollectionUtils.isEmpty(configurers)) &#123; this.configurers.addWebMvcConfigurers(configurers); &#125; &#125;&#125; 4、我们可以在这个类中去寻找一个我们刚才设置的viewController当做参考，发现它调用了一个 123protected void addViewControllers(ViewControllerRegistry registry) &#123; this.configurers.addViewControllers(registry);&#125; 5、我们点进去看一下 123456789public void addViewControllers(ViewControllerRegistry registry) &#123; Iterator var2 = this.delegates.iterator(); while(var2.hasNext()) &#123; // 将所有的WebMvcConfigurer相关配置来一起调用！包括我们自己配置的和Spring给我们配置的 WebMvcConfigurer delegate = (WebMvcConfigurer)var2.next(); delegate.addViewControllers(registry); &#125;&#125; 所以得出结论：所有的WebMvcConfiguration都会被作用，不止Spring自己的配置类，我们自己的配置类当然也会被调用； 12.5、全面接管SpringMVC 官方文档： If you want to take complete control of Spring MVCyou can add your own @Configuration annotated with @EnableWebMvc. 全面接管即：SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己去配置！ 只需在我们的配置类中要加一个@EnableWebMvc。 我们看下如果我们全面接管了SpringMVC了，我们之前SpringBoot给我们配置的静态资源映射一定会无效，我们可以去测试一下； 不加注解之前，访问首页： 给配置类加上注解：@EnableWebMvc 我们发现所有的SpringMVC自动配置都失效了！回归到了最初的样子； 当然，我们开发中，不推荐使用全面接管SpringMVC 思考问题？为什么加了一个注解，自动配置就失效了！我们看下源码： 1、这里发现它是导入了一个类，我们可以继续进去看 123@Import(&#123;DelegatingWebMvcConfiguration.class&#125;)public @interface EnableWebMvc &#123;&#125; 2、它继承了一个父类 WebMvcConfigurationSupport 123public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123; // ......&#125; 3、我们来回顾一下Webmvc自动配置类 1234567891011@Configuration(proxyBeanMethods = false)@ConditionalOnWebApplication(type = Type.SERVLET)@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)// 这个注解的意思就是：容器中没有这个组件的时候，这个自动配置类才生效@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class, ValidationAutoConfiguration.class &#125;)public class WebMvcAutoConfiguration &#123; &#125; 总结一句话：@EnableWebMvc将WebMvcConfigurationSupport组件导入进来了； 而导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能！ 在SpringBoot中会有非常多的扩展配置，只要看见了这个，我们就应该多留心注意~ 员工管理系统 基本导入 1.模拟数据库，搭建dao和pojo 2.配置首页 3.添加css,添加图片：关闭模板引擎的缓存 运用@绝对路径 1、首页配置：注意点，所有也免得静态资源都需要使用thymeleaf接管； 1.模拟数据库，搭建dao和pojo 2.配置首页 3.添加css,添加图片：关闭模板引擎的缓存 运用@绝对路径 2、页面国际化(见后) 配置i18n文件 如果需要在项目中进行按钮自动切换，我们需要自定义一个组件LocaleResolver 将自己写的组件配置到spring容器中----@Bean #{} 3、登录 + 拦截器 3.1 登录页面对应 1234567891011121314151617181920&lt;form class=&quot;form-signin&quot; th:action=&quot;@&#123;/user/login&#125;&quot;&gt;&lt;img class=&quot;mb-4&quot; th:src=&quot;@&#123;img/bootstrap-solid.svg&#125;&quot; alt=&quot;&quot; width=&quot;72&quot; height=&quot;72&quot;&gt;&lt;h1 class=&quot;h3 mb-3 font-weight-normal&quot; th:text=&quot;#&#123;login.tip&#125;&quot;&gt;Please sign in&lt;/h1&gt;&lt;!--p标签注释样式--&gt;&lt;p style=&quot;color:red&quot; th:text=&quot;$&#123;msg&#125;&quot; th:if=&quot;$&#123;not #strings.isEmpty(msg)&#125;&quot;&gt;&lt;/p&gt;&lt;label class=&quot;sr-only&quot; &gt;Username&lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; class=&quot;form-control&quot; th:placeholder=&quot;#&#123;login.username&#125;&quot; required=&quot;&quot; autofocus=&quot;&quot;&gt;&lt;label class=&quot;sr-only&quot;&gt;Password&lt;/label&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; class=&quot;form-control&quot; th:placeholder=&quot;#&#123;login.password&#125;&quot; required=&quot;&quot;&gt;&lt;div class=&quot;checkbox mb-3&quot;&gt;&lt;label&gt;&lt;input type=&quot;checkbox&quot; value=&quot;remember-me&quot; th:text=&quot;#&#123;login.remember&#125;&quot;&gt;&lt;/label&gt;&lt;/div&gt;&lt;button class=&quot;btn btn-lg btn-primary btn-block&quot; type=&quot;submit&quot; th:text=&quot;#&#123;login.btn&#125;&quot;&gt;&lt;/button&gt;&lt;p class=&quot;mt-5 mb-3 text-muted&quot;&gt;© 2017-2018&lt;/p&gt;&lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@&#123;/index.html(l=&#x27;zh_CN&#x27;)&#125;&quot;&gt;中文&lt;/a&gt;&lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@&#123;/index.html(l=&#x27;en_US&#x27;)&#125;&quot;&gt;English&lt;/a&gt;&lt;/form&gt; 3.2拦截器 4、员工列表展示 提取公共页面 th:fragment=&quot;sidebar&quot; &lt;div th:replace=&quot;~&#123;commons/commons::sidebar(active='main.html')&#125;&quot;&gt;&lt;/div&gt; 高亮 如果要传递参数，可以直接使用（）传参，接收判断即可 列表循环展示、 提取之后删除 插入common内部 的路径 insert ~ 5、添加员工 按钮提交 跳转到添加页面 添加成功 返回首页 6、CRUD搞定 代码整理：https://gitee.com/su_shuwang/SpringBootLearn 13、页面国际化（i18n） 有的时候，我们的网站会去涉及中英文甚至多语言的切换，这时候我们就需要学习国际化了！ 13.1、准备工作 先在IDEA中统一设置properties的编码问题！ 编写国际化配置文件，抽取页面需要显示的国际化页面消息。我们可以去登录页面查看一下，哪些内容我们需要编写国际化的配置！ 13.2、配置文件编写 1、我们在resources资源文件下新建一个i18n目录，存放国际化配置文件 2、建立一个login.properties文件，还有一个login_zh_CN.properties；发现IDEA自动识别了我们要做国际化操作；文件夹变了！ 3、我们可以在这上面去新建一个文件； 弹出如下页面：我们再添加一个英文的； 这样就快捷多了！ 4、接下来，我们就来编写配置，我们可以看到idea下面有另外一个视图； 这个视图我们点击 + 号就可以直接添加属性了；我们新建一个login.tip，可以看到边上有三个文件框可以输入 我们添加一下首页的内容！ 然后依次添加其他页面内容即可！ 然后去查看我们的配置文件； login.properties ：默认 英文： 中文： OK，配置文件步骤搞定！ 13.3、配置文件生效探究 我们去看一下SpringBoot对国际化的自动配置！这里又涉及到一个类：MessageSourceAutoConfiguration 里面有一个方法，这里发现SpringBoot已经自动配置好了管理我们国际化资源文件的组件 ResourceBundleMessageSource； 12345678910111213141516171819202122// 获取 properties 传递过来的值进行判断@Beanpublic MessageSource messageSource(MessageSourceProperties properties) &#123; ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); if (StringUtils.hasText(properties.getBasename())) &#123; // 设置国际化文件的基础名（去掉语言国家代码的） messageSource.setBasenames( StringUtils.commaDelimitedListToStringArray( StringUtils.trimAllWhitespace(properties.getBasename()))); &#125; if (properties.getEncoding() != null) &#123; messageSource.setDefaultEncoding(properties.getEncoding().name()); &#125; messageSource.setFallbackToSystemLocale(properties.isFallbackToSystemLocale()); Duration cacheDuration = properties.getCacheDuration(); if (cacheDuration != null) &#123; messageSource.setCacheMillis(cacheDuration.toMillis()); &#125; messageSource.setAlwaysUseMessageFormat(properties.isAlwaysUseMessageFormat()); messageSource.setUseCodeAsDefaultMessage(properties.isUseCodeAsDefaultMessage()); return messageSource;&#125; 我们真实 的情况是放在了i18n目录下，所以我们要去配置这个messages的路径； 1spring.messages.basename=i18n.login 13.4、配置页面国际化值 去页面获取国际化的值，查看Thymeleaf的文档，找到message取值操作为：#{…}。我们去页面测试下： IDEA还有提示，非常智能的！ 我们可以去启动项目，访问一下，发现已经自动识别为中文的了！ 但是我们想要更好！可以根据按钮自动切换中文英文！ 配置国际化解析 在Spring中有一个国际化的Locale （区域信息对象）；里面有一个叫做LocaleResolver （获取区域信息对象）的解析器！ 我们去我们webmvc自动配置文件，寻找一下！看到SpringBoot默认配置： 12345678910111213@Bean@ConditionalOnMissingBean@ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;locale&quot;)public LocaleResolver localeResolver() &#123; // 容器中没有就自己配，有的话就用用户配置的 if (this.mvcProperties.getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123; return new FixedLocaleResolver(this.mvcProperties.getLocale()); &#125; // 接收头国际化分解 AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver;&#125; AcceptHeaderLocaleResolver 这个类中有一个方法 1234567891011121314151617181920public Locale resolveLocale(HttpServletRequest request) &#123; Locale defaultLocale = this.getDefaultLocale(); // 默认的就是根据请求头带来的区域信息获取Locale进行国际化 if (defaultLocale != null &amp;&amp; request.getHeader(&quot;Accept-Language&quot;) == null) &#123; return defaultLocale; &#125; else &#123; Locale requestLocale = request.getLocale(); List&lt;Locale&gt; supportedLocales = this.getSupportedLocales(); if (!supportedLocales.isEmpty() &amp;&amp; !supportedLocales.contains(requestLocale)) &#123; Locale supportedLocale = this.findSupportedLocale(request, supportedLocales); if (supportedLocale != null) &#123; return supportedLocale; &#125; else &#123; return defaultLocale != null ? defaultLocale : requestLocale; &#125; &#125; else &#123; return requestLocale; &#125; &#125;&#125; 那假如我们现在想点击链接让我们的国际化资源生效，就需要让我们自己的Locale生效！ 我们去自己写一个自己的LocaleResolver，可以在链接上携带区域信息！ 修改一下前端页面的跳转连接： 123&lt;!-- 这里传入参数不需要使用 ？使用 （key=value）--&gt;&lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@&#123;/index.html(l=&#x27;zh_CN&#x27;)&#125;&quot;&gt;中文&lt;/a&gt;&lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@&#123;/index.html(l=&#x27;en_US&#x27;)&#125;&quot;&gt;English&lt;/a&gt; 我们去写一个处理的组件类！ 123456789101112131415161718192021//可以在链接上携带区域信息public class MyLocaleResolver implements LocaleResolver &#123; //解析请求 @Override public Locale resolveLocale(HttpServletRequest request) &#123; String language = request.getParameter(&quot;l&quot;); Locale locale = Locale.getDefault(); // 如果没有获取到就使用系统默认的 //如果请求链接不为空 if (!StringUtils.isEmpty(language))&#123; //分割请求参数 String[] split = language.split(&quot;_&quot;); //国家，地区 locale = new Locale(split[0],split[1]); &#125; return locale; &#125; @Override public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) &#123; &#125;&#125; 为了让我们的区域化信息能够生效，我们需要再配置一下这个组件！在我们自己的MvcConofig下添加bean； 1234@Beanpublic LocaleResolver localeResolver()&#123; return new MyLocaleResolver();&#125; 我们重启项目，来访问一下，发现点击按钮可以实现成功切换！搞定收工！ 小结： 页面国际化 配置i18n文件 如果需要在项目中进行按钮自动切换，我们需要自定义一个组件LocaleResolver 将自己写的组件配置到spring容器中----@Bean 14、整合JDBC 14.1、SpringData简介 对于数据访问层，无论是 SQL(关系型数据库) 还是 NOSQL(非关系型数据库)，Spring Boot 底层都是采用 Spring Data 的方式进行统一处理。 Spring Boot 底层都是采用 Spring Data 的方式进行统一处理各种数据库，Spring Data 也是 Spring 中与 Spring Boot、Spring Cloud 等齐名的知名项目。 Sping Data 官网：https://spring.io/projects/spring-data 数据库相关的启动器 ：可以参考官方文档： https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter 14.2、整合JDBC 创建测试项目测试数据源 1、新建一个项目测试：springboot-data-jdbc ; 引入相应的模块！基础模块 2、项目建好之后，发现自动帮我们导入了如下的启动器： 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 3、编写yaml配置文件连接数据库； 12345678spring: datasource: username: root password: root #?serverTimezone=UTC解决时区的报错 url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Driver #新的驱动程序类不推荐使用 com.mysql.jdbc.Driver 驱动程序通过SPI自动注册，通常不需要手动加载驱动程序类。 注意： 新的驱动程序类不推荐使用 com.mysql.jdbc.Driver 驱动程序通过SPI自动注册，通常不需要手动加载驱动程序类。 新的驱动程序类推荐使用 com.mysql.cj.jdbc.Driver 可以不配置，有默认配置 4、配置完这一些东西后，我们就可以直接去使用了，因为SpringBoot已经默认帮我们进行了自动配置；去测试类测试一下 12345678910111213141516171819import javax.sql.DataSource;@SpringBootTestclass SpringbootDataJdbcApplicationTests &#123; //DI注入数据源 @Autowired DataSource dataSource; @Test public void contextLoads() throws SQLException &#123; //看一下默认数据源 System.out.println(dataSource.getClass()); //获得连接 Connection connection = dataSource.getConnection(); System.out.println(connection); //关闭连接 connection.close(); &#125;&#125; 结果：我们可以看到他默认给我们配置的数据源为 : class com.zaxxer.hikari.HikariDataSource ， 我们并没有手动配置 我们来全局搜索一下，找到数据源的所有自动配置都在 ：DataSourceAutoConfiguration文件： 1234567@Import( &#123;Hikari.class, Tomcat.class, Dbcp2.class, Generic.class, DataSourceJmxConfiguration.class&#125;)protected static class PooledDataSourceConfiguration &#123; protected PooledDataSourceConfiguration() &#123; &#125;&#125; 这里导入的类都在 DataSourceConfiguration 配置类下，可以看出 Spring Boot 2.2.5 默认使用HikariDataSource 数据源，而以前版本，如 Spring Boot 1.5 默认使用 org.apache.tomcat.jdbc.pool.DataSource 作为数据源； HikariDataSource 号称 Java WEB 当前速度最快的数据源，相比于传统的 C3P0 、DBCP、Tomcat jdbc 等连接池更加优秀； 可以使用 spring.datasource.type 指定自定义的数据源类型，值为 要使用的连接池实现的完全限定名。 关于数据源我们并不做介绍，有了数据库连接，显然就可以 CRUD 操作数据库了。但是我们需要先了解一个对象 JdbcTemplate JDBCTemplate 1、有了数据源(com.zaxxer.hikari.HikariDataSource)，然后可以拿到数据库连接(java.sql.Connection)，有了连接，就可以使用原生的 JDBC 语句来操作数据库； 2、即使不使用第三方第数据库操作框架，如 MyBatis等，Spring 本身也对原生的JDBC 做了轻量级的封装，即JdbcTemplate。(XXX template是已经配置好的Bean文件拿来即用) 3、数据库操作的所有 CRUD 方法都在 JdbcTemplate 中。 4、Spring Boot 不仅提供了默认的数据源，同时默认已经配置好了 JdbcTemplate 放在了容器中，程序员只需自己注入即可使用 5、JdbcTemplate 的自动配置是依赖 org.springframework.boot.autoconfigure.jdbc 包下的 JdbcTemplateConfiguration 类 JdbcTemplate主要提供以下几类方法： execute方法：可以用于执行任何SQL语句，一般用于执行DDL语句； update方法及batchUpdate方法：update方法用于执行新增、修改、删除等语句；batchUpdate方法用于执行批处理相关语句； query方法及queryForXXX方法：用于执行查询相关语句； call方法：用于执行存储过程、函数相关语句。 测试 编写一个Controller，注入 jdbcTemplate，编写测试方法进行访问测试； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@RestController@RequestMapping(&quot;/jdbc&quot;)public class JdbcController &#123; /** * Spring Boot 默认提供了数据源，默认提供了 org.springframework.jdbc.core.JdbcTemplate * JdbcTemplate 中会自己注入数据源，用于简化 JDBC操作 * 还能避免一些常见的错误,使用起来也不用再自己来关闭数据库连接 */ @Autowired JdbcTemplate jdbcTemplate; //查询employee表中所有数据 //List 中的1个 Map 对应数据库的 1行数据 //Map 中的 key 对应数据库的字段名，value 对应数据库的字段值 @GetMapping(&quot;/list&quot;) public List&lt;Map&lt;String, Object&gt;&gt; userList()&#123; String sql = &quot;select * from employee&quot;; List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(sql); return maps; &#125; //新增一个用户 @GetMapping(&quot;/add&quot;) public String addUser()&#123; //插入语句，注意时间问题 String sql = &quot;insert into employee(last_name, email,gender,department,birth)&quot; + &quot; values (&#x27;狂神说&#x27;,&#x27;24736743@qq.com&#x27;,1,101,&#x27;&quot;+ new Date().toLocaleString() +&quot;&#x27;)&quot;; jdbcTemplate.update(sql); //查询 return &quot;addOk&quot;; &#125; //修改用户信息 @GetMapping(&quot;/update/&#123;id&#125;&quot;) public String updateUser(@PathVariable(&quot;id&quot;) int id)&#123; //插入语句 String sql = &quot;update employee set last_name=?,email=? where id=&quot;+id; //数据 Object[] objects = new Object[2]; objects[0] = &quot;秦疆&quot;; objects[1] = &quot;24736743@sina.com&quot;; jdbcTemplate.update(sql,objects); //查询 return &quot;updateOk&quot;; &#125; //删除用户 @GetMapping(&quot;/delete/&#123;id&#125;&quot;) public String delUser(@PathVariable(&quot;id&quot;) int id)&#123; //插入语句 String sql = &quot;delete from employee where id=?&quot;; jdbcTemplate.update(sql,id); //查询 return &quot;deleteOk&quot;; &#125; &#125; 测试请求，结果正常； 到此，CURD的基本操作，使用 JDBC 就搞定了。 15、整合Druid 15.1、Druid简介 Java程序很大一部分要操作数据库，为了提高性能操作数据库的时候，又不得不使用数据库连接池。 Druid 是阿里巴巴开源平台上一个数据库连接池实现，结合了 C3P0、DBCP 等 DB 池的优点，同时加入了日志监控。 Druid 可以很好的监控 DB 池连接和 SQL 的执行情况，天生就是针对监控而生的 DB 连接池。 Druid已经在阿里巴巴部署了超过600个应用，经过一年多生产环境大规模部署的严苛考验。 Spring Boot 2.0 以上默认使用 Hikari 数据源，可以说 Hikari 与 Driud 都是当前 Java Web 上最优秀的数据源，我们来重点介绍 Spring Boot 如何集成 Druid 数据源，如何实现数据库监控。 Github地址：https://github.com/alibaba/druid/ com.alibaba.druid.pool.DruidDataSource 基本配置参数如下： 配置 缺省值 说明 name 配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。 如果没有配置，将会生成一个名字，格式是：“DataSource-” + System.identityHashCode(this) jdbcUrl 连接数据库的url，不同数据库不一样。例如： mysql : jdbc:mysql://10.20.153.104:3306/druid2 oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto username 连接数据库的用户名 password 连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：https://github.com/alibaba/druid/wiki/使用ConfigFilter driverClassName 根据url自动识别 这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下) initialSize 0 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 maxActive 8 最大连接池数量 maxIdle 8 已经不再使用，配置了也没效果 minIdle 最小连接池数量 maxWait 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。 poolPreparedStatements false 是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。 maxOpenPreparedStatements -1 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100 validationQuery 用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。 testOnBorrow true 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 testOnReturn false 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 testWhileIdle false 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 timeBetweenEvictionRunsMillis 有两个含义： 1) Destroy线程会检测连接的间隔时间2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明 numTestsPerEvictionRun 不再使用，一个DruidDataSource只支持一个EvictionRun minEvictableIdleTimeMillis connectionInitSqls 物理连接初始化的时候执行的sql exceptionSorter 根据dbType自动识别 当数据库抛出一些不可恢复的异常时，抛弃连接 filters 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有： 监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall proxyFilters 类型是List&lt;com.alibaba.druid.filter.Filter&gt;，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系 15.2、配置数据源 1、添加上 Druid 数据源依赖。 123456&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt; 2、切换数据源；之前已经说过 Spring Boot 2.0 以上默认使用 com.zaxxer.hikari.HikariDataSource 数据源，但可以 通过 spring.datasource.type 指定数据源。 1234567spring: datasource: username: root password: 123456 url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource # 自定义数据源 3、数据源切换之后，在测试类中注入 DataSource，然后获取到它，输出一看便知是否成功切换； 4、切换成功！既然切换成功，就可以设置数据源连接初始化大小、最大连接数、等待时间、最小连接数 等设置项；可以查看源码 123456789101112131415161718192021222324252627282930spring: datasource: username: root password: 123456 #?serverTimezone=UTC解决时区的报错 url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource #Spring Boot 默认是不注入这些属性值的，需要自己绑定 #druid 数据源专有配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入 #如果允许时报错 java.lang.ClassNotFoundException: org.apache.log4j.Priority #则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 5、导入Log4j 的依赖 123456&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; 6、现在需要程序员自己为 DruidDataSource 绑定全局配置文件中的参数，再添加到容器中，而不再使用 Spring Boot 的自动生成了；我们需要 自己添加 DruidDataSource 组件到容器中，并绑定属性； 1234567891011121314@Configurationpublic class DruidConfig &#123; /* 将自定义的 Druid数据源添加到容器中，不再让 Spring Boot 自动创建 绑定全局配置文件中的 druid 数据源属性到 com.alibaba.druid.pool.DruidDataSource从而让它们生效 @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)：作用就是将 全局配置文件中 前缀为 spring.datasource的属性值注入到 com.alibaba.druid.pool.DruidDataSource 的同名参数中 */ @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) @Bean public DataSource druidDataSource() &#123; return new DruidDataSource(); &#125;&#125; 7、去测试类中测试一下；看是否成功！ 1234567891011121314151617181920212223@SpringBootTestclass SpringbootDataJdbcApplicationTests &#123; //DI注入数据源 @Autowired DataSource dataSource; @Test public void contextLoads() throws SQLException &#123; //看一下默认数据源 System.out.println(dataSource.getClass()); //获得连接 Connection connection = dataSource.getConnection(); System.out.println(connection); DruidDataSource druidDataSource = (DruidDataSource) dataSource; System.out.println(&quot;druidDataSource 数据源最大连接数：&quot; + druidDataSource.getMaxActive()); System.out.println(&quot;druidDataSource 数据源初始化连接数：&quot; + druidDataSource.getInitialSize()); //关闭连接 connection.close(); &#125;&#125; 输出结果 ：可见配置参数已经生效！ 15.3、配置Druid数据源监控 Druid 数据源具有监控的功能，并提供了一个 web 界面方便用户查看，类似安装 路由器 时，人家也提供了一个默认的 web 页面。 所以第一步需要设置 Druid 的后台管理页面，比如 登录账号、密码 等；配置后台管理； DruidConfig.java 123456789101112131415161718192021222324//配置 Druid 监控管理后台的Servlet；//因为springboot内置了Servlet 容器，所以没有web.xml文件，所以使用 SpringBoot 的注册 Servlet 方式@Beanpublic ServletRegistrationBean servletRegistration()&#123; ServletRegistrationBean&lt;StatViewServlet&gt; bean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;);//访问会进入相关路径 // 这些参数可以在 com.alibaba.druid.support.http.StatViewServlet // 的父类 com.alibaba.druid.support.http.ResourceServlet 中找到 Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(&quot;loginUsername&quot;, &quot;admin&quot;); //后台管理界面的登录账号 initParams.put(&quot;loginPassword&quot;, &quot;123456&quot;); //后台管理界面的登录密码 //后台允许谁可以访问 //initParams.put(&quot;allow&quot;, &quot;localhost&quot;)：表示只有本机可以访问 //initParams.put(&quot;allow&quot;, &quot;&quot;)：为空或者为null时，表示允许所有访问 initParams.put(&quot;allow&quot;, &quot;&quot;); //deny：Druid 后台拒绝谁访问 &quot;allow&quot;, &quot;localhost&quot; 允许本地访问 //initParams.put(&quot;kuangshen&quot;, &quot;192.168.1.20&quot;);表示禁止此ip访问 //设置初始化参数 bean.setInitParameters(initParams); return bean;&#125; 配置完毕后，我们可以选择访问 ：http://localhost:8080/druid 进入之后 配置 Druid web 监控 filter 过滤器 12345678910111213141516//配置 Druid 监控 之 web 监控的 filter//WebStatFilter：用于配置Web和Druid数据源之间的管理关联监控统计@Beanpublic FilterRegistrationBean webStatFilter() &#123; FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); //exclusions：设置哪些请求进行过滤排除掉，从而不进行统计 Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(&quot;exclusions&quot;, &quot;*.js,*.css,/druid/*,/jdbc/*&quot;); bean.setInitParameters(initParams); //&quot;/*&quot; 表示过滤所有请求 bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;)); return bean;&#125; 平时在工作中，按需求进行配置即可，主要用作监控！ 16、整合MyBatis 官方文档：http://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/ Maven仓库地址：https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter/2.1.4 16.1、整合测试 1、导入 MyBatis 所需要的依赖 123456789101112131415161718&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.4&lt;/version&gt;&lt;/dependency&gt;&lt;!--德鲁伊--&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt; 2、配置数据库连接信息（不变） 123456789101112131415161718192021222324252627282930spring: datasource: username: root password: root #?serverTimezone=UTC解决时区的报错 url: jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource #Spring Boot 默认是不注入这些属性值的，需要自己绑定 #druid 数据源专有配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入 #如果允许时报错 java.lang.ClassNotFoundException: org.apache.log4j.Priority #则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 3、测试数据库是否连接成功！ 4、创建实体类，导入 Lombok！ 12345678@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private int id; private String name; private String pwd;&#125; 5、创建mapper目录以及对应的 Mapper 接口 123456789101112131415//@Mapper : 表示本类是一个 MyBatis 的 Mapper@Mapper@Repositorypublic interface UserMapper &#123; List&lt;User&gt; queryUserList(); User queryUserById(int id); int addUser(User user); int updateUser(User user); int deleteUser(int id);&#125; 6、对应的Mapper映射文件 select时可以加缓存 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.jiang.mapper.UserMapper&quot;&gt; &lt;select id=&quot;queryUserList&quot; resultType=&quot;User&quot;&gt; select * from user; &lt;/select&gt; &lt;select id=&quot;queryUserById&quot; resultType=&quot;User&quot; parameterType=&quot;int&quot;&gt; select * from user where id = #&#123;id&#125;; &lt;/select&gt; &lt;insert id=&quot;addUser&quot; parameterType=&quot;User&quot;&gt; insert into user(id,name,pwd) values(#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;); &lt;/insert&gt; &lt;update id=&quot;updateUser&quot; parameterType=&quot;User&quot;&gt; update user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id=#&#123;id&#125;; &lt;/update&gt; &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; delete from user where id = #&#123;id&#125;; &lt;/delete&gt;&lt;/mapper&gt; 7、maven配置资源过滤问题 123456789&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt;&lt;/resources&gt; 或者 在yaml中配置 123mybatis: type-aliases-package: com.kuang.pojo #别名的包 mapper-locations: classpath:mybatis/mapper/*.xml #要扫描的包 8、编写Controller 进行测试！ 1234567891011121314151617181920212223242526272829303132@RestControllerpublic class UserController &#123;@Autowired private UserMapper userMapper; @GetMapping(&quot;/queryUserList&quot;) public List&lt;User&gt; queryUserList()&#123; List&lt;User&gt; users = userMapper.queryUserList(); for (User user : users) &#123; System.out.println(user); &#125; return users; &#125; @GetMapping(&quot;/addUser&quot;) public String addUser()&#123; userMapper.addUser(new User(6,&quot;阿毛&quot;,&quot;123456&quot;)); return &quot;ok&quot;; &#125; @GetMapping(&quot;/updateUser&quot;) public String udpateUser()&#123; userMapper.updateUser(new User(6,&quot;阿毛&quot;,&quot;111111&quot;)); return &quot;ok&quot;; &#125; @GetMapping(&quot;/deleteUser&quot;) public String deleteUser()&#123; userMapper.deleteUser(5); return &quot;ok&quot;; &#125;&#125; 启动项目访问进行测试！","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"后端学习","slug":"后端学习","permalink":"http://example.com/tags/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"狂神说SpringMVC","slug":"狂神说SpringMVC","date":"2021-03-31T04:58:10.000Z","updated":"2021-04-02T07:21:42.222Z","comments":true,"path":"2021/03/31/狂神说SpringMVC/","link":"","permalink":"http://example.com/2021/03/31/%E7%8B%82%E7%A5%9E%E8%AF%B4SpringMVC/","excerpt":"","text":"1、回顾MVC 1.1、什么是MVC MVC是模型(Model)dao service、视图(View)JSP、控制器(Controller) servlet的简写，是一种软件设计规范。 是将业务逻辑、数据、显示分离的方法来组织代码。 MVC主要作用是降低了视图与业务逻辑间的双向偶合。 MVC不是一种设计模式，MVC是一种架构模式。当然不同的MVC存在差异。 Model（模型）： 数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。 View（视图）：负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。 Controller（控制器）：接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作。 最典型的MVC就是JSP + servlet + javabean的模式。 1.2、Model1时代 在web早期的开发中，通常采用的都是Model1。 Model1中，主要分为两层，视图层和模型层。 Model1优点：架构简单，比较适合小型项目开发； Model1缺点：JSP职责不单一，职责过重，不便于维护； 1.3、Model2时代 Model2把一个项目分成三部分，包括视图、控制、模型。 用户发请求 Servlet接收请求数据，并调用对应的业务逻辑方法 业务处理完毕，返回更新后的数据给servlet servlet转向到JSP，由JSP来渲染页面 响应给前端更新后的页面 职责分析： Controller：控制器 取得表单数据 调用业务逻辑 转向指定的页面 Model：模型 业务逻辑 保存数据的状态 View：视图 显示页面 Model2这样不仅提高的代码的复用率与项目的扩展性，且大大降低了项目的维护成本。Model 1模式的实现比较简单，适用于快速开发小规模项目，Model1中JSP页面身兼View和Controller两种角色，将控制逻辑和表现逻辑混杂在一起，从而导致代码的重用性非常低，增加了应用的扩展性和维护的难度。Model2消除了Model1的缺点。 1.4、回顾Servlet 新建一个Maven工程当做父工程！pom依赖！ 123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 建立一个Moudle：springmvc-01-servlet ， 添加Web app的支持！ 导入servlet 和 jsp 的 jar 依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt;&lt;/dependency&gt; 编写一个Servlet类，用来处理用户的请求 123456789101112131415161718192021222324package nuc.ss.servlet;//实现Servlet接口public class HelloServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //取得参数 String method = req.getParameter(&quot;method&quot;); if (method.equals(&quot;add&quot;))&#123; req.getSession().setAttribute(&quot;msg&quot;,&quot;执行了add方法&quot;); &#125; if (method.equals(&quot;delete&quot;))&#123; req.getSession().setAttribute(&quot;msg&quot;,&quot;执行了delete方法&quot;); &#125; //业务逻辑 //视图跳转 安全页面web-inf下 公共页面web下面 转发后继续携带参数 req.getRequestDispatcher(&quot;/WEB-INF/jsp/hello.jsp&quot;).forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req,resp); &#125;&#125; 编写Hello.jsp，在WEB-INF目录下新建一个jsp的文件夹，新建hello.jsp 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Kuangshen&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 在web.xml中注册Servlet 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.kuang.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/user&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 配置Tomcat，并启动测试 localhost:8080/user?method=add localhost:8080/user?method=delete MVC框架要做哪些事情 将url映射到java类或java类的方法 . 封装用户提交的数据 . 处理请求–调用相关的业务处理–封装响应数据 . 将响应的数据进行渲染 . jsp / html 等表示层数据 . 说明： 常见的服务器端MVC框架有：Struts、Spring MVC、ASP.NET MVC、Zend Framework、JSF；常见前端MVC框架：vue、angularjs、react、backbone；由MVC演化出了另外一些模式如：MVP、MVVM 等等… 2、什么是SpringMVC 2.1、概述 Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。 查看官方文档：https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/web.html#spring-web 我们为什么要学习SpringMVC呢? Spring MVC的特点： 轻量级，简单易学 高效 , 基于请求响应的MVC框架 与Spring兼容性好，无缝结合 约定优于配置 ----------唯一花样，研究底层 功能强大：RESTful、数据验证、格式化、本地化、主题等 简洁灵活 Spring的web框架围绕DispatcherServlet [ 调度Servlet ] 设计。 DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解形式进行开发，十分简洁； 正因为SpringMVC好 , 简单 , 便捷 , 易学 , 天生和Spring无缝集成(使用SpringIoC和Aop) , 使用约定优于配置 . 能够进行简单的junit测试 . 支持Restful风格 .异常处理 , 本地化 , 国际化 , 数据验证 , 类型转换 , 拦截器 等等…所以我们要学习 . 最重要的一点还是用的人多 , 使用的公司多 . 2.2、中心控制器 Spring的web框架围绕DispatcherServlet设计。**DispatcherServlet的作用是将请求分发到不同的处理器。**从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解的controller声明方式。 Spring MVC框架像许多其他MVC框架一样, 以请求为驱动 , 围绕一个中心Servlet分派请求及提供其他功能，DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)。 SpringMVC的原理如下图所示： 当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。 原图 中文图 2.3、SpringMVC执行原理 图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现 3和6 简要分析执行流程 DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。 我们假设请求的url为 : http://localhost:8080/SpringMVC/hello 如上url拆分成三部分： http://localhost:8080 ------&gt; 服务器域名 SpringMVC ------&gt; 部署在服务器上的web站点 hello ------&gt; 表示控制器 通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。 HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。 HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。 HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。 HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。 Handler让具体的Controller执行。 Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。 HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。 DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。 视图解析器将解析的逻辑视图名传给DispatcherServlet。 DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。 最终视图呈现给用户。 3、第一个MVC程序 3.1、配置版 前提jar包导入 新建一个Moudle ， springmvc-02-hello ， 添加web的支持！ 确定导入了SpringMVC 的依赖！ 配置web.xml ， 注册DispatcherServlet 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--1.注册DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--启动级别-1 服务器启动就启动--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--/ 匹配所有的请求；（不包括.jsp）--&gt; &lt;!--/* 匹配所有的请求；（包括.jsp）--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 编写SpringMVC 的 配置文件！名称：springmvc-servlet.xml : [servletname]-servlet.xml 说明，这里的名称要求是按照官方来的 4-7结合配置三大 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt; 添加 处理映射器（可省略） 1&lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt; 添加 处理器适配器（可省略） 1&lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt; 添加 视图解析器 123456789101112&lt;!--视图解析器:DispatcherServlet给他的ModelAndView 1.获取了ModelAndView的数据 2.解析ModeAndView的视图名字 3.拼接视图名字，找到对应视图 /WEB-INF/jsp/hello.jsp 4.将数据渲染到这个视图上 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;InternalResourceViewResolver&quot;&gt; &lt;!--前缀--&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;!--后缀--&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt; 编写我们要操作业务Controller ，要么实现Controller接口，要么增加注解；需要返回一个ModelAndView，装数据，封视图； 12345678910111213141516171819202122232425package nuc.ss.controller;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;//注意：这里我们先导入Controller接口，还有一个注解public class HelloController implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; //ModelAndView 模型和视图 ModelAndView mv = new ModelAndView();//----------------业务代码 //封装对象，放在ModelAndView中。Model mv.addObject(&quot;msg&quot;,&quot;HelloSpringMVC!&quot;);//（msg,objet）msg存放业务数据，object可以存任何 //封装要跳转的视图，放在ModelAndView中 mv.setViewName(&quot;hello&quot;); //: /WEB-INF/jsp/hello.jsp //第一行和最后一行固定 return mv; &#125;&#125; 将自己的类交给SpringIOC容器，注册bean .BeanNameUrlHandlerMapping要求我们要一个bean 123&lt;!--Handler--&gt;&lt;bean id=&quot;/hello&quot; class=&quot;nuc.ss.controller.HelloController&quot;/&gt; 写要跳转的jsp页面，显示ModelandView存放的数据，以及我们的正常页面； 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Kuangshen&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 配置Tomcat 启动测试！ 总结： 可能遇到的问题：访问出现404，排查步骤： 查看控制台输出，看一下是不是缺少了什么jar包。 如果jar包存在，显示无法输出，就在IDEA的项目发布中，添加lib依赖！ IDEA的硬伤 重启Tomcat 即可解决！ 小结：我们来看个注解版实现，这才是SpringMVC的精髓。 3.2、注解版 新建一个Moudle，springmvc-03-hello-annotation 。添加web支持！ 由于Maven可能存在资源过滤的问题，我们将配置完善 1234567891011121314151617181920&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 在pom.xml文件引入相关的依赖：主要有Spring框架核心库、Spring MVC、servlet , JSTL等。我们在父依赖中已经引入了！ 配置web.xml 注意点： 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--1.注册servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动顺序，数字越小，启动越早 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--所有请求都会被springmvc拦截 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; / 和 /* 的区别： &lt; url-pattern &gt; / &lt;/ url-pattern &gt; 不会匹配到.jsp， 只针对我们编写的请求；即：.jsp 不会进入spring的 DispatcherServlet类 。 &lt; url-pattern &gt; /* &lt;/ url-pattern &gt; 会匹配 *.jsp，会出现返回 jsp视图 时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错。 添加Spring MVC配置文件 在resource目录下添加springmvc-servlet.xml配置文件，配置的形式与Spring容器配置基本类似，为了支持基于注解的IOC，设置了自动扫描包的功能，具体配置信息如下： 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt; &lt;context:component-scan base-package=&quot;nuc.ss.controller&quot;/&gt; &lt;!-- 让Spring MVC不处理静态资源 过滤 .css,.js .html--&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!-- 支持mvc注解驱动 在spring中一般采用@RequestMapping注解来完成映射关系 要想使@RequestMapping注解生效 必须向上下文中注册DefaultAnnotationHandlerMapping 和一个AnnotationMethodHandlerAdapter实例 这两个实例分别在类级别和方法级别处理。 而annotation-driven配置帮助我们自动完成上述两个实例的注入。 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;!-- 后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 在视图解析器中我们把所有的视图都存放在/WEB-INF/目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问。 让IOC的注解生效 静态资源过滤 ：HTML . JS . CSS . 图片 ， 视频 … MVC的注解驱动 配置视图解析器 创建Controller 编写一个Java控制类：nuc.ss.controller.HelloController , 注意编码规范 12345678910111213141516171819package nuc.ss.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping(&quot;/HelloController&quot;)public class HelloController &#123; //真实访问地址 : 项目名/hello加了@RequestMapping(&quot;/HelloController&quot;)变为/HelloController/hello @RequestMapping(&quot;/hello&quot;) public String sayHello(Model model)&#123; //向模型中添加属性msg与值，可以在JSP页面中取出并渲染 model.addAttribute(&quot;msg&quot;,&quot;hello,SpringMVC&quot;); //web-inf/jsp/hello.jsp return &quot;hello&quot;; &#125;&#125; @Controller是为了让Spring IOC容器初始化时自动扫描到； @RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是/HelloController/hello； 方法中声明Model类型的参数是为了把Action中的数据带到视图中； 方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF/jsp/hello.jsp 创建视图层 在WEB-INF/ jsp目录中创建hello.jsp ， 视图可以直接取出并展示从Controller带回的信息； 可以通过EL表示取出Model中存放的值，或者对象； 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;SpringMVC&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 配置Tomcat运行 配置Tomcat ， 开启服务器 ， 访问 对应的请求路径！ OK，运行成功！ 小结 实现步骤其实非常的简单： 新建一个web项目 导入相关jar包 编写web.xml , 注册DispatcherServlet 编写springmvc配置文件 接下来就是去创建对应的控制类 , controller 最后完善前端视图和controller之间的对应 测试运行调试. 使用springMVC必须配置的三大件 处理器映射器、处理器适配器、视图解析器 通常，我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可，而省去了大段的xml配置 4、RestFul和控制器 4.1、控制器Controller 控制器复杂提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。 控制器负责解析用户的请求并将其转换为一个模型。 在Spring MVC中一个控制器类可以包含多个方法 在Spring MVC中，对于Controller的配置方式有很多种 4.2、实现Controller接口 Controller是一个接口，在org.springframework.web.servlet.mvc包下，接口中只有一个方法； 12345//实现该接口的类获得控制器功能public interface Controller &#123; //处理请求且返回一个模型与视图对象 ModelAndView handleRequest(HttpServletRequest var1, HttpServletResponse var2) throws Exception;&#125; 测试 新建一个Moudle，springmvc-04-controller！ mvc的配置文件只留下 视图解析器！ 编写一个Controller类不要导错包，ControllerTest1 123456789101112131415//定义控制器//注意点：不要导错包，实现Controller接口，重写方法；import org.springframework.web.servlet.mvc.Controller;public class ControllerTest1 implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(&quot;msg&quot;,&quot;Test1Controller&quot;); mv.setViewName(&quot;test&quot;); return mv; &#125;&#125; 编写完毕后，去Spring配置文件中注册请求的bean；name对应请求路径，class对应处理请求的类 12&lt;bean name=&quot;/t1&quot; class=&quot;nuc.ss.controller.ControllerTest1&quot;/&gt; 编写前端test.jsp，注意在WEB-INF/jsp目录下编写，对应我们的视图解析器 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Kuangshen&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 配置Tomcat运行测试，我这里没有项目发布名配置的就是一个 / ，所以请求不用加项目名，OK！ 说明： 实现接口Controller定义控制器是较老的办法 缺点是：一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller；定义的方式比较麻烦； 使用注解@Controller @Controller注解类型用于声明Spring类的实例是一个控制器（在讲IOC时还提到了另外3个注解）； @Component 组件 @Service services @Controller controller @Repository dao 12345678 - Spring可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证Spring能找到你的控制器，需要在配置文件中声明组件扫描。 &#96;&#96;&#96;xml &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt; &lt;context:component-scan base-package&#x3D;&quot;nuc.ss.controller&quot;&#x2F;&gt; 增加一个ControllerTest2类，使用注解实现； 1234567891011121314//@Controller注解的类会自动添加到Spring上下文中//代表会被spring接管，这个类所有返回是String的方法，并且返回页面会跳转会被解析器尝试解析@Controllerpublic class ControllerTest2&#123; //映射访问路径 @RequestMapping(&quot;/t2&quot;) public String index(Model model)&#123; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(&quot;msg&quot;, &quot;ControllerTest2&quot;); //返回视图位置 return &quot;test&quot;; &#125;&#125; 运行tomcat测试 可以发现，我们的两个请求都可以指向一个视图(test)，但是页面结果的结果是不一样的，从这里可以看出视图是被复用的，而控制器与视图之间是弱偶合关系。 注解方式是平时使用的最多的方式！ RequestMapping @RequestMapping @RequestMapping**注解用于映射url到控制器类或一个特定的处理程序方法。**可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。 为了测试结论更加准确，我们可以加上一个项目名测试 myweb 只注解在方法上面 1234567@Controllerpublic class TestController &#123; @RequestMapping(&quot;/h1&quot;) public String test()&#123; return &quot;test&quot;; &#125;&#125; 访问路径：http://localhost:8080 / 项目名 / h1 同时注解类与方法 12345678@Controller@RequestMapping(&quot;/admin&quot;)public class TestController &#123; @RequestMapping(&quot;/h1&quot;) public String test()&#123; return &quot;test&quot;;//用于拼接 &#125;&#125; 访问路径：http://localhost:8080 / 项目名/ admin /h1 , 需要先指定类的路径再指定方法的路径； RestFul 风格 概念 Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。 功能 资源：互联网所有的事物都可以被抽象为资源 资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。 分别对应 添加、 删除、修改、查询。 传统方式操作资源 ：通过不同的参数来实现不同的效果！方法单一，post 和 get http://127.0.0.1/item/queryItem.action?id=1 查询,GET http://127.0.0.1/item/saveItem.action 新增,POST http://127.0.0.1/item/updateItem.action 更新,POST http://127.0.0.1/item/deleteItem.action?id=1 删除,GET或POST 使用RESTful操作资源 ：可以通过不同的请求方式来实现不同的效果！如下：甚至请求地址一样，但是功能可以不同！ http://127.0.0.1/item/1 查询,GET http://127.0.0.1/item 新增,POST http://127.0.0.1/item 更新,PUT http://127.0.0.1/item/1 删除,DELETE 学习测试 在新建一个类 RestFulController 12@Controllerpublic class RestFulController &#123;&#125; 在Spring MVC中可以使用 @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上。 123456789101112131415@Controllerpublic class RestFulController &#123; //映射访问路径 @RequestMapping(&quot;/add/&#123;p1&#125;/&#123;p2&#125;&quot;) public String index(@PathVariable int p1, @PathVariable int p2, Model model)&#123; int result = p1+p2; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(&quot;msg&quot;, &quot;结果：&quot;+result); //返回视图位置 return &quot;test&quot;; &#125;&#125; 我们来测试请求查看下 思考：使用路径变量的好处？ 使路径变得更加简洁； 获得参数更加方便，框架会自动进行类型转换。 通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是/add/1/a，则路径与方法不匹配，而不会是参数转换失败。 我们来修改下对应的参数类型，再次测试 1234567891011//映射访问路径@RequestMapping(&quot;/add/&#123;p1&#125;/&#123;p2&#125;&quot;)public String index(@PathVariable int p1, @PathVariable String p2, Model model)&#123; String result = p1+p2; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(&quot;msg&quot;, &quot;结果：&quot;+result); //返回视图位置 return &quot;test&quot;;&#125; 、 使用method属性指定请求类型 用于约束请求的类型，可以收窄请求范围**（默认是Get）**。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE等 我们来测试一下： 增加一个方法 123456//映射访问路径,必须是POST请求@RequestMapping(value = &quot;/hello&quot;,method = &#123;RequestMethod.POST&#125;)public String index2(Model model)&#123; model.addAttribute(&quot;msg&quot;, &quot;hello!&quot;); return &quot;test&quot;;&#125; 我们使用浏览器地址栏进行访问默认是Get请求，会报错405： 将POST修改正常； 123456789101112//映射访问路径,必须是Get请求@RequestMapping(value = &quot;/hello&quot;,method = &#123;RequestMethod.GET&#125;)public String index2(Model model)&#123; model.addAttribute(&quot;msg&quot;, &quot;hello!&quot;); return &quot;test&quot;;&#125;@PostMapping(value = &quot;/hello&quot;)public String index2(Model model)&#123; model.addAttribute(&quot;msg&quot;, &quot;hello!&quot;); return &quot;test&quot;;&#125;//不同提交方式，实现同一个路径的多重访问 小结： Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。 所有的地址栏请求默认都会是 HTTP GET 类型的。 方法级别的注解变体有如下几个：组合注解 12345@GetMapping@PostMapping@PutMapping@DeleteMapping@PatchMapping @GetMapping 是一个组合注解，平时使用的会比较多！ 它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式。 扩展：小黄鸭调试法 场景一：我们都有过向别人（甚至可能向完全不会编程的人）提问及解释编程问题的经历，但是很多时候就在我们解释的过程中自己却想到了问题的解决方案，然后对方却一脸茫然。 场景二：你的同行跑来问你一个问题，但是当他自己把问题说完，或说到一半的时候就想出答案走了，留下一脸茫然的你。 其实上面两种场景现象就是所谓的小黄鸭调试法（Rubber Duck Debuging），又称橡皮鸭调试法，它是我们软件工程中最常使用调试方法之一。 此概念据说来自《程序员修炼之道》书中的一个故事，传说程序大师随身携带一只小黄鸭，在调试代码的时候会在桌上放上这只小黄鸭，然后详细地向鸭子解释每行代码，然后很快就将问题定位修复了。 5、结果跳转方式(视图解析器) 5.1、ModelAndView 设置ModelAndView对象 , 根据view的名称 , 和视图解析器跳到指定的页面 . 页面 : {视图解析器前缀} + viewName +{视图解析器后缀} 12345678&lt;!-- 视图解析器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;!-- 后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;&lt;/bean&gt; 对应的controller类 12345678910public class ControllerTest1 implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;); mv.setViewName(&quot;test&quot;); return mv; &#125;&#125; 5.2、ServletAPI ServletAPI 通过设置ServletAPI , 不需要视图解析器 . 通过HttpServletResponse进行输出 通过HttpServletResponse实现重定向 通过HttpServletResponse实现转发 123456789101112131415161718192021@Controllerpublic class ResultGo &#123; @RequestMapping(&quot;/result/t1&quot;) public void test1(HttpServletRequest req, HttpServletResponse rsp) throws IOException &#123; rsp.getWriter().println(&quot;Hello,Spring BY servlet API&quot;); &#125; @RequestMapping(&quot;/result/t2&quot;) public void test2(HttpServletRequest req, HttpServletResponse rsp) throws IOException &#123; rsp.sendRedirect(&quot;/index.jsp&quot;); &#125; @RequestMapping(&quot;/result/t3&quot;) public void test3(HttpServletRequest req, HttpServletResponse rsp) throws Exception &#123; //转发 req.setAttribute(&quot;msg&quot;,&quot;/result/t3&quot;); req.getRequestDispatcher(&quot;/WEB-INF/jsp/test.jsp&quot;).forward(req,rsp); &#125;&#125; 5.3、SpringMVC 通过SpringMVC来实现转发和重定向 - 无需视图解析器 测试前，需要将视图解析器注释掉 默认为forward转发（也可以加上） redirect转发需特别加 1234567891011121314151617181920@Controllerpublic class ResultSpringMVC &#123; @RequestMapping(&quot;/rsm/t1&quot;) public String test1()&#123; //转发 return &quot;/index.jsp&quot;; &#125; @RequestMapping(&quot;/rsm/t2&quot;) public String test2()&#123; //转发二 return &quot;forward:/index.jsp&quot;; &#125; @RequestMapping(&quot;/rsm/t3&quot;) public String test3()&#123; //重定向 return &quot;redirect:/index.jsp&quot;; &#125;&#125; **通过SpringMVC来实现转发和重定向 - ** 有视图解析器； 重定向 , 不需要视图解析器 , 本质就是重新请求一个新地方嘛 , 所以注意路径问题. 可以重定向到另外一个请求实现 . 默认为forward转发（不可以加上） redirect转发需特别加 123456789101112131415@Controllerpublic class ResultSpringMVC2 &#123; @RequestMapping(&quot;/rsm2/t1&quot;) public String test1()&#123; //转发 return &quot;test&quot;; &#125; @RequestMapping(&quot;/rsm2/t2&quot;) public String test2()&#123; //重定向 return &quot;redirect:/index&quot;;//视频有错误 //return &quot;redirect:hello.do&quot;; //hello.do为另一个请求/ &#125;&#125; 6、数据处理 6.1、处理提交数据 1、提交的域名称和处理方法的参数名一致 提交数据 : http://localhost:8080/hello?name=kuangshen 处理方法 : 12345@RequestMapping(&quot;/hello&quot;)public String hello(String name)&#123; System.out.println(name); return &quot;hello&quot;;&#125; 后台输出 : kuangshen 2、提交的域名称和处理方法的参数名不一致 提交数据 : http://localhost:8080/hello?username=kuangshen 处理方法 : 1234567//非RestFul风格可以直接 //localhost:8080/user/t1?name=xxx//@RequestParam(&quot;username&quot;) : username提交的域的名称 .@RequestMapping(&quot;/hello&quot;)public String hello(@RequestParam(&quot;username&quot;) String name)&#123; System.out.println(name); return &quot;hello&quot;;&#125; 后台输出 : kuangshen 3、提交的是一个对象 要求提交的表单域和对象的属性名一致 , 参数使用对象即可 实体类 12345678public class User &#123; private int id; private String name; private int age; //构造 //get/set //tostring()&#125; 提交数据 : http://localhost:8080/mvc04/user?name=kuangshen&amp;id=1&amp;age=15 处理方法 : 12345@RequestMapping(&quot;/user&quot;)public String user(User user)&#123; System.out.println(user); return &quot;hello&quot;;&#125; 后台输出 : User { id=1, name=‘kuangshen’, age=15 } 说明：如果使用对象的话，前端传递的参数名和对象名必须一致，否则就是null。 6.2、数据显示到前端 第一种 : 通过ModelAndView 我们前面一直都是如此 . 就不过多解释 12345678910public class ControllerTest1 implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;); mv.setViewName(&quot;test&quot;); return mv; &#125;&#125; 第二种 : 通过ModelMap ModelMap 12345678@RequestMapping(&quot;/hello&quot;)public String hello(@RequestParam(&quot;username&quot;) String name, ModelMap modelMap)&#123; //封装要显示到视图中的数据 //相当于req.setAttribute(&quot;name&quot;,name); modelMap.addAttribute(&quot;name&quot;,name); System.out.println(name); return &quot;hello&quot;;&#125; 第三种 : 通过Model Model 12345678@RequestMapping(&quot;/ct2/hello&quot;)public String hello(@RequestParam(&quot;username&quot;) String name, Model model)&#123; //封装要显示到视图中的数据 //相当于req.setAttribute(&quot;name&quot;,name); model.addAttribute(&quot;msg&quot;,name); System.out.println(name); return &quot;test&quot;;&#125; 6.3、对比 就对于新手而言简单来说使用区别就是： 123Model 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解；ModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性；ModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。 当然更多的以后开发考虑的更多的是性能和优化，就不能单单仅限于此的了解。 请使用80%的时间打好扎实的基础，剩下18%的时间研究框架，2%的时间去学点英文，框架的官方文档永远是最好的教程。 7、乱码问题 双tomcat的form提交 测试步骤： 我们可以在首页编写一个提交的表单 form.xml(和web.xml平级的文件) 1234&lt;form action=&quot;/e/t&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 后台编写对应的处理类 12345678@Controllerpublic class Encoding &#123; @RequestMapping(&quot;/e/t1&quot;) public String test(Model model,String name)&#123; model.addAttribute(&quot;msg&quot;,name); //获取表单提交的值 return &quot;test&quot;; //跳转到test页面显示输入的值 &#125;&#125; 输入中文测试，发现乱码 不得不说，乱码问题是在我们开发中十分常见的问题，也是让我们程序猿比较头大的问题！ post请求的乱码来自提交过程 以前乱码问题通过过滤器解决 , 而SpringMVC给我们提供了一个过滤器 , 可以在web.xml中配置 . 修改了xml文件需要重启服务器！ 123456789101112&lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 注意：这里写/*，写/的话过滤不了jsp页面，不能解决乱码 但是我们发现 , 有些极端情况下.这个过滤器对get的支持不好 . 处理方法 : 修改tomcat配置文件 ：设置编码！ 123&lt;Connector URIEncoding=&quot;utf-8&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 自定义过滤器（万能解决） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package com.kuang.filter;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.util.Map;/*** 解决get和post请求 全部乱码的过滤器*/public class GenericEncodingFilter implements Filter &#123; @Override public void destroy() &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; //处理response的字符编码 HttpServletResponse myResponse=(HttpServletResponse) response; myResponse.setContentType(&quot;text/html;charset=UTF-8&quot;); // 转型为与协议相关对象 HttpServletRequest httpServletRequest = (HttpServletRequest) request; // 对request包装增强 HttpServletRequest myrequest = new MyRequest(httpServletRequest); chain.doFilter(myrequest, response); &#125; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125;&#125;//自定义request对象，HttpServletRequest的包装类class MyRequest extends HttpServletRequestWrapper &#123; private HttpServletRequest request; //是否编码的标记 private boolean hasEncode; //定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰 public MyRequest(HttpServletRequest request) &#123; super(request);// super必须写 this.request = request; &#125; // 对需要增强方法 进行覆盖 @Override public Map getParameterMap() &#123; // 先获得请求方式 String method = request.getMethod(); if (method.equalsIgnoreCase(&quot;post&quot;)) &#123; // post请求 try &#123; // 处理post乱码 request.setCharacterEncoding(&quot;utf-8&quot;); return request.getParameterMap(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; else if (method.equalsIgnoreCase(&quot;get&quot;)) &#123; // get请求 Map&lt;String, String[]&gt; parameterMap = request.getParameterMap(); if (!hasEncode) &#123; // 确保get手动编码逻辑只运行一次 for (String parameterName : parameterMap.keySet()) &#123; String[] values = parameterMap.get(parameterName); if (values != null) &#123; for (int i = 0; i &lt; values.length; i++) &#123; try &#123; // 处理get乱码 values[i] = new String(values[i] .getBytes(&quot;ISO-8859-1&quot;), &quot;utf-8&quot;); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; hasEncode = true; &#125; return parameterMap; &#125; return super.getParameterMap(); &#125; //取一个值 @Override public String getParameter(String name) &#123; Map&lt;String, String[]&gt; parameterMap = getParameterMap(); String[] values = parameterMap.get(name); if (values == null) &#123; return null; &#125; return values[0]; // 取回参数的第一个值 &#125; //取所有值 @Override public String[] getParameterValues(String name) &#123; Map&lt;String, String[]&gt; parameterMap = getParameterMap(); String[] values = parameterMap.get(name); return values; &#125;&#125; 一般情况下，SpringMVC默认的乱码处理就已经能够很好的解决了！ 然后在web.xml中配置这个过滤器即可！ 乱码问题，需要平时多注意，在尽可能能设置编码的地方，都设置为统一编码 UTF-8！ 8、Json交互处理 8.1、什么是JSON？ JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。 采用完全独立于编程语言的文本格式来存储和表示数据。 简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式： 对象表示为键值对，数据由逗号分隔 花括号保存对象 方括号保存数组 JSON 键值对是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值： 1&#123;&quot;name&quot;:&quot;江志健&quot;,&quot;age&quot;:20,&quot;sex&quot;:&quot;男&quot;&#125; 很多人搞不清楚 JSON 和 JavaScript 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解： JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。 12var obj = &#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125;; //这是一个对象，注意键名也是可以使用引号包裹的var json = &#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;; //这是一个 JSON 字符串，本质是一个字符串 8.2、JSON 和 JavaScript 对象互转 要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法： 12var obj = JSON.parse(&#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;);//结果是 &#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125; 要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法： 12var json = JSON.stringify(&#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125;);//结果是 &#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27; 代码测试 新建一个module ，springmvc-05-json ， 添加web的支持 在web目录下新建一个 json-1.html ， 编写测试内容 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JSON_秦疆&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt; //编写一个js的对象 var user = &#123; name:&quot;秦疆&quot;, age:3, sex:&quot;男&quot; &#125;; //将js对象转换成json字符串 var str = JSON.stringify(user); console.log(str); //将json字符串转换为js对象 var user2 = JSON.parse(str); console.log(user2.age,user2.name,user2.sex);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在IDEA中使用浏览器打开，查看控制台输出！ 8.3、Controller返回JSON数据 Jackson应该是目前比较好的json解析工具了 当然工具不止这一个，比如还有阿里巴巴的 fastjson 等等。 我们这里使用Jackson，使用它需要导入它的jar包； 12345678&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置SpringMVC需要的配置 （web.xml） 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--1.注册servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动顺序，数字越小，启动越早 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--所有请求都会被springmvc拦截 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; springmvc-servlet.xml 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt; &lt;context:component-scan base-package=&quot;com.kuang.controller&quot;/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;!-- 后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 我们随便编写一个User的实体类，然后我们去编写我们的测试Controller； 12345678@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private int id; private String name; private int age;&#125; 这里我们需要两个新东西，一个是@ResponseBody，一个是ObjectMapper对象，我们看下具体的用法 编写一个Controller； 12345678910111213@Controllerpublic class UserController &#123;@RequestMapping(&quot;/j1&quot;) @ResponseBody//他就不会走视图解析器，会直接返回一个字符串 public String json1() throws JsonProcessingException &#123; //jackson.ObjectMapper ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(1, &quot;秦疆一号&quot;, 12); //System.out.println(user); String str = mapper.writeValueAsString(user); return str; &#125; 此时输入中文会产生乱码 12//produces:指定响应体返回类型和编码@RequestMapping(value = &quot;/j1&quot;,produces = &quot;application/json;charset=utf-8&quot;) 配置Tomcat ， 启动测试一下！http://localhost:8080/j1 【注意：使用json记得处理乱码问题】 8.4代码优化 json乱码统一解决 上一种方法比较麻烦，如果项目中有许多请求则每一个都要添加，可以通过Spring配置统一指定，这样就不用每次都去处理了！ 我们可以在springmvc的配置文件上添加一段消息StringHttpMessageConverter转换配置！ 1234567891011121314&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;constructor-arg value=&quot;UTF-8&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt; &lt;property name=&quot;objectMapper&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt; &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; 返回json字符串统一解决 @ResponseBody解决（**每个方法都得加，**不建议使用） 12345678910111213141516@Controllerpublic class UserController &#123; //produces:指定响应体返回类型和编码 @RequestMapping(value = &quot;/json1&quot;) @ResponseBody public String json1() throws JsonProcessingException &#123; //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(1, &quot;秦疆一号&quot;, 12); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便 return str; &#125;&#125; @RestController（直接加到类上即可） 12345678910111213@RestControllerpublic class UserController &#123; @RequestMapping(value = &quot;/j1&quot;) public String json1() throws JsonProcessingException &#123; //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(1, &quot;秦疆一号&quot;, 12); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); return str; &#125;&#125; 8.5、测试集合输出 增加一个新的方法 123456789101112131415161718192021@RequestMapping(&quot;/j2&quot;)public String json2() throws JsonProcessingException &#123; //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user1 = new User(1, &quot;秦疆1号&quot;, 12); User user2 = new User(2, &quot;秦疆2号&quot;, 12); User user3 = new User(3, &quot;秦疆3号&quot;, 12); User user4 = new User(4, &quot;秦疆4号&quot;, 12); User user5 = new User(5, &quot;秦疆5号&quot;, 12); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); list.add(user5); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(list); return str;&#125; 运行结果 : 十分完美，没有任何问题！ 8.6、输出时间对象 增加一个新的方法 1234567891011@RequestMapping(&quot;/j3&quot;)public String json3() throws JsonProcessingException &#123; ObjectMapper mapper = new ObjectMapper(); //创建时间一个对象，java.util.Date Date date = new Date(); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(date); return str;&#125; 运行结果 : 默认日期格式会变成一个数字，是1970年1月1日到当前日期的毫秒数！ Jackson 默认是会把时间转成timestamps形式 解决方案：取消timestamps形式 ， 自定义时间格式 1234567891011121314151617@RequestMapping(&quot;/j3&quot;)public String json4() throws JsonProcessingException &#123; ObjectMapper mapper = new ObjectMapper(); //不使用时间戳的方式 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义日期格式对象 SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); //指定日期格式 mapper.setDateFormat(sdf); Date date = new Date(); String str = mapper.writeValueAsString(date); return str;&#125; 运行结果 : 成功的输出了时间！ 抽取为工具类 如果要经常使用的话，这样是比较麻烦的，我们可以将这些代码封装到一个工具类中；我们去编写下 12345678910111213141516171819202122public class JsonUtils &#123; public static String getJson(Object object) &#123; return getJson(object,&quot;yyyy-MM-dd HH:mm:ss&quot;); //重载，代码复用 &#125; public static String getJson(Object object, String dateFormat) &#123; ObjectMapper mapper = new ObjectMapper(); //java自定义日期格式 SimpleDateFormat sdf = new SimpleDateFormat(dateFormat); //sdf.format(date) // 使用ObjectMapper 来格式化输出 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS,false); mapper.setDateFormat(sdf); try &#123; //ObjectMapper,时间解析后的默认格式为：TImestamp.时间戳 return mapper.writeValueAsString(object); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 我们使用工具类，代码就更加简洁了！ 123456@RequestMapping(&quot;/j3&quot;) public String json3()&#123; Date date = new Date(); return JsonUtils.getJson(date,&quot;yyyy-MM-dd HH:mm:ss&quot;); &#125;&#125; 大功告成！完美！ 8.7、FastJson fastjson.jar是阿里开发的一款专门用于Java开发的包， 实现json对象与JavaBean对象的转换， 实现JavaBean对象与json字符串的转换， 实现json对象与json字符串的转换。 实现json的转换方法很多，最后的实现结果都是一样的。 fastjson 的 pom依赖！ 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.60&lt;/version&gt;&lt;/dependency&gt; fastjson 三个主要的类： JSONObject 代表 json 对象 JSONObject实现了Map接口, 猜想 JSONObject底层操作是由Map实现的。 JSONObject对应json对象，通过各种形式的get()方法可以获取json对象中的数据，也可利用诸如size()，isEmpty()等方法获取&quot;键：值&quot;对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。 JSONArray 代表 json 对象数组 内部是有List接口中的方法来完成操作的。 JSON代表 JSONObject和JSONArray的转化 JSON类源码分析与使用 仔细观察这些方法，主要是实现json对象，json对象数组，javabean对象，json字符串之间的相互转化。 代码测试，我们新建一个FastJsonDemo 类 12345678910111213141516171819202122232425262728293031323334353637@RequestMapping(&quot;/j4&quot;) //@ResponseBody//他就不会走视图解析器，会直接返回一个 字符串 public String json4()&#123; User user1 = new User(1, &quot;秦疆1号&quot;, 12); User user2 = new User(2, &quot;秦疆2号&quot;, 12); User user3 = new User(3, &quot;秦疆3号&quot;, 12); User user4 = new User(4, &quot;秦疆4号&quot;, 12); User user5 = new User(5, &quot;秦疆5号&quot;, 12); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); list.add(user5); System.out.println(&quot;*******Java对象 转 JSON字符串*******&quot;); String str1 = JSON.toJSONString(list); System.out.println(&quot;JSON.toJSONString(list)==&gt;&quot;+str1); String str2 = JSON.toJSONString(user1); System.out.println(&quot;JSON.toJSONString(user1)==&gt;&quot;+str2); System.out.println(&quot;\\n****** JSON字符串 转 Java对象*******&quot;); User jp_user1=JSON.parseObject(str2,User.class); System.out.println(&quot;JSON.parseObject(str2,User.class)==&gt;&quot;+jp_user1); System.out.println(&quot;\\n****** Java对象 转 JSON对象 ******&quot;); JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2); System.out.println(&quot;(JSONObject) JSON.toJSON(user2)==&gt;&quot;+jsonObject1.getString(&quot;name&quot;)); System.out.println(&quot;\\n****** JSON对象 转 Java对象 ******&quot;); User to_java_user = JSON.toJavaObject(jsonObject1, User.class); System.out.println(&quot;JSON.toJavaObject(jsonObject1, User.class)==&gt;&quot;+to_java_user); return JSON.toJSONString(list); &#125; 这种工具类，我们只需要掌握使用就好了，在使用的时候在根据具体的业务去找对应的实现。和以前的commons-io那种工具包一样，拿来用就好了！ 9、Ajax研究(主动权交给了前端) 9.1、简介 AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。 在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。Google Suggest能够自动帮你完成搜索单词。 Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：当您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。就和国内百度的搜索框一样! 传统的网页(即不用ajax技术的网页)，想要更新内容或者提交一个表单，都需要重新加载整个网页。 使用ajax技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。(弹窗等) 使用Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的Web用户界面。 9.2、伪造Ajax 我们可以使用前端的一个标签来伪造一个ajax的样子。iframe标签 新建一个module ：sspringmvc-06-ajax ， 导入web支持！ 编写一个 ajax-frame.html 使用 iframe 测试，感受下效果 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;kuangshen&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; var myDate = new Date(); document.getElementById(&#x27;currentTime&#x27;).innerText = myDate.getTime(); &#125;; function LoadPage()&#123; var targetUrl = document.getElementById(&#x27;url&#x27;).value; console.log(targetUrl); document.getElementById(&quot;iframePosition&quot;).src = targetUrl; &#125;&lt;/script&gt;&lt;div&gt; &lt;p&gt;请输入要加载的地址：&lt;span id=&quot;currentTime&quot;&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt; &lt;input id=&quot;url&quot; type=&quot;text&quot; value=&quot;https://www.baidu.com/&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;提交&quot; onclick=&quot;LoadPage()&quot;&gt; &lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;h3&gt;加载页面位置：&lt;/h3&gt; &lt;iframe id=&quot;iframePosition&quot; style=&quot;width: 100%;height: 500px;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 使用IDEA开浏览器测试一下！ 利用AJAX可以做： 注册时，输入用户名自动检测用户是否已经存在。 登陆时，提示用户名密码错误 删除数据行时，将行ID发送到后台，后台在数据库中删除，数据库删除成功后，在页面DOM中将数据行也删除。 …等等 9.3、jQuery.ajax（前后端交互） 纯JS原生实现Ajax我们不去讲解这里，直接使用jquery提供的，方便学习和使用，避免重复造轮子，有兴趣的同学可以去了解下JS原生XMLHttpRequest ！ Ajax的核心是XMLHttpRequest对象(XHR)。XHR为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。 jQuery 提供多个与 AJAX 有关的方法。 通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON – 同时您能够把这些外部数据直接载入网页的被选元素中。 jQuery 不是生产者，而是大自然搬运工。 jQuery Ajax本质就是 XMLHttpRequest，对他进行了封装，方便调用！ 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;ifram体验AJAX&lt;/title&gt; &lt;script&gt; function go() &#123; var url=document.getElementById(&quot;url&quot;).value; document.getElementById(&quot;iframel&quot;).src=url; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;p&gt;请输入地址：&lt;/p&gt; &lt;p&gt; &lt;input type=&quot;text&quot; id=&quot;url&quot; value=&quot;https://www.csdn.net/?spm=1001.2101.3001.4476&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;提交&quot; onclick=&quot;go()&quot;&gt; &lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;iframe id=&quot;iframel&quot; style=&quot;width:100% ;height:500px&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 先去官网拷贝Jquery代码 url data sucess和error参数 123456789101112131415161718192021jQuery.ajax(...) 公用方法 部分参数： --url：请求地址 type：请求方式，GET、POST（1.9.0之后用method） headers：请求头 --data：要发送的数据 contentType：即将发送信息至服务器的内容编码类型(默认: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;) async：是否异步 timeout：设置请求超时时间（毫秒） beforeSend：发送请求前执行的函数(全局) complete：完成之后执行的回调函数(全局) --success：成功之后执行的回调函数(全局) error：失败之后执行的回调函数(全局) accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型 dataType：将服务器端返回的数据转换成指定类型 &quot;xml&quot;: 将服务器端返回的内容转换成xml格式 &quot;text&quot;: 将服务器端返回的内容转换成普通文本格式 &quot;html&quot;: 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。 &quot;script&quot;: 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式 &quot;json&quot;: 将服务器端返回的内容转换成相应的JavaScript对象 &quot;jsonp&quot;: JSONP 格式使用 JSONP 形式调用函数时，如 &quot;myurl?callback=?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数 我们来个简单的测试，使用最原始的HttpServletResponse处理 , .最简单 , 最通用 配置web.xml 和 springmvc的配置文件【记得静态资源过滤和注解驱动配置上】 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt; &lt;context:component-scan base-package=&quot;com.kuang.controller&quot;/&gt; &lt;!--静态资源过滤，可以找到JQuery--&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!--注解驱动配--&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;!-- 后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 编写一个AjaxController 123456789101112@Controllerpublic class AjaxController &#123; @RequestMapping(&quot;/a1&quot;) public void ajax1(String name , HttpServletResponse response) throws IOException &#123; if (&quot;admin&quot;.equals(name))&#123; response.getWriter().print(&quot;true&quot;); &#125;else&#123; response.getWriter().print(&quot;false&quot;); &#125; &#125;&#125; 导入jquery ， 可以使用在线的CDN ， 也可以下载导入 12&lt;script src=&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt; 编写index.jsp测试 12345678910111213141516171819202122232425262728&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;%--&lt;script src=&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;--%&gt; //$&#123;pageContext.request.contextPath&#125;是web的原始地址0 &lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; function a1()&#123; $.post(&#123; url:&quot;$&#123;pageContext.request.contextPath&#125;/a1&quot;, data:&#123;&#x27;name&#x27;:$(&quot;#txtName&quot;).val()&#125;, success:function (data,status) &#123; alert(data); alert(status); &#125; //error:function()&#123;&#125; &#125;); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;%--onblur：失去焦点触发事件--%&gt;用户名:&lt;input type=&quot;text&quot; id=&quot;txtName&quot; onblur=&quot;a1()&quot;/&gt; &lt;/body&gt;&lt;/html&gt; 启动tomcat测试！打开浏览器的控制台，当我们鼠标离开输入框的时候，可以看到发出了一个ajax的请求！是后台返回给我们的结果！测试成功！ 9.4、Springmvc实现 实体类user（使用了lombok插件，可以自己写实现类方法） 12345678910@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private String name; private int age; private String sex;&#125; 我们来获取一个集合对象，展示到前端页面 12345678@RequestMapping(&quot;/a2&quot;)public List&lt;User&gt; ajax2()&#123; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(new User(&quot;秦疆1号&quot;,3,&quot;男&quot;)); list.add(new User(&quot;秦疆2号&quot;,3,&quot;男&quot;)); list.add(new User(&quot;秦疆3号&quot;,3,&quot;男&quot;)); return list; //由于@RestController注解，将list转成json格式返回&#125; 前端接受用户 Jquery的固定写法记忆 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/static/js/jquery-3.4.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $(&quot;#btn&quot;).click(function () &#123; // console.log(&#x27;点击事件成功&#x27;) // $.post(url,param,[可以省略],success) $.post(&quot;$&#123;pageContext.request.contextPath&#125;/a2&quot;,function (data) &#123; console.log(data[0].name); let html = &quot;&quot;; for (let i = 0; i &lt; data.length; i++) &#123; html += `&lt;tr&gt; &lt;td&gt;$&#123;&quot;$&#123;data[i].name&#125;&quot;&#125;&lt;/td&gt; &lt;td&gt;$&#123;&quot;$&#123;data[i].age&#125;&quot;&#125;&lt;/td&gt; &lt;td&gt;$&#123;&quot;$&#123;data[i].sex&#125;&quot;&#125;&lt;/td&gt; &lt;/tr&gt;` &#125; $(&quot;#content&quot;).html(html) console.log(html) &#125;) &#125;) &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; value=&quot;加载数据&quot; id=&quot;btn&quot;&gt;&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;性别&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody id=&quot;content&quot;&gt; &lt;%--数据：后台--%&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 几种js代码对比 上面的代码也正确 ${}占位符也是为某一个数据结构占据位置。 1234let job=&quot;web前端开发工程师&quot;;let str2=`我是$&#123;job&#125;，工作5年了`;//注意有坑：这里不是单引号，是esc下面的点符号console.log(str2);上面代码很自然的利用占位符将变量插入到字符串中。 成功实现了数据回显！可以体会一下Ajax的好处，注意版本！ 9.5、注册提示效果 我们写一个Controller 1234567891011121314151617181920@RequestMapping(&quot;/a3&quot;)public String ajax3(String name,String pwd)&#123; String msg = &quot;&quot;; //模拟数据库中存在数据 if (name!=null)&#123; if (&quot;admin&quot;.equals(name))&#123; msg = &quot;OK&quot;; &#125;else &#123; msg = &quot;用户名输入错误&quot;; &#125; &#125; if (pwd!=null)&#123; if (&quot;123456&quot;.equals(pwd))&#123; msg = &quot;OK&quot;; &#125;else &#123; msg = &quot;密码输入有误&quot;; &#125; &#125; return msg; //由于@RestController注解，将msg转成json格式返回&#125; 前端页面 login.jsp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;ajax&lt;/title&gt; &lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery.js&quot;&gt;&lt;/script&gt; &lt;script&gt; function a1()&#123; $.post(&#123; url:&quot;$&#123;pageContext.request.contextPath&#125;/a3&quot;, data:&#123;&#x27;name&#x27;:$(&quot;#name&quot;).val()&#125;, success:function (data) &#123; if (data.toString()==&#x27;OK&#x27;)&#123; $(&quot;#userInfo&quot;).css(&quot;color&quot;,&quot;green&quot;); &#125;else &#123; $(&quot;#userInfo&quot;).css(&quot;color&quot;,&quot;red&quot;); &#125; $(&quot;#userInfo&quot;).html(data); &#125; &#125;); &#125; function a2()&#123; $.post(&#123; url:&quot;$&#123;pageContext.request.contextPath&#125;/a3&quot;, data:&#123;&#x27;pwd&#x27;:$(&quot;#pwd&quot;).val()&#125;, success:function (data) &#123; if (data.toString()==&#x27;OK&#x27;)&#123; $(&quot;#pwdInfo&quot;).css(&quot;color&quot;,&quot;green&quot;); &#125;else &#123; $(&quot;#pwdInfo&quot;).css(&quot;color&quot;,&quot;red&quot;); &#125; $(&quot;#pwdInfo&quot;).html(data); &#125; &#125;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt; 用户名:&lt;input type=&quot;text&quot; id=&quot;name&quot; onblur=&quot;a1()&quot;/&gt; &lt;span id=&quot;userInfo&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt; 密码:&lt;input type=&quot;text&quot; id=&quot;pwd&quot; onblur=&quot;a2()&quot;/&gt; &lt;span id=&quot;pwdInfo&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 记得处理json乱码问题 123456789101112131415&lt;!--JSON乱码问题配置--&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;constructor-arg value=&quot;UTF-8&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt; &lt;property name=&quot;objectMapper&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt; &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; 测试一下效果，动态请求响应，局部刷新，就是如此！ 9.6、获取baidu接口Demo JSONP.html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;JSONP百度搜索&lt;/title&gt; &lt;style&gt; #q&#123; width: 500px; height: 30px; border:1px solid #ddd; line-height: 30px; display: block; margin: 0 auto; padding: 0 10px; font-size: 14px; &#125; #ul&#123; width: 520px; list-style: none; margin: 0 auto; padding: 0; border:1px solid #ddd; margin-top: -1px; display: none; &#125; #ul li&#123; line-height: 30px; padding: 0 10px; &#125; #ul li:hover&#123; background-color: #f60; color: #fff; &#125; &lt;/style&gt; &lt;script&gt; // 2.步骤二 // 定义demo函数 (分析接口、数据) function demo(data)&#123; var Ul = document.getElementById(&#x27;ul&#x27;); var html = &#x27;&#x27;; // 如果搜索数据存在 把内容添加进去 if (data.s.length) &#123; // 隐藏掉的ul显示出来 Ul.style.display = &#x27;block&#x27;; // 搜索到的数据循环追加到li里 for(var i = 0;i&lt;data.s.length;i++)&#123; html += &#x27;&lt;li&gt;&#x27;+data.s[i]+&#x27;&lt;/li&gt;&#x27;; &#125; // 循环的li写入ul Ul.innerHTML = html; &#125; &#125; // 1.步骤一 window.onload = function()&#123; // 获取输入框和ul var Q = document.getElementById(&#x27;q&#x27;); var Ul = document.getElementById(&#x27;ul&#x27;); // 事件鼠标抬起时候 Q.onkeyup = function()&#123; // 如果输入框不等于空 if (this.value != &#x27;&#x27;) &#123; // ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆JSONPz重点☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆ // 创建标签 var script = document.createElement(&#x27;script&#x27;); //给定要跨域的地址 赋值给src //这里是要请求的跨域的地址 我写的是百度搜索的跨域地址 script.src = &#x27;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=&#x27;+this.value+&#x27;&amp;cb=demo&#x27;; // 将组合好的带src的script标签追加到body里 document.body.appendChild(script); &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;text&quot; id=&quot;q&quot; /&gt;&lt;ul id=&quot;ul&quot;&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 测试 10、拦截器 10.1、概述 SpringMVC的处理器拦截器**类似于Servlet开发中的过滤器Filter,**用于对处理器进行预处理和后处理。 开发者可以自己定义一些拦截器来实现特定的功能。 过滤器与拦截器的区别：拦截器是AOP思想的具体应用。 过滤器 servlet规范中的一部分，任何javaweb工程都可以使用 在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截 拦截器 拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用 拦截器只会拦截访问的控制器方法， 如果访问的是jsp/html/css/image/js是不会进行拦截的,减少资源损耗 10.2、自定义拦截器 新建一个Moudule ， springmvc-Interceptor ， 添加web支持 配置web.xml 和 springmvc-servlet.xml 文件 编写一个拦截器（必须实现 HandlerInterceptor 接口）AOP思想的运用 return true的情况 123456789101112131415161718192021222324252627package nuc.ss.config;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class MyInterceptor implements HandlerInterceptor &#123; //return true; 执行下一个拦截器，放行 //return false; 不执行下一个拦截器，拦截 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;===========处理前===========&quot;); return true; &#125; //日志 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;===========处理后===========&quot;); &#125; //日志 public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;===========清理===========&quot;); &#125;&#125; 在springmvc的配置文件中配置拦截器 类比web下的过滤器配置 过滤那个请求 那些类 123456789&lt;!--拦截器配置--&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--包括这个请求下面的所有请求--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;nuc.ss.config.MyInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 编写一个Controller，接收请求 12345678910111213package nuc.ss.controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class TestController &#123; @GetMapping(&quot;/t1&quot;) public String test() &#123; System.out.println(&quot;TestController.test&quot;); return &quot;ok&quot;; &#125;&#125; 启动tomcat 测试一下！(http://localhost:8888/t1) 10.3、验证用户是否登录 (认证用户) 实现思路 有一个登陆页面，需要写一个controller访问页面。 登陆页面有一提交表单的动作。需要在controller中处理。判断用户名密码是否正确。如果正确，向session中写入用户信息。返回登陆成功。 拦截用户请求，判断用户是否登陆。如果用户已经登陆。放行， 如果用户未登陆，跳转到登陆页面 测试： 编写一个登陆页面 login.jsp 1234567891011121314151617&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%--在web-inf下面的所有页面或者资源，只能通过controller或者Servlet进行访问--%&gt;&lt;h1&gt;登录页面&lt;/h1&gt;&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/user/login&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; 密码：&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 编写一个Controller处理请求 12345678910111213141516171819202122232425@Controller@RequestMapping(&quot;/user&quot;)//限定为user下面的请求public class LoginController &#123; @RequestMapping(&quot;/main&quot;) public String main() &#123; return &quot;main&quot;; &#125; @RequestMapping(&quot;/goLogin&quot;) public String login() &#123; return &quot;login&quot;; &#125; @RequestMapping(&quot;/login&quot;) public String login(HttpSession session, String username, String password, Model model) &#123; //把用户的信息存在session中 session.setAttribute(&quot;userLoginInfo&quot;,username); model.addAttribute(&quot;password&quot;,password); model.addAttribute(&quot;username&quot;,username); return &quot;main&quot;; &#125; @RequestMapping(&quot;/goOut&quot;) public String goOut(HttpSession sessionl) &#123; sessionl.removeAttribute(&quot;userLoginInfo&quot;); return &quot;login&quot;; &#125;&#125; 编写一个登陆成功的页面 **在web_inf下面只能通过controller或者servlet访问 ** main.jsp 12345678910111213141516&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;首页&lt;/h1&gt;&lt;span&gt;$&#123;password&#125;&lt;/span&gt;&lt;span&gt;$&#123;username&#125;&lt;/span&gt;&lt;p&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/goOut&quot;&gt;注销&lt;/a&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 在 index 页面上测试跳转！启动Tomcat 测试，未登录也可以进入主页！ 1234567891011&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;index&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/goLogin&quot;&gt;登录页面&lt;/a&gt;&lt;/h1&gt;&lt;h1&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/main&quot;&gt;首页&lt;/a&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 编写用户登录拦截器 12345678910111213141516171819202122232425262728package nuc.ss.config;import org.springframework.web.servlet.HandlerInterceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;public class LoginInterceptor implements HandlerInterceptor &#123; public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; HttpSession session = request.getSession(); //放行:判断什么情况下登录 //登录页面也会放行 if (request.getRequestURI().contains(&quot;goLogin&quot;)) &#123; return true; &#125; if (request.getRequestURI().contains(&quot;login&quot;)) &#123; return true; &#125; if (session.getAttribute(&quot;userLoginInfo&quot;) != null) &#123; return true; &#125; //判断什么情况下没有登录，不满足转发到登录页面 request.getRequestDispatcher(&quot;/WEB-INF/jsp/login.jsp&quot;).forward(request,response); return false; &#125;&#125; 在Springmvc的配置文件中注册拦截器 1234567&lt;!--关于拦截器的配置--&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean id=&quot;loginInterceptor&quot; class=&quot;com.kuang.interceptor.LoginInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 再次重启Tomcat测试！ OK，测试登录拦截功能无误. 11、文件上传和下载 11.1、准备工作 文件上传是项目开发中最常见的功能之一 ,springMVC 可以很好的支持文件上传。 SpringMVC上下文中默认没有装配MultipartResolver，因此默认情况下其不能处理文件上传工作。如果想使用Spring的文件上传功能，则需要在上下文中配置MultipartResolver。 前端表单要求：为了能上传文件，必须将表单的method设置为POST，并将enctype设置为multipart/form-data。只有在这样的情况下，浏览器才会把用户选择的文件以二进制数据发送给服务器； 对表单中的 enctype 属性做个详细的说明： application/x-www=form-urlencoded：默认方式，只处理表单域中的 value 属性值，采用这种编码方式的表单会将表单域中的值处理成 URL 编码方式。 multipart/form-data：这种编码方式会以二进制流的方式来处理表单数据，这种编码方式会把文件域指定文件的内容也封装到请求参数中，不会对字符编码。 text/plain：除了把空格转换为 “+” 号外，其他字符都不做编码处理，这种方式适用直接通过表单发送邮件。 1234&lt;form action=&quot;&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 一旦设置了enctype为multipart/form-data，浏览器即会采用二进制流的方式来处理表单数据，而对于文件上传的处理则涉及在服务器端解析原始的HTTP响应。在2003年，Apache Software Foundation发布了开源的Commons FileUpload组件，其很快成为Servlet/JSP程序员上传文件的最佳选择。 Servlet3.0规范已经提供方法来处理文件上传，但这种上传需要在Servlet中完成。 而Spring MVC则提供了更简单的封装。 Spring MVC为文件上传提供了直接的支持，这种支持是用即插即用的MultipartResolver实现的。 Spring MVC使用Apache Commons FileUpload技术实现了一个MultipartResolver实现类： CommonsMultipartResolver。因此，SpringMVC的文件上传还需要依赖Apache Commons FileUpload的组件。 11.2、文件上传 导入文件上传的jar包，commons-fileupload ， Maven会自动帮我们导入他的依赖包 commons-io包； 123456789101112&lt;!--文件上传--&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;!--servlet-api导入高版本的--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt;&lt;/dependency&gt; 配置bean：multipartResolver 【注意！！！这个bena的id必须为：multipartResolver ， 否则上传文件会报400的错误！在这里栽过坑,教训！】 12345678&lt;!--文件上传配置--&gt;&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 --&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;/&gt; &lt;!-- 上传文件大小上限，单位为字节（10485760=10M） --&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760&quot;/&gt; &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot;/&gt;&lt;/bean&gt; CommonsMultipartFile 的 常用方法： String getOriginalFilename()：获取上传文件的原名 InputStream getInputStream()：获取文件流 void transferTo(File dest)：将上传文件保存到一个目录文件中 我们去实际测试一下 编写前端页面 1234&lt;form action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt; 以二进制形式提交 &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;upload&quot;&gt;&lt;/form&gt; Controller 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package nuc.ss.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.multipart.commons.CommonsMultipartFile;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.*;import java.net.URLEncoder;@RestControllerpublic class FileController &#123; //@RequestParam(&quot;file&quot;) 将name=file控件得到的文件封装成CommonsMultipartFile 对象 //批量上传CommonsMultipartFile则为数组即可 @RequestMapping(&quot;/upload&quot;) public String fileUpload(@RequestParam(&quot;file&quot;) CommonsMultipartFile file , HttpServletRequest request) throws IOException &#123; //获取文件名 : file.getOriginalFilename(); String uploadFileName = file.getOriginalFilename(); //如果文件名为空，直接回到首页！ if (&quot;&quot;.equals(uploadFileName))&#123; return &quot;redirect:/index.jsp&quot;; &#125; System.out.println(&quot;上传文件名 : &quot;+uploadFileName); //上传路径保存设置 String path = request.getServletContext().getRealPath(&quot;/upload&quot;); //如果路径不存在，创建一个 File realPath = new File(path); if (!realPath.exists())&#123; realPath.mkdir(); &#125; System.out.println(&quot;上传文件保存地址：&quot;+realPath); InputStream is = file.getInputStream(); //文件输入流 OutputStream os = new FileOutputStream(new File(realPath,uploadFileName)); //文件输出流 //读取写出 int len=0; byte[] buffer = new byte[1024]; while ((len=is.read(buffer))!=-1)&#123; os.write(buffer,0,len); os.flush(); &#125; os.close(); is.close(); return &quot;redirect:/index.jsp&quot;; &#125;&#125; 测试上传文件，OK！ 采用file.Transto 来保存上传的文件 编写Controller 1234567891011121314151617181920/** 采用file.Transto 来保存上传的文件*/@RequestMapping(&quot;/upload2&quot;)public String fileUpload2(@RequestParam(&quot;file&quot;) CommonsMultipartFile file, HttpServletRequest request) throws IOException &#123; //上传路径保存设置 String path = request.getServletContext().getRealPath(&quot;/upload&quot;); File realPath = new File(path); if (!realPath.exists())&#123; realPath.mkdir(); &#125; //上传文件地址 System.out.println(&quot;上传文件保存地址：&quot;+realPath); //通过CommonsMultipartFile的方法直接写文件（注意这个时候） file.transferTo(new File(realPath +&quot;/&quot;+ file.getOriginalFilename())); return &quot;redirect:/index.jsp&quot;;&#125; 前端表单提交地址修改 访问提交测试，OK！ 11.3、文件下载 文件下载步骤： 设置 response 响应头 读取文件 – InputStream 写出文件 – OutputStream 执行操作 关闭流 （先开后关） 代码实现： 12345678910111213141516171819202122232425262728293031@RequestMapping(value=&quot;/download&quot;)public String downloads(HttpServletResponse response ,HttpServletRequest request) throws Exception&#123; //要下载的图片地址 String path = request.getServletContext().getRealPath(&quot;/upload&quot;); String fileName = &quot;基础语法.jpg&quot;; //1、设置response 响应头 response.reset(); //设置页面不缓存,清空buffer response.setCharacterEncoding(&quot;UTF-8&quot;); //字符编码 response.setContentType(&quot;multipart/form-data&quot;); //二进制传输数据 //设置响应头 response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;fileName=&quot;+URLEncoder.encode(fileName, &quot;UTF-8&quot;)); File file = new File(path,fileName); //2、 读取文件--输入流 InputStream input=new FileInputStream(file); //3、 写出文件--输出流 OutputStream out = response.getOutputStream(); byte[] buff =new byte[1024]; int index=0; //4、执行 写出操作 while((index= input.read(buff))!= -1)&#123; out.write(buff, 0, index); out.flush(); &#125; out.close(); input.close(); return null;&#125; 前端 12&lt;a href=&quot;/download&quot;&gt;点击下载&lt;/a&gt;1 测试，文件下载OK","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"后端学习","slug":"后端学习","permalink":"http://example.com/tags/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"狂神说Spring","slug":"狂神说Spring","date":"2021-03-31T03:58:10.000Z","updated":"2021-04-02T07:20:28.071Z","comments":true,"path":"2021/03/31/狂神说Spring/","link":"","permalink":"http://example.com/2021/03/31/%E7%8B%82%E7%A5%9E%E8%AF%B4Spring/","excerpt":"","text":"Spring 1.简介 1.1.简介 万物皆注入省去new对象 Spring : 春天 —&gt;给软件行业带来了春天 2002年，Rod Jahnson首次推出了Spring框架雏形interface21框架。 2004年3月24日，Spring框架以interface21框架为基础，经过重新设计，发布了1.0正式版。 很难想象Rod Johnson的学历 , 他是悉尼大学的博士，然而他的专业不是计算机，而是音乐学。 Spring理念 : 使现有技术更加实用 . 本身就是一个大杂烩 , 整合现有的框架技术 官网 : http://spring.io/ 官方下载地址 : https://repo.spring.io/libs-release-local/org/springframework/spring/ GitHub : https://github.com/spring-projects maven Spring Web MVC&amp;JDBC 123456789101112131415161718192021222324&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.3.3&lt;/version&gt;&lt;/dependency&gt; 1.2.优点 1、Spring是一个开源免费的框架 , 容器 . 2、Spring是一个轻量级的框架 , 非侵入式的 . 3、控制反转 IoC , 面向切面 Aop 4、对事物的支持 , 对框架的支持 … 一句话概括： Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器（框架）。 1.3.组成 组成 Spring 框架是一个分层架构，由 **7 个定义良好的模块组成。**Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式 . 组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下： 核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。 Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。 Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。 Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。 Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。 Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。 Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。 1.4.扩展 拓展 Spring Boot与Spring Cloud Spring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发单个微服务; Spring Cloud是基于Spring Boot实现的； Spring Boot专注于快速、方便集成的单个微服务个体，Spring Cloud关注全局的服务治理框架； Spring Boot使用了约束优于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置 , Spring Cloud很大的一部分是基于Spring Boot来实现，Spring Boot可以离开Spring Cloud独立使用开发项目，但是Spring Cloud离不开Spring Boot，属于依赖的关系。 SpringBoot在SpringClound中起到了承上启下的作用，如果你要学习SpringCloud必须要学习SpringBoot。 2.IOC理论推导 IoC基础 新建一个空白的maven项目 2.1.分析实现 分析实现 我们先用我们原来的方式写一段代码 . 1、先写一个UserDao接口 123public interface UserDao &#123; public void getUser();&#125; 2、再去写Dao的实现类 123456public class UserDaoImpl implements UserDao &#123; @Override public void getUser() &#123; System.out.println(&quot;获取用户数据&quot;); &#125;&#125; 3、然后去写UserService的接口 123public interface UserService &#123; public void getUser();&#125; 4、最后写Service的实现类 组合业务层调用userDao 12345678public class UserServiceImpl implements UserService &#123; private UserDao userDao = new UserDaoImpl(); @Override public void getUser() &#123; userDao.getUser(); &#125;&#125; 5、测试一下 12345@Testpublic void test()&#123; UserService service = new UserServiceImpl(); service.getUser();&#125; 这是我们原来的方式 , 开始大家也都是这么去写的对吧 . 那我们现在修改一下 . 把Userdao的实现类增加一个 . 123456public class UserDaoMySqlImpl implements UserDao &#123; @Override public void getUser() &#123; System.out.println(&quot;MySql获取用户数据&quot;); &#125;&#125; 紧接着我们要去使用MySql的话 , 我们就需要去service实现类里面修改对应的实现 新建UserDaoMysql.java 12345678public class UserServiceImpl implements UserService &#123; private UserDao userDao = new UserDaoMySqlImpl(); @Override public void getUser() &#123; userDao.getUser(); &#125;&#125; 在假设, 我们再增加一个那么我们要使用的Oracle 的实现类 . 123456public class UserDaoOracleImpl implements UserDao &#123; @Override public void getUser() &#123; System.out.println(&quot;Oracle获取用户数据&quot;); &#125;&#125; 那么我们要使用Oracle , 又需要去service实现类里面修改对应的实现 . 假设我们的这种需求非常大 , 这种方式就根本不适用了, 甚至反人类对吧 , 每次变动 , 都需要修改大量代码 . 这种设计的耦合性太高了, 牵一发而动全身 . 那我们如何去解决呢 ? 我们可以在需要用到他的地方 , 不去实现它 , 而是留出一个接口 , 利用set , 我们去代码里修改下 . 123456789101112public class UserServiceImpl implements UserService &#123; private UserDao userDao;// 利用set进行动态实现 public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void getUser() &#123; userDao.getUser(); &#125;&#125; 现在去我们的测试类里 , 进行测试 ; 123456789@Testpublic void test()&#123; UserServiceImpl service = new UserServiceImpl(); service.setUserDao( new UserDaoMySqlImpl() ); service.getUser(); //那我们现在又想用Oracle去实现呢 service.setUserDao( new UserDaoOracleImpl() ); service.getUser();&#125; 以前所有东西都是由程序去进行控制创建 , 而现在是由我们自行控制创建对象 , 把主动权交给了调用者 . 程序不用去管怎么创建,怎么实现了 . 它只负责提供一个接口 .set注入后程序被动接收对象，不需要主动改变 这种思想 , 从本质上解决了问题 , 我们**程序员不再去管理对象的创建了 , 更多的去关注业务的实现 . 耦合性大大降低 . 这也就是IOC的原型 !**程序架构不需要改变 2.2.IOC本质 本质 控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。 IoC是Spring框架的核心内容，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。 Spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象。 采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。 控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。 3.HelloSpring 导入Jar包 注 : spring 需要导入commons-logging进行日志记录 . 我们利用maven , 他会自动下载对应的依赖项 . 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.10.RELEASE&lt;/version&gt;&lt;/dependency&gt; 3.1编写代码 1、编写一个Hello实体类 123456789101112public class Hello &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void show()&#123; System.out.println(&quot;Hello,&quot;+ name ); &#125;&#125; 2、编写我们的spring文件 , 这里我们命名为beans.xml（resources目录下） 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--bean就是java对象 , 由Spring创建和管理--&gt; &lt;bean id=&quot;hello&quot; class=&quot;com.kuang.pojo.Hello&quot;&gt; &lt;!--属性和对应值--&gt; &lt;property name=&quot;name&quot; value=&quot;Spring&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 3、我们可以去进行测试了 . 12345678@Testpublic void test()&#123; //解析beans.xml文件 , 生成管理相应的Bean对象 获取spring的上下文对象 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); //getBean : 参数即为spring配置文件中bean的id . Hello hello = (Hello) context.getBean(&quot;hello&quot;); hello.show();&#125; 思考 Hello 对象是谁创建的 ? hello 对象是由Spring创建的 Hello 对象的属性是怎么设置的 ? hello 对象的属性是由Spring容器设置的 类名 变量名=new 类型（）; id=变量名；class=new 的对象（实体类）；property相当于给对象的属性设置一个值 这个过程就叫控制反转 : 控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的 反转 : 程序本身不创建对象 , 而变成被动的接收对象 . 依赖注入 : 就是利用set方法来进行注入的（删除set方法会报错）. IOC是一种编程思想，由主动的编程变成被动的接收 可以通过newClassPathXmlApplicationContext去浏览一下底层源码 . 3.2修改案例一 我们在案例一中， 新增一个Spring配置文件beans.xml 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;MysqlImpl&quot; class=&quot;com.kuang.dao.impl.UserDaoMySqlImpl&quot;/&gt; &lt;bean id=&quot;OracleImpl&quot; class=&quot;com.kuang.dao.impl.UserDaoOracleImpl&quot;/&gt; &lt;bean id=&quot;ServiceImpl&quot; class=&quot;com.kuang.service.impl.UserServiceImpl&quot;&gt; &lt;!--注意: 这里的name并不是属性 , 而是set方法后面的那部分 , 首字母小写--&gt; &lt;!--引用另外一个bean , 不是用value 而是用 ref ，普通属性用value--&gt; &lt;property name=&quot;userDao&quot; ref=&quot;OracleImpl&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试！ 1234567@Testpublic void test2()&#123; //new CPX简写 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserServiceImpl serviceImpl = (UserServiceImpl) context.getBean(&quot;ServiceImpl&quot;); serviceImpl.getUser();&#125; OK , 到了现在 , 我们彻底不用再程序中去改动了 , 要实现不同的操作 , 用户只需要在xml配置文件中进行修改 , 所谓的IoC,一句话搞定 : 对象由Spring 来创建 , 管理 , 装配 ! 4.IOC创建对象方式 4.1.通过无参构造方法来创建 通过无参构造方法来创建 1、User.java 123456789101112public class User &#123; private String name; public User() &#123; System.out.println(&quot;user无参构造方法&quot;); &#125; public void setName(String name) &#123; this.name = name; &#125; public void show()&#123; System.out.println(&quot;name=&quot;+ name ); &#125;&#125; 2、beans.xml 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Spring&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 3、测试类 12345678910@Testpublic void test()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); //在执行getBean的时候, user已经创建好了 , 通过无参构造 User user = (User) context.getBean(&quot;user&quot;); //调用对象的方法 . user.show();&#125;//输出user无参构造方法//name=Spring 结果可以发现，在调用show方法之前，User对象已经通过无参构造初始化了！ 4.2.通过有参构造方法来创建 通过有参构造方法来创建 1、UserT . java 123456789101112public class UserT &#123; private String name; public UserT(String name) &#123; this.name = name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void show()&#123; System.out.println(&quot;name=&quot;+ name ); &#125;&#125; 2、beans.xml 有三种方式编写 正常情况下创建不了 1234567891011121314&lt;!-- 第一种根据index参数下标设置 --&gt;&lt;bean id=&quot;userT&quot; class=&quot;com.kuang.pojo.UserT&quot;&gt; &lt;!-- index指构造方法 , 下标从0开始 --&gt;xml &lt;constructor-arg index=&quot;0&quot; value=&quot;kuangshen2&quot;/&gt;&lt;/bean&gt;&lt;!-- 第二种根据参数名字设置 --&gt;&lt;bean id=&quot;userT&quot; class=&quot;com.kuang.pojo.UserT&quot;&gt; &lt;!-- name指参数名 --&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;kuangshen2&quot;/&gt;&lt;/bean&gt;&lt;!-- 第三种根据参数类型设置 不建议使用 --&gt;&lt;bean id=&quot;userT&quot; class=&quot;com.kuang.pojo.UserT&quot;&gt; &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;kuangshen2&quot;/&gt;&lt;/bean&gt; 3、测试 123456@Testpublic void testT()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserT user = (UserT) context.getBean(&quot;userT&quot;); user.show();&#125; 再加一个User方法： 12345ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);User user = (User) context.getBean(&quot;User&quot;);User user2 = (User) context.getBean(&quot;User&quot;);System.out.println(user==user2);//返回true说明已经创建了.默认单例模式 结论：在配置文件加载的时候。其中管理的对象都已经初始化了！ 5.Spring配置 5.1.别名 alias 设置别名 , 为bean设置别名 , 可以设置多个别名 12&lt;!--设置别名：在获取Bean的时候可以使用别名获取--&gt;&lt;alias name=&quot;userT&quot; alias=&quot;userNew&quot;/&gt; 5.2.Bean的配置 Bean的配置 1234567891011&lt;!--bean就是java对象,由Spring创建和管理--&gt;&lt;!-- 1.id 是bean的标识符,要唯一,如果没有配置id,name就是默认标识符 如果配置id,又配置了name,那么name是别名 2.name可以设置多个别名,可以用逗号,分号,空格隔开 ----alias显得鸡肋 如果不配置id和name,可以根据applicationContext.getBean(.class)获取对象; 3.class是bean的全限定名=包名+类名--&gt;&lt;bean id=&quot;hello&quot; name=&quot;hello2 h2,h3;h4&quot; class=&quot;com.kuang.pojo.Hello&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Spring&quot;/&gt;&lt;/bean&gt; 5.3.import 建一个新包： 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 团队的合作通过import来实现 .多个bean合并为一个 内容相同会合并 1&lt;import resource=&quot;&#123;path&#125;/beans.xml&quot;/&gt; 6.依赖注入（DI） Dependency Injection 概念 依赖注入（Dependency Injection,DI）。 依赖 : 指Bean对象的创建依赖于容器 . Bean对象的依赖资源 . 注入 : 指Bean对象所依赖的资源 , 由容器来设置和装配 . 6.1.构造器注入 构造器注入 我们在之前的案例已经讲过了 6.2.Set 注入 （重点） Set 注入 （重点） 要求被注入的属性 , 必须有set方法 , set方法的方法名由set + 属性首字母大写 , 如果属性是boolean类型 , 没有set方法 , 是 is . 测试pojo类 : Address.java 123456789101112public class Address &#123; private String address; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; Student.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.kuang.pojo;import java.util.List;import java.util.Map;import java.util.Properties;import java.util.Set;public class Student &#123; private String name; private Address address; private String[] books; private List&lt;String&gt; hobbys; private Map&lt;String,String&gt; card; private Set&lt;String&gt; games; private String wife; private Properties info; public void setName(String name) &#123; this.name = name; &#125; public void setAddress(Address address) &#123; this.address = address; &#125; public void setBooks(String[] books) &#123; this.books = books; &#125; public void setHobbys(List&lt;String&gt; hobbys) &#123; this.hobbys = hobbys; &#125; public void setCard(Map&lt;String, String&gt; card) &#123; this.card = card; &#125; public void setGames(Set&lt;String&gt; games) &#123; this.games = games; &#125; public void setWife(String wife) &#123; this.wife = wife; &#125; public void setInfo(Properties info) &#123; this.info = info; &#125; public void show()&#123; System.out.println(&quot;name=&quot;+ name + &quot;,address=&quot;+ address.getAddress() + &quot;,books=&quot; ); for (String book:books)&#123; System.out.print(&quot;&lt;&lt;&quot;+book+&quot;&gt;&gt;\\t&quot;); &#125; System.out.println(&quot;\\n爱好:&quot;+hobbys); System.out.println(&quot;card:&quot;+card); System.out.println(&quot;games:&quot;+games); System.out.println(&quot;wife:&quot;+wife); System.out.println(&quot;info:&quot;+info); &#125;&#125; 6.3.扩展的注入（几个数据类型为例） 1、常量注入 123&lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;&lt;/bean&gt; 测试： 123456@Testpublic void test01()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); Student student = (Student) context.getBean(&quot;student&quot;); System.out.println(student.getName());&#125; 2、Bean注入 注意点：这里的值是一个引用，ref 12345678&lt;bean id=&quot;addr&quot; class=&quot;com.kuang.pojo.Address&quot;&gt; &lt;property name=&quot;address&quot; value=&quot;重庆&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt; &lt;property name=&quot;address&quot; ref=&quot;addr&quot;/&gt;&lt;/bean&gt; 3、数组注入 1234567891011&lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt; &lt;property name=&quot;address&quot; ref=&quot;addr&quot;/&gt; &lt;property name=&quot;books&quot;&gt; &lt;array&gt; &lt;value&gt;西游记&lt;/value&gt; &lt;value&gt;红楼梦&lt;/value&gt; &lt;value&gt;水浒传&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; 4、List注入 1234567&lt;property name=&quot;hobbys&quot;&gt; &lt;list&gt; &lt;value&gt;听歌&lt;/value&gt; &lt;value&gt;看电影&lt;/value&gt; &lt;value&gt;爬山&lt;/value&gt; &lt;/list&gt;&lt;/property&gt; 5、Map注入 123456&lt;property name=&quot;card&quot;&gt; &lt;map&gt; &lt;entry key=&quot;中国邮政&quot; value=&quot;456456456465456&quot;/&gt; &lt;entry key=&quot;建设&quot; value=&quot;1456682255511&quot;/&gt; &lt;/map&gt;&lt;/property&gt; 6、set注入 12345678&lt;property name=&quot;games&quot;&gt; &lt;set&gt; &lt;value&gt;LOL&lt;/value&gt; &lt;value&gt;BOB&lt;/value&gt; &lt;value&gt;COC&lt;/value&gt; &lt;/set&gt;&lt;/property&gt; 7、Null注入 1&lt;property name=&quot;wife&quot;&gt;&lt;null/&gt;&lt;/property&gt; 8、Properties注入 1234567&lt;property name=&quot;info&quot;&gt; &lt;props&gt; &lt;prop key=&quot;学号&quot;&gt;20190604&lt;/prop&gt; &lt;prop key=&quot;性别&quot;&gt;男&lt;/prop&gt; &lt;prop key=&quot;姓名&quot;&gt;小明&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt; 测试结果： 9、p命名和c命名注入 p命名和c命名注入 注意：要导入约束 User.java ：【注意：这里没有有参构造器！】 1234567891011121314151617public class User &#123; private String name; private int age; public void setName(String name) &#123; this.name = name; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 1、P命名空间注入 : 需要在头文件中加入约束文件 123导入约束 : xmlns:p=&quot;http://www.springframework.org/schema/p&quot;&lt;!--P(属性: properties)命名空间 , 直接注入属性--&gt;&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; p:name=&quot;狂神&quot; p:age=&quot;18&quot;/&gt; 2、c 命名空间注入 : 需要在头文件中加入约束文件 123导入约束 : xmlns:c=&quot;http://www.springframework.org/schema/c&quot;&lt;!--C(构造: Constructor)命名空间 , 使用构造器注入--&gt;&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; c:name=&quot;狂神&quot; c:age=&quot;18&quot;/&gt; 发现问题：爆红了，刚才我们没有写有参构造！ 解决：把有参构造器加上，这里也能知道，c 就是所谓的构造器注入！ 测试代码： 123456@Testpublic void test02()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); User user = (User) context.getBean(&quot;user&quot;); System.out.println(user);&#125; 6.4.Bean的作用域 在Spring中，那些组成应用程序的主体及由Spring IoC容器所管理的对象，被称之为bean。简单地讲，bean就是由IoC容器初始化、装配及管理的对象 . Scope Description singleton (Default) Scopes a single bean definition to a single object instance for each Spring IoC container. prototype Scopes a single bean definition to any number of object instances. request Scopes a single bean definition to the lifecycle of a single HTTP request. That is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring ApplicationContext. session Scopes a single bean definition to the lifecycle of an HTTP Session. Only valid in the context of a web-aware Spring ApplicationContext. application Scopes a single bean definition to the lifecycle of a ServletContext. Only valid in the context of a web-aware Spring ApplicationContext. websocket Scopes a single bean definition to the lifecycle of a WebSocket. Only valid in the context of a web-aware Spring ApplicationContext. 几种作用域中，request、session作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架），只能用在基于web的Spring ApplicationContext环境。 Singleton(单例模式重点 默认模式) 当一个bean的作用域为Singleton，那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。注意，Singleton作用域是Spring中的缺省作用域。要在XML中将bean定义成singleton，可以这样配置： 1&lt;bean id=&quot;ServiceImpl&quot; class=&quot;cn.csdn.service.ServiceImpl&quot; scope=&quot;singleton&quot;&gt; 测试： 1234567@Testpublic void test03()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); User user = (User) context.getBean(&quot;user&quot;); User user2 = (User) context.getBean(&quot;user&quot;); System.out.println(user==user2);&#125; true Prototype(原型模式) 当一个bean的作用域为Prototype，表示**一个bean定义对应多个对象实例。**Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。在XML中将bean定义成prototype，可以这样配置： 123&lt;bean id=&quot;account&quot; class=&quot;com.foo.DefaultAccount&quot; scope=&quot;prototype&quot;/&gt; 或者&lt;bean id=&quot;account&quot; class=&quot;com.foo.DefaultAccount&quot; singleton=&quot;false&quot;/&gt; 测试： 1234567@Testpublic void test03()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); User user = (User) context.getBean(&quot;user&quot;); User user2 = (User) context.getBean(&quot;user&quot;); System.out.println(user==user2);&#125; false Request 当一个bean的作用域为Request，表示在一次HTTP请求中，一个bean定义对应一个实例；即每个HTTP请求都会有各自的bean实例，它们依据某个bean定义创建而成。该**作用域仅在基于web的Spring ApplicationContext情形下有效。**考虑下面bean定义： 1&lt;bean id&#x3D;&quot;loginAction&quot; class&#x3D;cn.csdn.LoginAction&quot; scope&#x3D;&quot;request&quot;&#x2F;&gt; 针对每次HTTP请求，Spring容器会根据loginAction bean的定义创建一个全新的LoginAction bean实例，且该loginAction bean实例仅在当前HTTP request内有效，因此可以根据需要放心的更改所建实例的内部状态，而其他请求中根据loginAction bean定义创建的实例，将不会看到这些特定于某个请求的状态变化。当处理请求结束，request作用域的bean实例将被销毁。 Session 当一个bean的作用域为Session，表示在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义： 1&lt;bean id&#x3D;&quot;userPreferences&quot; class&#x3D;&quot;com.foo.UserPreferences&quot; scope&#x3D;&quot;session&quot;&#x2F;&gt; 针对某个HTTP Session，Spring容器会根据userPreferences bean定义创建一个全新的userPreferences bean实例，且该userPreferences bean仅在当前HTTP Session内有效。与request作用域一样，可以根据需要放心的更改所创建实例的内部状态，而别的HTTP Session中根据userPreferences创建的实例，将不会看到这些特定于某个HTTP Session的状态变化。当HTTP Session最终被废弃的时候，在该HTTP Session作用域内的bean也会被废弃掉。 7.Bean的自动装配 自动装配说明 自动装配是使用spring满足bean依赖的一种方法 spring会在应用上下文中为某个bean寻找其依赖的bean。 Spring中bean有三种装配机制，分别是： 在xml中显式配置； 在java中显式配置； 隐式的bean发现机制和自动装配。 这里我们主要讲第三种：自动化的装配bean。 Spring的自动装配需要从两个角度来实现，或者说是两个操作： 组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean； 自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的IoC/DI； 组件扫描和自动装配组合发挥巨大威力，使得显示的配置降低到最少。 **推荐不使用自动装配xml配置 , 而使用注解 . 测试环境搭建 1、新建一个项目 2、新建两个实体类，Cat Dog 都有一个叫的方法 12345678910public class Cat &#123; public void shout() &#123; System.out.println(&quot;miao~&quot;); &#125;&#125;public class Dog &#123; public void shout() &#123; System.out.println(&quot;wang~&quot;); &#125;&#125; 3、新建一个用户类 User 12345public class User &#123; private Cat cat; private Dog dog; private String str;&#125; 4、编写Spring配置文件 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt; &lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt; &lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;&gt; &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;/&gt; &lt;property name=&quot;dog&quot; ref=&quot;dog&quot;/&gt; &lt;property name=&quot;str&quot; value=&quot;qinjiang&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 5、测试 123456789public class MyTest &#123; @Test public void testMethodAutowire() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); User user = (User) context.getBean(&quot;user&quot;); user.getCat().shout(); user.getDog().shout(); &#125;&#125; 结果正常输出，环境OK 7.1.byName byName autowire byName (按名称自动装配) 由于在手动配置xml过程中，常常发生字母缺漏和大小写等错误，而无法对其进行检查，使得开发效率降低。 采用自动装配将避免这些错误，并且使配置简单化。 测试： 1、修改bean配置，增加一个属性 autowire=“byName” 123&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; autowire=&quot;byName&quot;&gt; &lt;property name=&quot;str&quot; value=&quot;qinjiang&quot;/&gt;&lt;/bean&gt; 2、再次测试，结果依旧成功输出！ 3、我们将 cat 的bean id修改为 catXXX 4、再次测试， 执行时报空指针java.lang.NullPointerException。因为按byName规则找不对应set方法，真正的setCat就没执行，对象就没有初始化，所以调用时就会报空指针错误。 小结： 当一个bean节点带有 autowire byName的属性时。 将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat。 去spring容器中寻找是否有此字符串名称id的对象。 如果有，就取出注入；如果没有，就报空指针异常。 7.2.byType byType autowire byType (按类型自动装配) 使用autowire byType首先需要保证：同一类型的对象，在spring容器中唯一。如果不唯一，会报不唯一的异常。 1NoUniqueBeanDefinitionException 测试： 1、将user的bean配置修改一下 ： autowire=“byType” 2、测试，正常输出 3、在注册一个cat 的bean对象！ 123456&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;&lt;bean id=&quot;cat2&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; autowire=&quot;byType&quot;&gt; &lt;property name=&quot;str&quot; value=&quot;qinjiang&quot;/&gt;&lt;/bean&gt; 4、测试，报错：NoUniqueBeanDefinitionException 5、删掉cat2，将cat的bean名称改掉！测试！因为是按类型装配，所以并不会报异常，也不影响最后的结果。甚至将id属性去掉，也不影响结果。 12&lt;bean class=&quot;com.kuang.pojo.Cat&quot;/&gt;&lt;bean class=&quot;com.kuang.pojo.Dog&quot;/&gt; 这就是按照类型自动装配！ 总结： bytype:保证bean的class唯一，而且需要自动注入的set方法的参数类型一致 ，而且类型 全局唯一 byname将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat。 7.3.使用注解 jdk1.5开始支持注解，spring2.5开始全面支持注解。 准备工作：利用注解的方式注入属性。 1、在spring配置文件中引入context文件头约束 12345678910&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; 2、开启属性注解支持！ 1&lt;context:annotation-config/&gt; @Autowired @Autowired是按类型自动转配的，不支持id匹配。 需要导入 spring-aop的包！ 测试： 1、将User类中的可以将set方法去掉，使用@Autowired注解 1234567891011121314151617public class User &#123; @Autowired private Cat cat; @Autowired private Dog dog; private String str; public Cat getCat() &#123; return cat; &#125; public Dog getDog() &#123; return dog; &#125; public String getStr() &#123; return str; &#125;&#125; 2、此时配置文件内容要求和原来set之后的名字一样 1234&lt;context:annotation-config/&gt;&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;/&gt; 3、测试，成功输出结果！ 结论： Autowried:可以不用set方法,按照类型来 1234&lt;context:annotation-config/&gt;&lt;bean class=&quot;com.kuang.pojo.Cat&quot;/&gt;&lt;bean class=&quot;com.kuang.pojo.Dog&quot;/&gt;&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;/&gt; 【小狂神科普时间】 @Autowired(required=false) 说明**：false，对象可以为null；**true，对象必须存对象，不能为null。 1234567//如果允许对象为null，设置required = false,默认为true@Autowired(required = false)private Cat cat;public Peopel(@Nullabel String name)&#123; this,name=name;//可以为空&#125; @Qualifier @Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配 @Qualifier不能单独使用。 测试实验步骤： 1、配置文件修改内容，保证类型存在对象。且名字不为类的默认名字！ 类型重复了 1234&lt;bean id=&quot;dog1&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;&lt;bean id=&quot;dog2&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;&lt;bean id=&quot;cat2&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt; 2、没有加Qualifier测试，直接报错 3、在属性上添加Qualifier注解 123456@Autowired@Qualifier(value = &quot;cat2&quot;)private Cat cat;@Autowired@Qualifier(value = &quot;dog2&quot;)private Dog dog; 测试，成功输出！ @Resource @Resource如有指定的name属性，先按该属性进行byName方式查找装配； 其次再进行默认的byName方式进行装配； 如果以上都不成功，则按byType的方式自动装配。 都不成功，则报异常。 实体类： 12345678public class User &#123; //如果允许对象为null，设置required = false,默认为true @Resource(name = &quot;cat2&quot;) private Cat cat; @Resource private Dog dog; private String str;&#125; beans.xml 1234&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;&lt;bean id=&quot;cat2&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;/&gt; 测试：结果OK 配置文件2：beans.xml ， 删掉cat2 12&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt; ----按照Byname匹配成功&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt; ----按照ByType匹配成功 实体类上只保留注解 1234@Resourceprivate Cat cat;@Resourceprivate Dog dog; 结果：OK 结论：先进行byType查找，失败；再进行byName查找，成功。 小结 @Autowired与@Resource异同： 1、@Autowired与@Resource都可以用来装配bean。都可以写在字段上，或写在setter方法上。 2、@Autowired默认按类型装配（属于spring规范），默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用 3、@Resource（属于J2EE复返），默认按照名称进行装配，名称可以通过name属性进行指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。 它们的作用相同都是用注解方式注入对象，但执行顺序不同。@Autowired先byType，@Resource先byName。 8.使用注解开发 说明 在spring4之后，想要使用注解形式，必须得要引入aop的包 在配置文件当中，还得要引入一个context约束 12345678910&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;&lt;&#x2F;beans&gt; 8.1.Bean的实现(省去xml文件) 我们之前都是使用 bean 的标签进行bean注入，但是实际开发中，我们一般都会使用注解！ 1、配置扫描哪些包下的注解 12&lt;!--指定注解扫描包--&gt;&lt;context:component-scan base-package=&quot;com.kuang.pojo&quot;/&gt; 2、在指定包下编写类，增加注解 12345@Component(&quot;user&quot;)// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;public class User &#123; public String name = &quot;秦疆&quot;;&#125; 3、测试 1234567@Testpublic void test()&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); User user = (User) applicationContext.getBean(&quot;user&quot;); System.out.println(user.name);&#125; 8.2.属性注入 使用注解注入属性 1、可以不用提供set方法，直接在直接名上添加@value(“值”) 1234567@Component(&quot;user&quot;)// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;public class User &#123; @Value(&quot;秦疆&quot;) // 相当于配置文件中 &lt;property name=&quot;name&quot; value=&quot;秦疆&quot;/&gt; public String name;&#125; 2、如果提供了set方法，在set方法上添加@value(“值”); 12345678@Component(&quot;user&quot;)public class User &#123; public String name; @Value(&quot;秦疆&quot;) public void setName(String name) &#123; this.name = name; &#125;&#125; 8.3.衍生注解 我们这些注解，就是替代了在配置文件当中配置步骤而已！更加的方便快捷！ @Component三个衍生注解 为了更好的进行分层，Spring可以使用其它三个注解，功能一样，目前使用哪一个功能都一样。 @Controller：controller层 @Service：service层 @Repository：dao层 写上这些注解，就相当于将这个类交给Spring管理装配了！ 8.4.自动装配注解 在Bean的自动装配已经讲过了，可以回顾！ 8.5.作用域 @scope singleton：默认的，Spring会采用单例模式创建这个对象。关闭工厂 ，所有的对象都会销毁。 prototype：多例模式。关闭工厂 ，所有的对象不会销毁。内部的垃圾回收机制会回收 123456@Controller(&quot;user&quot;)@Scope(&quot;prototype&quot;)public class User &#123; @Value(&quot;秦疆&quot;) public String name;&#125; 8.6.小结 XML与注解比较 XML可以适用任何场景 ，结构清晰，维护方便 注解不是自己提供的类使用不了，开发简单方便 xml与注解整合开发 ：推荐最佳实践 xml管理Bean 注解完成属性注入 使用过程中， 可以不用扫描，扫描是为了类上的注解 1&lt;context:annotation-config&#x2F;&gt; 作用： 进行注解驱动注册，从而使注解生效 用于激活那些已经在spring容器里注册过的bean上面的注解，也就是显示的向Spring注册 如果不扫描包，就需要手动配置bean 如果不加注解驱动，则注入的值为null！ 9.基于Java类进行配置 JavaConfig 原来是 Spring 的一个子项目，它通过 Java 类的方式提供 Bean 的定义信息，在 Spring4 的版本， JavaConfig 已正式成为 Spring4 的核心功能 。 测试： 1、编写一个实体类，Dog 1234@Component //将这个类标注为Spring的一个组件，放到容器中！public class Dog &#123; public String name = &quot;dog&quot;;&#125; 2、新建一个config配置包，编写一个MyConfig配置类 123456789@Configuration //代表这是一个配置类@ComponentScan(&quot;com.kuang.pojo&quot;)//扫描,如果class类里面有注解的话public class MyConfig &#123; @Bean //通过方法注册一个bean，这里的返回值就Bean的类型，方法名就是bean的id！ public Dog dog()&#123; return new Dog(); &#125;&#125; 3、测试 12345678@Testpublic void test2()&#123; //完全使用配置类的方式要AnnotationConfigApplicationContext获取上下文资源 ApplicationContext applicationContext = new AnnotationConfigApplicationContext(MyConfig.class); Dog dog = (Dog) applicationContext.getBean(&quot;dog&quot;); System.out.println(dog.name);&#125; 4、成功输出结果！ 导入其他配置如何做呢？ 1、我们再编写一个配置类！ 123@Configuration &#x2F;&#x2F;代表这是一个配置类public class MyConfig2 &#123;&#125; 2、在之前的配置类中我们来选择导入这个配置类 123456789@Configuration@Import(MyConfig2.class) //导入合并其他配置类，类似于配置文件中的 inculde 标签public class MyConfig &#123; @Bean public Dog dog()&#123; return new Dog(); &#125;&#125; 关于这种Java类的配置方式，我们在之后的SpringBoot 和 SpringCloud中还会大量看到，我们需要知道这些注解的作用即可！ 10.代理模式 为什么要学习代理模式，因为AOP的底层机制就是动态代理！ 代理模式： 静态代理 动态代理 学习aop之前 , 我们要先了解一下代理模式！ 10.1静态代理 静态代理角色分析 抽象角色 : 一般使用接口或者抽象类来实现 真实角色 : 被代理的角色 代理角色 : 代理真实角色 ; 代理真实角色后 , 一般会做一些附属的操作 . 客户 : 使用代理角色来进行一些操作 . 代码实现 Rent . java 即抽象角色 1234//抽象角色：租房public interface Rent &#123; public void rent();&#125; Host . java 即真实角色 123456//真实角色: 房东，房东要出租房子public class Host implements Rent&#123; public void rent() &#123; System.out.println(&quot;房屋出租&quot;); &#125;&#125; Proxy . java 即代理角色 1234567891011121314151617181920212223//代理角色：中介public class Proxy implements Rent &#123; private Host host; public Proxy() &#123; &#125; public Proxy(Host host) &#123; this.host = host; &#125; //租房 public void rent()&#123; seeHouse(); host.rent(); fare(); &#125; //看房 public void seeHouse()&#123; System.out.println(&quot;带房客看房&quot;); &#125; //收中介费 public void fare()&#123; System.out.println(&quot;收中介费&quot;); &#125;&#125; Client . java 即客户 1234567891011//客户类，一般客户都会去找代理！public class Client &#123; public static void main(String[] args) &#123; //房东要租房 Host host = new Host(); //中介帮助房东 Proxy proxy = new Proxy(host); //你去找中介！ proxy.rent(); &#125;&#125; 分析：在这个过程中，你直接接触的就是中介，就如同现实生活中的样子，你看不到房东，但是你依旧租到了房东的房子通过代理，这就是所谓的代理模式，程序源自于生活，所以学编程的人，一般能够更加抽象的看待生活中发生的事情。 静态代理的好处: 可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 . 公共的业务由代理来完成 . 实现了业务的分工 , 公共业务发生扩展时变得更加集中和方便 . 缺点 : 类多了 , 多了代理类 , 工作量变大了 . 开发效率降低 . 我们想要静态代理的好处，又不想要静态代理的缺点，所以 , 就有了动态代理 ! 10.2.静态代理再理解 同学们练习完毕后，我们再来举一个例子，巩固大家的学习！ 练习步骤： 1、创建一个抽象角色，比如咋们平时做的用户业务，抽象起来就是增删改查！ 1234567//抽象角色：增删改查业务public interface UserService &#123; void add(); void delete(); void update(); void query();&#125; 2、我们需要一个真实对象来完成这些增删改查操作 12345678910111213141516171819//真实对象，完成增删改查操作的人public class UserServiceImpl implements UserService &#123; public void add() &#123; System.out.println(&quot;增加了一个用户&quot;); &#125; public void delete() &#123; System.out.println(&quot;删除了一个用户&quot;); &#125; public void update() &#123; System.out.println(&quot;更新了一个用户&quot;); &#125; public void query() &#123; System.out.println(&quot;查询了一个用户&quot;); &#125;&#125; 3、需求来了，现在我们需要增加一个日志功能，怎么实现！ 思路1 ：在实现类上增加代码 【麻烦！】 思路2：使用代理来做，能够不改变原来的业务情况下，实现此功能就是最好的了！ 4、设置一个代理类来处理日志！代理角色 123456789101112131415161718192021222324252627282930313233//代理角色，在这里面增加日志的实现public class UserServiceProxy implements UserService &#123; private UserServiceImpl userService; public void setUserService(UserServiceImpl userService) &#123; this.userService = userService; &#125; public void add() &#123; log(&quot;add&quot;); userService.add(); &#125; public void delete() &#123; log(&quot;delete&quot;); userService.delete(); &#125; public void update() &#123; log(&quot;update&quot;); userService.update(); &#125; public void query() &#123; log(&quot;query&quot;); userService.query(); &#125; public void log(String msg)&#123; System.out.println(&quot;执行了&quot;+msg+&quot;方法&quot;); &#125;&#125; 5、测试访问类： 123456789101112public class Client &#123; public static void main(String[] args) &#123; //真实业务 UserServiceImpl userService = new UserServiceImpl(); //代理类 UserServiceProxy proxy = new UserServiceProxy(); //使用代理类实现日志功能！ proxy.setUserService(userService); proxy.add(); &#125;&#125; OK，到了现在代理模式大家应该都没有什么问题了，重点大家需要理解其中的思想； 我们在不改变原来的代码的情况下，实现了对原有功能的增强，这是AOP中最核心的思想 聊聊AOP：纵向开发，横向开发 AOP横向放代理,辅助纵向开发 10.3动态代理（反射） 动态代理的角色和静态代理的一样 . 动态代理的代理类是动态生成的 . 静态代理的代理类是我们提前写好的 动态代理分为两类 : 一类是基于接口动态代理 , 一类是基于类的动态代理 基于接口的动态代理----JDK动态代理 基于类的动态代理–cglib 现在用的比较多的是 javasist 来生成动态代理 . 百度一下javasist 我们这里使用JDK的原生代码来实现，其余的道理都是一样的！、 JDK的动态代理需要了解两个类 核心 : InvocationHandler 和 Proxy ， 打开JDK帮助文档看看 【InvocationHandler：调用处理程序】 唯一方法 12345Object invoke(Object proxy, 方法 method, Object[] args)；//参数//proxy - 调用该方法的代理实例//method -所述方法对应于调用代理实例上的接口方法的实例。方法对象的声明类将是该方法声明的接口，它可以是代理类继承该方法的代理接口的超级接口。//args -包含的方法调用传递代理实例的参数值的对象的阵列，或null如果接口方法没有参数。原始类型的参数包含在适当的原始包装器类的实例中，例如java.lang.Integer或java.lang.Boolean 。 【Proxy : 代理】 1234//生成代理类public Object getProxy()&#123; return Proxy.newProxyInstance(this.getClass().getClassLoader(),rent.getClass().getInterfaces(),this);&#125; 代码实现 抽象角色和真实角色和之前的一样！ Rent . java 即抽象角色 1234//抽象角色：租房public interface Rent &#123; public void rent();&#125; Host . java 即真实角色 123456//真实角色: 房东，房东要出租房子public class Host implements Rent&#123; public void rent() &#123; System.out.println(&quot;房屋出租&quot;); &#125;&#125; ProxyInvocationHandler. java 即代理角色 1234567891011121314151617181920212223242526272829public class ProxyInvocationHandler implements InvocationHandler &#123; private Rent rent; public void setRent(Rent rent) &#123; this.rent = rent; &#125; //生成代理类，重点是第二个参数，获取要代理的抽象角色！之前都是一个角色，现在可以代理一类角色 public Object getProxy()&#123; return Proxy.newProxyInstance(this.getClass().getClassLoader(), rent.getClass().getInterfaces(),this); &#125; // proxy : 代理类 method : 代理类的调用处理程序的方法对象. // 处理代理实例上的方法调用并返回结果 @Override public Object invoke(Object proxy, Method method, Object[] args) throwsThrowable &#123; seeHouse(); //核心：本质利用反射实现！ Object result = method.invoke(rent, args); fare(); return result; &#125; //看房 public void seeHouse()&#123; System.out.println(&quot;带房客看房&quot;); &#125; //收中介费 public void fare()&#123; System.out.println(&quot;收中介费&quot;); &#125;&#125; Client . java 1234567891011121314//租客public class Client &#123; public static void main(String[] args) &#123; //真实角色 Host host = new Host(); //代理实例的调用处理程序 ProxyInvocationHandler pih = new ProxyInvocationHandler(); //通过调用程序处理角色处理我们要调用的对象，将真实角色放置进去！ pih.setRent(host); Rent proxy = (Rent)pih.getProxy(); //动态生成对应的代理类！ proxy.rent(); &#125;&#125; 核心：一个动态代理 , 一般代理某一类业务 , 一个动态代理可以代理多个类，代理的是接口！、 10.4深化理解 我们来使用动态代理实现代理我们后面写的UserService！ 我们也可以编写一个通用的动态代理实现的类！所有的代理对象设置为Object即可！ 12345678910111213141516171819202122232425public class ProxyInvocationHandler implements InvocationHandler &#123; private Object target; public void setTarget(Object target) &#123; this.target = target; &#125; //生成代理类 public Object getProxy()&#123; return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(),this); &#125; // proxy : 代理类 // method : 代理类的调用处理程序的方法对象. public Object invoke(Object proxy, Method method, Object[] args) throwsThrowable &#123; log(method.getName()); Object result = method.invoke(target, args); return result; &#125; public void log(String methodName)&#123; System.out.println(&quot;执行了&quot;+methodName+&quot;方法&quot;); &#125;&#125; 测试！ 1234567891011public class Test &#123; public static void main(String[] args) &#123; //真实对象 UserServiceImpl userService = new UserServiceImpl(); //代理对象的调用处理程序 ProxyInvocationHandler pih = new ProxyInvocationHandler(); pih.setTarget(userService); //设置要代理的对象 UserService proxy = (UserService)pih.getProxy(); //动态生成代理类！ proxy.delete(); &#125;&#125; 测试，增删改查，查看结果！ 10.5动态代理的好处 静态代理有的它都有，静态代理没有的，它也有！ 可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 . 公共的业务由代理来完成 . 实现了业务的分工 , 公共业务发生扩展时变得更加集中和方便 . 一个动态代理 , 一般代理某一类业务 一个动态代理可以代理多个类，代理的是接口！ 11.AOP 11.1.什么是AOP AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行**期动态代理实现程序功能的统一维护的一种技术。**AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 11.2.Aop在Spring中的作用 提供声明式事务；允许用户自定义切面 以下名词需要了解下： 横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点**。如日志 , 安全 , 缓存 , 事务等等 …** 切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。 --log类 通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。 --log类的方法 目标（Target）：被通知对象。 --接口或者方法 代理（Proxy）：向目标对象应用通知之后创建的对象。 切入点（PointCut）：切面通知 执行的 “地点”的定义。 ----------method invoke 连接点（JointPoint）：与切入点匹配的执行点。 SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice: 即 Aop 在 不改变原有代码的情况下 , 去增加新的功能 . 11.3.使用Spring实现Aop 【重点】使用AOP织入，需要导入一个依赖包！ 123456&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt; 11.3.1.通过 Spring API 实现 第一种方式 首先编写我们的业务接口和实现类 12345678910111213141516171819202122232425262728public interface UserService &#123; public void add(); public void delete(); public void update(); public void search();&#125;public class UserServiceImpl implements UserService&#123; @Override public void add() &#123; System.out.println(&quot;增加用户&quot;); &#125; @Override public void delete() &#123; System.out.println(&quot;删除用户&quot;); &#125; @Override public void update() &#123; System.out.println(&quot;更新用户&quot;); &#125; @Override public void search() &#123; System.out.println(&quot;查询用户&quot;); &#125;&#125; 然后去写我们的增强类 , 我们编写两个 , 一个前置增强 一个后置增强 12345678910111213141516171819202122public class Log implements MethodBeforeAdvice &#123; //method : 要执行的目标对象的方法 //objects : 被调用的方法的参数 //Object : 目标对象 @Override public void before(Method method, Object[] objects, Object o) throws Throwable &#123; System.out.println( o.getClass().getName() + &quot;的&quot; + method.getName() + &quot;方法被执行了&quot;); &#125;&#125;public class AfterLog implements AfterReturningAdvice &#123; //returnValue 返回值 //method被调用的方法 //args 被调用的方法的对象的参数 //target 被调用的目标对象 @Override public void afterReturning(Object returnValue, Method method, Object[] args,Object target) throws Throwable &#123; System.out.println(&quot;执行了&quot; + target.getClass().getName() +&quot;的&quot;+method.getName()+&quot;方法,&quot; +&quot;返回值：&quot;+returnValue); &#125;&#125; 最后去spring的文件中注册 , 并实现aop切入实现 , 注意导入约束 . 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--注册bean--&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.kuang.service.UserServiceImpl&quot;/&gt; &lt;bean id=&quot;log&quot; class=&quot;com.kuang.log.Log&quot;/&gt; &lt;bean id=&quot;afterLog&quot; class=&quot;com.kuang.log.AfterLog&quot;/&gt; &lt;!--aop的配置--&gt; &lt;aop:config&gt; &lt;!--切入点 expression:表达式匹配要执行的方法 excution(执行的位置：修饰词，返回值，列名，方法名，参数)--&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;/&gt; &lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点和id=&quot;pointcut&quot;对应--&gt; &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;/aop:config&gt;&lt;/beans&gt; **一、execution：**使用“execution(方法表达式)”匹配方法执行； 模式 描述 public * *(…) 任何公共方法的执行 * cn.javass…IPointcutService.*() cn.javass包及所有子包下IPointcutService接口中的任何无参方法 * cn.javass….(…) cn.javass包及所有子包下任何类的任何方法 * cn.javass…IPointcutService.() cn.javass包及所有子包下IPointcutService接口的任何只有一个参数方法 测试 12345678public class MyTest &#123; @Test public void test()&#123; ApplicationContext context = newClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserService userService = (UserService) context.getBean(&quot;userService&quot;); userService.search(); &#125;&#125; Aop的重要性 : 很重要 . 一定要理解其中的思路 , 主要是思想的理解这一块 . Spring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 , 其本质还是动态代理 . 11.3.2.自定义类来实现Aop（推荐） 第二种方式 目标业务类不变依旧是userServiceImpl 相对简单，但是没法对参数便捷的操作 第一步 : 写我们自己的一个切入类 123456789public class DiyPointcut &#123; public void before()&#123; System.out.println(&quot;---------方法执行前---------&quot;); &#125; public void after()&#123; System.out.println(&quot;---------方法执行后---------&quot;); &#125;&#125; 去spring中配置 12345678910111213&lt;!--第二种方式自定义实现--&gt;&lt;!--注册bean--&gt;&lt;bean id=&quot;diy&quot; class=&quot;com.kuang.config.DiyPointcut&quot;/&gt;&lt;!--aop的配置--&gt;&lt;aop:config&gt; &lt;!--第二种方式：使用AOP的标签实现--&gt; &lt;aop:aspect ref=&quot;diy&quot;&gt; &lt;aop:pointcut id=&quot;diyPonitcut&quot; expression=&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;/&gt; &lt;aop:before pointcut-ref=&quot;diyPonitcut&quot; method=&quot;before&quot;/&gt; &lt;aop:after pointcut-ref=&quot;diyPonitcut&quot; method=&quot;after&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 测试： 12345678public class MyTest &#123; @Test public void test()&#123; ApplicationContext context = newClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserService userService = (UserService) context.getBean(&quot;userService&quot;); userService.add(); &#125;&#125; 11.3.4.使用注解实现 第三种方式 第一步：编写一个注解实现的增强类—要导入正确的包 123456789101112131415161718192021222324252627282930package com.kuang.config;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;@Aspectpublic class AnnotationPointcut &#123; @Before(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;) public void before()&#123; System.out.println(&quot;---------方法执行前---------&quot;); &#125; @After(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;) public void after()&#123; System.out.println(&quot;---------方法执行后---------&quot;); &#125; @Around(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;) public void around(ProceedingJoinPoint jp) throws Throwable &#123; System.out.println(&quot;环绕前&quot;); System.out.println(&quot;签名:&quot;+jp.getSignature()); //执行的方法本身 //执行目标方法proceed Object proceed = jp.proceed(); System.out.println(&quot;环绕后&quot;); System.out.println(proceed); &#125;&#125; 1234567&#x2F;&#x2F;输出 了解环绕和执行方法的先后顺序环绕前signature void com.kaung.service.UserService.search()---------方法执行前---------查询用户---------执行前------------环绕后 第二步：在Spring配置文件中，注册bean，并增加支持注解的配置 可以直接@Component(“user”) // 相当于配置文件中 123&lt;!--第三种方式:注解实现--&gt;&lt;bean id=&quot;annotationPointcut&quot; class=&quot;com.kuang.config.AnnotationPointcut&quot;/&gt;&lt;aop:aspectj-autoproxy/&gt; aop:aspectj-autoproxy：了解有个参数 通过aop命名空间的&lt;aop:aspectj-autoproxy /&gt;声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。当然，spring 在内部依旧采用AnnotationAwareAspectJAutoProxyCreator进行自动代理的创建工作，但具体实现的细节已经被&lt;aop:aspectj-autoproxy /&gt;隐藏起来了 &lt;aop:aspectj-autoproxy /&gt;有一个proxy-target-class属性，默认为false，表示使用jdk动态代理织入增强，当配为&lt;aop:aspectj-autoproxy poxy-target-class=“true”/&gt;时，表示使用CGLib动态代理技术织入增强。不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。 12.整合MyBatis 文档：http://mybatis.org/spring/zh/getting-started.html 步骤 1、导入相关jar包 junit 12345&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt; mybatis 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt; mysql-connector-java 12345&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt;&lt;/dependency&gt; spring相关 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.10.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.10.RELEASE&lt;/version&gt;&lt;/dependency&gt; aspectJ AOP 织入器 123456&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt; mybatis-spring整合包 【重点】 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt; 配置Maven静态资源过滤问题！ 123456789101112&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 2、编写配置文件 3、代码实现 12.1回忆MyBatis 编写pojo实体类 1234567package com.kuang.pojo;public class User &#123; private int id; //id private String name; //姓名 private String pwd; //密码&#125; 实现mybatis的配置文件 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.kuang.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;package name=&quot;com.kuang.dao&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; UserDao接口编写 123public interface UserMapper &#123; public List&lt;User&gt; selectUser();&#125; 接口对应的Mapper映射文件 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.kuang.dao.UserMapper&quot;&gt; &lt;select id=&quot;selectUser&quot; resultType=&quot;User&quot;&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 测试类 1234567891011121314151617@Testpublic void selectUser() throws IOException &#123; String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = newSqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; userList = mapper.selectUser(); for (User user: userList)&#123; System.out.println(user); &#125; sqlSession.close();&#125; 12.2.MyBatis-Spring学习 引入Spring之前需要了解mybatis-spring包中的一些重要类； http://www.mybatis.org/spring/zh/index.html 什么是 MyBatis-Spring？ MyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中。 知识基础 在开始使用 MyBatis-Spring 之前，你需要先熟悉 Spring 和 MyBatis 这两个框架和有关它们的术语。这很重要 MyBatis-Spring 需要以下版本： MyBatis-Spring MyBatis Spring 框架 Spring Batch Java 2.0 3.5+ 5.0+ 4.0+ Java 8+ 1.3 3.4+ 3.2.2+ 2.1+ Java 6+ 如果使用 Maven 作为构建工具，仅需要在 pom.xml 中加入以下代码即可： 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt; 要和 Spring 一起使用 MyBatis，需要在 Spring 应用上下文中定义至少两样东西：一个 SqlSessionFactory 和至少一个数据映射器类。 在 MyBatis-Spring 中，可使用SqlSessionFactoryBean来创建 SqlSessionFactory。要配置这个工厂 bean，只需要把下面代码放在 Spring 的 XML 配置文件中： 123&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt; 注意：SqlSessionFactory需要一个 DataSource（数据源）。这可以是任意的 DataSource，只需要和配置其它 Spring 数据库连接一样配置它就可以了。 在基础的 MyBatis 用法中，是通过 SqlSessionFactoryBuilder 来创建 SqlSessionFactory 的。而在 MyBatis-Spring 中，则使用 SqlSessionFactoryBean 来创建。 在 MyBatis 中，你可以使用 SqlSessionFactory 来创建 SqlSession。一旦你获得一个 session 之后，你可以使用它来执行映射了的语句，提交或回滚连接，最后，当不再需要它的时候，你可以关闭 session。 SqlSessionFactory有一个唯一的必要属性：用于 JDBC 的 DataSource。这可以是任意的 DataSource 对象，它的配置方法和其它 Spring 数据库连接是一样的。 一个常用的属性是 configLocation，它用来指定 MyBatis 的 XML 配置文件路径。它在需要修改 MyBatis 的基础配置非常有用。通常，基础配置指的是 &lt; settings&gt; 或 &lt; typeAliases&gt;元素。 需要注意的是，这个配置文件并不需要是一个完整的 MyBatis 配置。确切地说，任何环境配置（），数据源（）和 MyBatis 的事务管理器（）都会被忽略。SqlSessionFactoryBean 会创建它自有的 MyBatis 环境配置（Environment），并按要求设置自定义环境的值。 SqlSessionTemplate 是 MyBatis-Spring 的核心。作为 SqlSession 的一个实现，这意味着可以使用它无缝代替你代码中已经在使用的 SqlSession。 模板可以参与到 Spring 的事务管理中，并且由于其是线程安全的，可以供多个映射器类使用，你应该总是用 SqlSessionTemplate 来替换 MyBatis 默认的 DefaultSqlSession 实现。在同一应用程序中的不同类之间混杂使用可能会引起数据一致性的问题。 可以使用 SqlSessionFactory 作为构造方法的参数来创建 SqlSessionTemplate 对象。 123&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot; /&gt;&lt;/bean&gt; 现在，这个 bean 就可以直接注入到你的 DAO bean 中了。你需要在你的 bean 中添加一个 SqlSession 属性，就像下面这样： 123456789101112public class UserDaoImpl implements UserDao &#123; private SqlSession sqlSession; public void setSqlSession(SqlSession sqlSession) &#123; this.sqlSession = sqlSession;&#125; public User getUser(String userId) &#123; return sqlSession.getMapper...;&#125;&#125; 按下面这样，注入 SqlSessionTemplate： 123&lt;bean id=&quot;userDao&quot; class=&quot;org.mybatis.spring.sample.dao.UserDaoImpl&quot;&gt; &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot; /&gt;&lt;/bean&gt; 12.3.整合实现一（建议） 1、引入Spring配置文件beans.xml 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; 2、配置数据源替换mybaits的数据源 1234567&lt;!--配置数据源：数据源有非常多，可以使用第三方的，也可使使用Spring的--&gt;&lt;bean id=&quot;dataSource&quot;class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;&lt;/bean&gt; 3、配置SqlSessionFactory，关联MyBatis 1234567&lt;!--配置SqlSessionFactory--&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!--关联Mybatis--&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; 绑定mybatis的地址 &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/kuang/dao/*.xml&quot;/&gt;&lt;/bean&gt; 建议：可以在mybatis配置文件中保留 setting 和别名 4、注册sqlSessionTemplate(模板性质等价于sqlSession线程安全)，关联sqlSessionFactory； 12345&lt;!--注册sqlSessionTemplate , 关联sqlSessionFactory--&gt;&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;!--通过源码了解到只能利用构造器注入--&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt; 5、核心：简化的代码， 增加Dao接口的实现类；私有化sqlSessionTemplate 1234567891011121314public class UserDaoImpl implements UserMapper &#123; //sqlSession不用我们自己创建了，Spring来管理 private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) &#123; this.sqlSession = sqlSession; &#125; public List&lt;User&gt; selectUser() &#123; UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.selectUser(); &#125;&#125; 6、注册bean实现 123&lt;bean id=&quot;userDao&quot; class=&quot;com.kuang.dao.UserDaoImpl&quot;&gt; &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot;/&gt;&lt;/bean&gt; 7、测试 1234567 @Test public void test2()&#123; ApplicationContext context = newClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserMapper mapper = (UserMapper) context.getBean(&quot;userDao&quot;); List&lt;User&gt; user = mapper.selectUser(); System.out.println(user);&#125; 结果成功输出！现在我们的Mybatis配置文件的状态！发现都可以被Spring整合！ 方便起见也可以简化resources的内容 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.kuang.pojo&quot;/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; 12.4.整合实现二 mybatis-spring1.2.3版以上的才有这个 . 可以在application中整合xml 官方文档截图 : dao继承Support类 , 直接利用 getSqlSession() 获得 , 然后直接注入SqlSessionFactory . 比起方式1 , 不需要管理SqlSessionTemplate , 而且对事务的支持更加友好 . 可跟踪源码查看 测试： 1、将我们上面写的UserDaoImpl修改一下 123456public class UserDaoImpl extends SqlSessionDaoSupport implements UserMapper &#123; public List&lt;User&gt; selectUser() &#123; UserMapper mapper = getSqlSession().getMapper(UserMapper.class); return mapper.selectUser(); &#125;&#125; 原理 2、修改bean的配置 123&lt;bean id=&quot;userDao&quot; class=&quot;com.kuang.dao.UserDaoImpl&quot;&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;&lt;/bean&gt; 3、测试 1234567@Testpublic void test2()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserMapper mapper = (UserMapper) context.getBean(&quot;userDao&quot;); List&lt;User&gt; user = mapper.selectUser(); System.out.println(user);&#125; 总结 : 整合到spring以后可以完全不要mybatis的配置文件，除了这些方式可以实现整合之外，我们还可以使用注解来实现，这个等我们后面学习SpringBoot的时候还会测试整合！ 13.声明式事务 13.1.回顾事务 事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！ 事务管理是企业级应用程序开发中必备技术，用来确保数据的完整性和一致性。 事务就是把一系列的动作当成一个独立的工作单元，这些动作要么全部完成，要么全部不起作用。 事务四个属性ACID 原子性（atomicity） 事务是原子性操作，由一系列动作组成，事务的原子性确保动作要么全部完成，要么完全不起作用 一致性（consistency） 一旦所有事务动作完成，事务就要被提交。数据和资源处于一种满足业务规则的一致性状态中 隔离性（isolation） 可能多个事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏 持久性（durability） 事务一旦完成，无论系统发生什么错误，结果都不会受到影响。通常情况下，事务的结果被写到持久化存储器中 测试 将上面的代码拷贝到一个新项目中 在之前的案例中，我们给userDao接口新增两个方法，删除和增加用户； 12345//添加一个用户int addUser(User user);//根据id删除用户int deleteUser(int id); mapper文件，我们故意把 deletes 写错，测试！ 1234567&lt;insert id=&quot;addUser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt;insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)&lt;/insert&gt;&lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;deletes from user where id = #&#123;id&#125;&lt;/delete&gt; 编写接口的实现类，在实现类中，我们去操作一波 1234567891011121314151617181920212223public class UserDaoImpl extends SqlSessionDaoSupport implements UserMapper &#123; //增加一些操作 public List&lt;User&gt; selectUser() &#123; User user = new User(4,&quot;小明&quot;,&quot;123456&quot;); UserMapper mapper = getSqlSession().getMapper(UserMapper.class); mapper.addUser(user); mapper.deleteUser(4); return mapper.selectUser(); &#125; //新增 public int addUser(User user) &#123; UserMapper mapper = getSqlSession().getMapper(UserMapper.class); return mapper.addUser(user); &#125; //删除 public int deleteUser(int id) &#123; UserMapper mapper = getSqlSession().getMapper(UserMapper.class); return mapper.deleteUser(id); &#125;&#125; 测试 1234567@Testpublic void test2()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserMapper mapper = (UserMapper) context.getBean(&quot;userDao&quot;); List&lt;User&gt; user = mapper.selectUser(); System.out.println(user);&#125; 报错：sql异常，delete写错了 结果 ：插入成功！ 没有进行事务的管理；我们想让他们都成功才成功，有一个失败，就都失败，我们就应该需要事务！ 以前我们都需要自己手动管理事务，十分麻烦！ 但是Spring给我们提供了事务管理，我们只需要配置即可； 13.2.Spring中的事务管理 Spring在不同的事务管理API之上定义了一个抽象层，使得开发人员不必了解底层的事务管理API就可以使用Spring的事务管理机制。Spring支持编程式事务管理和声明式的事务管理。 编程式事务管理 将事务管理代码嵌到业务方法中来控制事务的提交和回滚 缺点：必须在每个事务操作业务逻辑中包含额外的事务管理代码 声明式事务管理AOP（建议） 一般情况下比编程式事务好用。 将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。 将事务管理作为横切关注点**，通过aop方法模块化。Spring中通过Spring AOP框架支持声明式事务管理。** 使用Spring管理事务，注意头文件的约束导入 : tx 1234xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;http://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; 事务管理器 无论使用Spring的哪种事务管理策略（编程式或者声明式）事务管理器都是必须的。 就是 Spring的核心事务管理抽象，管理封装了一组独立于技术的方法。 JDBC事务 123&lt;bean id=&quot;transactionManager&quot;class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt; 配置好事务管理器后我们需要去配置事务的通知 123456789101112&lt;!--配置事务通知--&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!--配置哪些方法使用什么样的事务,配置事务的传播特性--&gt; &lt;tx:method name=&quot;add&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;delete&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;update&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;search*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;get&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; spring事务传播特性： 事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。spring支持7种事务传播行为： propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。 propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。 propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。 propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。 propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。 propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作 Spring 默认的事务传播行为是 PROPAGATION_REQUIRED，它适合于绝大多数的情况。 假设 ServiveX#methodX() 都工作在事务环境下（即都被 Spring 事务增强了），假设程序中存在如下的调用链：Service1#method1()-&gt;Service2#method2()-&gt;Service3#method3()，那么这 3 个服务类的 3 个方法通过 Spring 的事务传播机制都工作在同一个事务中。 就好比，我们刚才的几个方法存在调用，所以会被放在一组事务当中！ 配置AOP 导入aop的头文件！ 12345&lt;!--配置aop织入事务--&gt;&lt;aop:config&gt; &lt;aop:pointcut id=&quot;txPointcut&quot; expression=&quot;execution(* com.kuang.dao.*.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointcut&quot;/&gt;&lt;/aop:config&gt; 进行测试 删掉刚才插入的数据，再次测试！ 1234567@Testpublic void test2()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserMapper mapper = (UserMapper) context.getBean(&quot;userDao&quot;); List&lt;User&gt; user = mapper.selectUser(); System.out.println(user);&#125; 13.3.思考问题？ 为什么需要配置事务？ 如果不配置，就需要我们手动提交控制事务； 事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"后端学习","slug":"后端学习","permalink":"http://example.com/tags/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"python简单数据爬取","slug":"python简单爬取数据","date":"2021-03-31T02:58:10.000Z","updated":"2021-04-23T13:10:58.943Z","comments":true,"path":"2021/03/31/python简单爬取数据/","link":"","permalink":"http://example.com/2021/03/31/python%E7%AE%80%E5%8D%95%E7%88%AC%E5%8F%96%E6%95%B0%E6%8D%AE/","excerpt":"","text":"入门 1、爬取一张图的演示 简单地爬取一张图片演示（当然不可能吃饱了撑着去爬一张图，要用循环去爬取，当然前提得先找到图片路径的规律，可以用正则比如 xxx.jpg就去爬下来） 123456789101112131415#!/usr/bin/python3# -*- coding: utf-8 -*-# 发送请求的模块import requestsif __name__ == &#x27;__main__&#x27;: # main函数入口 # 图片的地址，可以访问这个网址看看 url = &quot;https://pic.qiushibaike.com/system/pictures/12354/123544829/medium/WT5DHEEQ4LJQL55Z.jpg&quot; # get方法获取url img_data = requests.get(url=url).content #content返回的是二进制形式的数据 # .text (字符串) .content(二进制) .json() (json对象) # 向当前目录下qiutu.jpg文件（没有则创建）写入二进制数据（构成图片） with open(&quot;qiutu.jpg&quot;, &quot;wb&quot;) as fp: fp.write(img_data) print(&quot;over!&quot;) 可以小结一下要怎么爬？ 2、爬取搜狗主页 html实际是text，爬取的格式为.text，不过最烦的就是编码，一般先将其encoding改成 ‘utf-8’ 再转text 12345678910111213#!/usr/bin/python3# -*- coding: utf-8 -*-import requestsif __name__ == &#x27;__main__&#x27;: url = &quot;https://www.sogou.com/&quot; response = requests.get(url=url) response.encoding = &quot;utf-8&quot; #text返回字符串形式的响应数据 page_text = response.text with open(&#x27;sogou.html&#x27;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as fp: fp.write(page_text) print(&quot;爬取数据结束!!&quot;) 3、爬豆瓣 这例子不是很好 123456789101112131415161718192021222324252627import requests# 解析jsonimport jsonif __name__ == &#x27;__main__&#x27;: url = &quot;https://movie.douban.com/j/chart/top_list&quot; # param是get方法或post方法中要传入的参数 param = &#123; &quot;type&quot;: &quot;24&quot;, &quot;interval_id&quot;: &quot;100:90&quot;, &quot;action&quot;:&#x27;&#x27;, &quot;start&quot;: &quot;0&quot;,#开始电影排名数 &quot;limit&quot;: &quot;100&quot;,#一次请求取出的个数 &#125; # headers是为了进行UA伪装，要不然躲不过这些网址的最基本的爬虫检查，这个headers就是浏览器F12里的Request-Header里面可以写好多字典类型的参数 headers = &#123; &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.81 Safari/537.36 SE 2.X MetaSr 1.0&quot; &#125; # 请求方法get中传入相应参数，就会返回一个response封装了所有响应信息 response = requests.get(url=url,params=param,headers=headers) list_data = response.json() # 这里的json对象要用list接收 fp = open(&#x27;douban.json&#x27;, &quot;w&quot;, encoding=&quot;utf-8&quot;) # 解析json数据(去掉一些转义字符啥的,然后将列表转换成字符串)并保存 json.dump(list_data, fp=fp,ensure_ascii=False) print(&quot;Over!&quot;) 4、爬取全国城市名称 url:https://www.aqistudy.cn/historydata/ 打开链接再按F12 看到了链接historydata 这个例子中以上信息并无卵用 下面的才有用 先定位到全部城市 发现规律了吗？ 城市名都在标签中，接下来只要准确的分类出这些标签再提前其中的文字，就能把城市全部爬下来 又发现这些标签都在标签中，就这样一层一层往外去定位它 etree使用参考: https://www.sogou.com/link?url=hedJjaC291MPna5SxlQUxvo1ussxympppRtRuDDMvTbY09i1Nqimpw… https://www.cnblogs.com/lei0213/p/7506130.html 使用etree(xpath解析)来解析 1234567891011121314151617181920import requests# etree模块from lxml import etree# 项目需求:解析出所有城市名称https://www.aqistudy.cn/historydata/if __name__ == &#x27;__main__&#x27;: url = &quot;https://www.aqistudy.cn/historydata/&quot; headers = &#123; &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.121 Safari/537.36 Edg/85.0.564.68&quot; &#125; # 先爬下整个html page_text = requests.get(url=url, headers=headers).text # 创建etree对象 tree = etree.HTML(page_text) a_list = tree.xpath(&quot;//div[@class=&#x27;bottom&#x27;]/ul/li/a | //div[@class=&#x27;bottom&#x27;]/ul/div[2]/li/a&quot;) all_city_names = [] for a in a_list: city_name = a.xpath(&quot;./text()&quot;)[0] all_city_names.append(city_name) # * 将列表转换成空格隔开的字符 print(*all_city_names,len(all_city_names)) 5、分页爬取 就是拼接url url:https://www.qiushibaike.com/imgrank/page/1/ 注意到url就只用1,2,3,4这样变，就可以用字符串拼接 12345678910111213141516171819202122232425262728293031323334#!/usr/bin/python3# -*- coding: utf-8 -*-import requestsimport reimport osimport timeif __name__ == &#x27;__main__&#x27;: if not os.path.exists(&#x27;qiutuLibs&#x27;): os.mkdir(&#x27;qiutuLibs&#x27;) url = &quot;https://www.qiushibaike.com/imgrank/page/%d/&quot; pageNum = 2 headers = &#123; &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.81 Safari/537.36 SE 2.X MetaSr 1.0&quot; &#125; for pageNum in range(1,36): new_url = format(url%pageNum) page_text = requests.get(url=url,headers=headers).text ex = &#x27;&lt;div class=&quot;thumb&quot;&gt;.*?&lt;img src=&quot;(.*?)&quot; alt.*?&lt;/div&gt;&#x27; img_src_list = re.findall(ex,page_text,re.S)#re.S多行匹配，re.M单行匹配 for src in img_src_list: #拼接处一个完整的url src = &#x27;https:&#x27; + src #请求到了图片的二进制数据 img_data = requests.get(url = src,headers = headers).content #生成图片名称 img_name = src.split(&#x27;/&#x27;)[-1] # 放入文件夹qiutuLibs中 imgPath = &#x27;./qiutuLibs&#x27; + img_name with open(imgPath,&#x27;wb&#x27;) as fp: fp.write(img_data) print(img_name,&#x27;下载成功!!!&#x27;) time.sleep(0.1) 进阶 重点：Selenium(使用自动化实现爬虫) 请参考视频教学，还要安装webdriver chromedriver下载地址:http://chromedriver.storage.googleapis.com/index.html 下载版本与你谷歌浏览器的版本一致 然后放python文件根目录 1、Selenium基础 一、 1234567891011121314151617181920212223from selenium import webdriverfrom lxml import etreefrom time import sleepif __name__ == &#x27;__main__&#x27;: # 实例化一个浏览器对象，可以不传入executable_path，如果你安装在该浏览器目录的化 bro = webdriver.Chrome() # 让浏览器发起一个指定url对应请求 bro.get(&quot;http://www.4399.com/&quot;) #通过webdriver获取浏览器当前页面源码数据 page_text = bro.page_source #游戏名称 tree = etree.HTML(page_text) li_list = tree.xpath(&#x27;//*[@id=&quot;skinbody&quot;]/div[10]/div[1]/div[1]/ul/li&#x27;) for li in li_list: name = li.xpath(&#x27;.//img/@alt&#x27;)[0] print(name) sleep(5) bro.quit() 二、 1234567891011121314151617181920212223242526from selenium import webdriverfrom time import sleepbro = webdriver.Chrome()bro.get(&#x27;https://www.taobao.com/&#x27;)# 标签定位search_input = bro.find_element_by_id(&#x27;q&#x27;)# 标签交互search_input.send_keys(&#x27;Iphone&#x27;)#执行一组is程序bro.execute_script(&#x27;window.scrollTo(0,document.body.scrollHeight)&#x27;)sleep(2)# 点击搜索按钮btn = bro.find_element_by_css_selector(&#x27;.btn-search&#x27;)btn.click()bro.get(&quot;https://www.baidu.com&quot;)sleep(2)# 回退bro.back()sleep(2)#前进bro.forward(2) 三、动作链和iframe处理 123456789101112131415161718192021222324252627282930#!/usr/bin/python3# -*- coding: utf-8 -*-from selenium import webdriverfrom time import sleep# 导入动作链对应的类from selenium.webdriver import ActionChainsbro = webdriver.Chrome()bro.get(&#x27;https://www.runoob.com/try/try.php?filename=jqueryui-api-droppable&#x27;)# 如果定位的标签是存在于iframe标签之中的则必须通过如下操作在进行标签定位bro.switch_to.frame(&#x27;iframeResult&#x27;) #切换浏览器标签定位的作用域div = bro.find_element_by_id(&#x27;draggable&#x27;)# 动作链action = ActionChains(bro)#点击长按指定的标签action.click_and_hold(div)for i in range(5): # perform()立即执行动作链操作 action.move_by_offset(17,0).perform() sleep(0.3)print(div) 四、自动登陆qq空间 不行了，被反了，要滑块验证了 123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/python3# -*- coding: utf-8 -*-from selenium import webdriverfrom time import sleepUserName = &quot;xxxx&quot; # 你的qq账号Password = &quot;xxxx&quot; # 你的qq密码bro = webdriver.Chrome()bro.get(&quot;https://qzone.qq.com/&quot;)sleep(5)bro.switch_to.frame(&quot;login_frame&quot;)a_tag = bro.find_element_by_id(&#x27;switcher_plogin&#x27;)a_tag.click()sleep(1)userName_tag = bro.find_element_by_id(&#x27;u&#x27;)password_tag = bro.find_element_by_id(&#x27;p&#x27;)userName_tag.send_keys(UserName)sleep(1)password_tag.send_keys(Password)sleep(1)btn = bro.find_element_by_id(&quot;login_button&quot;)btn.click()sleep(3)# bro.quit() 要用到 爬取后保存到execel 后面爬的时候execel上面的那里要和数据库字段相对应 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130# -*- codeing = utf-8 -*-from bs4 import BeautifulSoup # 网页解析，获取数据import re # 正则表达式，进行文字匹配import urllib.request, urllib.error # 制定URL，获取网页数据import xlwt # 进行excel操作def main(): baseurl = &quot;https://movie.douban.com/top250?start=&quot; # 1.爬取网页 datalist = getData(baseurl) # savepath = &quot;豆瓣电影Top250.xls&quot; savepath = &quot;1.xls&quot; # 3.保存数据 saveData(datalist,savepath)# 影片详情链接的规则findLink = re.compile(r&#x27;&lt;a href=&quot;(.*?)&quot;&gt;&#x27;) # 创建正则表达式对象，表示规则（字符串的模式）# 影片图片findImgSrc = re.compile(r&#x27;&lt;img.*src=&quot;(.*?)&quot;&#x27;, re.S) # re.S 让换行符包含在字符中# 影片片名findTitle = re.compile(r&#x27;&lt;span class=&quot;title&quot;&gt;(.*)&lt;/span&gt;&#x27;)# 影片评分findRating = re.compile(r&#x27;&lt;span class=&quot;rating_num&quot; property=&quot;v:average&quot;&gt;(.*)&lt;/span&gt;&#x27;)# 找到评价人数findJudge = re.compile(r&#x27;&lt;span&gt;(\\d*)人评价&lt;/span&gt;&#x27;)# 找到概况findInq = re.compile(r&#x27;&lt;span class=&quot;inq&quot;&gt;(.*)&lt;/span&gt;&#x27;)# 找到影片的相关内容findBd = re.compile(r&#x27;&lt;p class=&quot;&quot;&gt;(.*?)&lt;/p&gt;&#x27;, re.S)# 爬取网页def getData(baseurl): datalist = [] for i in range(0, 10): # 调用获取页面信息的函数，10次 url = baseurl + str(i * 25) html = askURL(url) # 保存获取到的网页源码 # 2.逐一解析数据 soup = BeautifulSoup(html, &quot;html.parser&quot;) for item in soup.find_all(&#x27;div&#x27;, class_=&quot;item&quot;): # 查找符合要求的字符串，形成列表 # print(item) #测试：查看电影item全部信息 data = [] # 保存一部电影的所有信息 item = str(item) # 影片详情的链接 link = re.findall(findLink, item)[0] # re库用来通过正则表达式查找指定的字符串 data.append(link) # 添加链接 imgSrc = re.findall(findImgSrc, item)[0] data.append(imgSrc) # 添加图片 titles = re.findall(findTitle, item) # 片名可能只有一个中文名，没有外国名 if (len(titles) == 2): ctitle = titles[0] # 添加中文名 data.append(ctitle) otitle = titles[1].replace(&quot;/&quot;, &quot;&quot;) # 去掉无关的符号 data.append(otitle) # 添加外国名 else: data.append(titles[0]) data.append(&#x27; &#x27;) # 外国名字留空 rating = re.findall(findRating, item)[0] data.append(rating) # 添加评分 judgeNum = re.findall(findJudge, item)[0] data.append(judgeNum) # 提加评价人数 inq = re.findall(findInq, item) if len(inq) != 0: inq = inq[0].replace(&quot;。&quot;, &quot;&quot;) # 去掉句号 data.append(inq) # 添加概述 else: data.append(&quot; &quot;) # 留空 bd = re.findall(findBd, item)[0] bd = re.sub(&#x27;&lt;br(\\s+)?/&gt;(\\s+)?&#x27;, &quot; &quot;, bd) # 去掉&lt;br/&gt; bd = re.sub(&#x27;/&#x27;, &quot; &quot;, bd) # 替换/ data.append(bd.strip()) # 去掉前后的空格 datalist.append(data) # 把处理好的一部电影信息放入datalist return datalist# 得到指定一个URL的网页内容def askURL(url): head = &#123; # 模拟浏览器头部信息，向豆瓣服务器发送消息 &quot;User-Agent&quot;: &quot;Mozilla / 5.0(Windows NT 10.0; Win64; x64) AppleWebKit / 537.36(KHTML, like Gecko) Chrome / 80.0.3987.122 Safari / 537.36&quot; &#125; # 用户代理，表示告诉豆瓣服务器，我们是什么类型的机器、浏览器（本质上是告诉浏览器，我们可以接收什么水平的文件内容） request = urllib.request.Request(url, headers=head) html = &quot;&quot; try: response = urllib.request.urlopen(request) html = response.read().decode(&quot;utf-8&quot;) # print(html) except urllib.error.URLError as e: if hasattr(e, &quot;code&quot;): print(e.code) if hasattr(e, &quot;reason&quot;): print(e.reason) return html# 保存数据def saveData(datalist, savepath): print(&quot;save....&quot;) book = xlwt.Workbook(encoding=&quot;utf-8&quot;, style_compression=0) # 创建workbook对象 sheet = book.add_sheet(&#x27;豆瓣电影Top250&#x27;, cell_overwrite_ok=True) # 创建工作表 col = (&quot;电影详情链接&quot;, &quot;图片链接&quot;, &quot;影片中文名&quot;, &quot;影片外国名&quot;, &quot;评分&quot;, &quot;评价数&quot;, &quot;概况&quot;, &quot;相关信息&quot;) for i in range(0, 8): sheet.write(0, i, col[i]) # 列名 for i in range(0, 250): print(&quot;第%d条&quot; % (i + 1)) data = datalist[i] for j in range(0, 8): sheet.write(i + 1, j, data[j]) # 数据 book.save(savepath) # 保存if __name__ == &quot;__main__&quot;: # 当程序执行时 # 调用函数 main() # init_db(&quot;movietest.db&quot;) print(&quot;爬取完毕！&quot;) 注意 爬取的信息可以参考这张表【把所有的字段弄成第一行】,其中红线画出的是爬取的，其它的数据可以是伪造的，但不要去动product_id【让它为空】 爬取的图片名最好重命名一下，存入图片路径时(product_icon)，重命名成/products/img/图片名称 的形式【使用字符串拼接实现】 图片就打包发我","categories":[{"name":"数据获取","slug":"数据获取","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"}],"keywords":[{"name":"数据获取","slug":"数据获取","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96/"}]},{"title":"狂神说Mybatis","slug":"狂神说Mybatis","date":"2021-03-31T02:58:10.000Z","updated":"2021-04-02T07:19:33.686Z","comments":true,"path":"2021/03/31/狂神说Mybatis/","link":"","permalink":"http://example.com/2021/03/31/%E7%8B%82%E7%A5%9E%E8%AF%B4Mybatis/","excerpt":"","text":"MyBatis 1、简介 1.1 什么是Mybatis 文档：https://mybatis.org/mybatis-3/zh/getting-started.html MyBatis 是一款优秀的持久层框架; 它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 1.2 持久化 数据持久化 持久化就是将程序的数据在持久状态和瞬时状态转化的过程 内存：断电即失 数据库（Jdbc）,io文件持久化。 为什么要持久化？ 有一些对象，不能让他丢掉 内存太贵 1.3 持久层 Dao层、Service层、Controller层 完成持久化工作的代码块 层界限十分明显 1.4 为什么需要MyBatis 帮助程序员将数据存入到数据库中 方便 传统的JDBC代码太复杂了，简化，框架，自动化 不用MyBatis也可以，技术没有高低之分 优点： 简单易学 灵活 sql和代码的分离，提高了可维护性。 提供映射标签，支持对象与数据库的orm字段关系映射 提供对象关系映射标签，支持对象关系组建维护 提供xml标签，支持编写动态sql 2、第一个Mybatis程序 1234567891011121314--新建数据库CREATE DATABASE `mybatis`;USE `mybatis`CREATE TABLE `user`( `id` INT(20) NOT NULL , `name` VARCHAR(30) DEFAULT NULL, `pwd` VARCHAR(30) DEFAULT NULL, PRIMARY KEY(`id`))ENGINE=INNODB DEFAULT CHARSET=utf8;INSERT INTO `user` (`id`,`name`,`pwd`) VALUES(1,&#x27;蒋中正&#x27;,&#x27;123456&#x27;),(2,&#x27;张三&#x27;,&#x27;123456&#x27;),(3,&#x27;李四&#x27;,&#x27;123456&#x27;) 思路：搭建环境(普通的项目) --&gt; 导入MyBatis --&gt; 编写代码 --&gt; 测试 2.1 搭建环境 新建项目 创建一个普通的maven项目 删除src目录 （就可以把此工程当做父工程了，然后创建子工程） 导入maven依赖 12345678910111213141516171819202122&lt;!--导入依赖--&gt;&lt;dependencies&gt; &lt;!--mysqlq驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.12&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.4&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建一个Module 2.2 创建一个模块 编写mybatis的核心配置文件 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;!--configuration核心配置文件--&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;!---设置连接，&amp;amp；==&amp;--&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?userSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=UTC&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 编写mybatis工具类 每个基于 MyBatis 的应用都是以一个SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。类似于preparedStatement 12345678910111213141516171819202122//sqlSessionFactory --&gt; sqlSessionpublic class MybatisUtils &#123; static SqlSessionFactory sqlSessionFactory = null; static &#123; try &#123; //使用Mybatis第一步 ：获取sqlSessionFactory对象 String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例. // SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。工厂模式或者单例模式 public static SqlSession getSqlSession()&#123; return sqlSessionFactory.openSession(); &#125;&#125; 2.3 编写代码 实体类 Dao接口-&gt;mapper 123public interface UserDao &#123; public List&lt;User&gt; getUserList();&#125; 接口实现类 （由原来的UserDaoImpl转变为一个Mapper配置文件） 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--namespace=绑定一个指定的Dao/Mapper接口--&gt;&lt;mapper namespace=&quot;com.kuang.dao.UserDao&quot;&gt; &lt;!--id对应方法名--&gt; &lt;select id=&quot;getUserList&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt; select * from USER &lt;/select&gt;&lt;/mapper&gt; 2.4测试 注意点： org.apache.ibatis.binding.BindingException: Type interface com.kuang.dao.UserDao is not known to the MapperRegistry. MapperRegistry是什么? 核心配置文件中注册mappers，每一个都要注册 junit测试 12345678910111213141516@Testpublic void test()&#123; //1.获取SqlSession对象 SqlSession sqlSession = MybatisUtils.getSqlSession(); //2.执行SQL // 方式一：getMapper UserDao userDao = sqlSession.getMapper(UserDao.class); List&lt;User&gt; userList = userDao.getUserList(); for (User user : userList) &#123; System.out.println(user); &#125; //关闭sqlSession sqlSession.close();&#125; 2.5可能会遇到的问题： 配置文件没有注册 绑定接口错误，路径要对 方法名不对 返回类型不对 sql语句的问题空格等 Maven导出资源问题.pom文件中执行 123456789101112131415161718192021&lt;!--在build中配置resources，来防止我们资源导出失败的问题--&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 输出xml文件的中文乱码问题 命名空间，限定名，核心接口，SqlSessionFactoryBuilder 3、CURD 1. namespace namespace中的包名要和Dao/Mapper接口的包名一致 2. select 选择，查询语句； id：就是对应的namespace中的方法名； resultType : Sql语句执行的返回值；类为多 parameterType : 参数类型； 1.编写接口 123456789public interface UserMapper &#123; List&lt;User&gt; getUserList(); //获取用户信息 User getUserById(int id); //添加用户 int addUser(User user); int updateUser(User user); int deleteUser(int id);&#125; 2.编写对应的mapper中的sql语句 123456789101112131415161718192021&lt;!--查询全部--&gt;&lt;select id=&quot;getUserList&quot; resultType=&quot;com.kuang.pojo.User&quot; &gt; select * from mybatis.user&lt;/select&gt;&lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt; select * from mybatis.user where id=#&#123;id&#125;&lt;/select&gt;&lt;!-- 参数和返回值是int可以不写--&gt;&lt;insert id=&quot;addUser&quot; parameterType=&quot;com.kuang.pojo.User&quot; &gt; insert into mybatis.user (id,name,pwd) value (#&#123;id&#125;,#&#123;name &#125;,#&#123;pwd&#125;);&lt;/insert&gt;&lt;update id=&quot;updateUser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt; update mybatis.user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id=#&#123;id&#125;&lt;/update&gt;&lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; delete from mybatis.user where id=#&#123;id&#125;&lt;/delete&gt; 3.测试 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class UserDemoTest &#123; @Test public void test() &#123; //优化代码,官方建议// try&#123;//// &#125; //获取sqlSession对象 SqlSession sqlSession = MybatisUtils.getSqlSession(); //执行1 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; userList = userMapper.getUserList(); //方法二要强转,类型不安全// List&lt;User&gt; userList=sqlSession.selectList(&quot;com.kuang.dao.UserDao.getUserList&quot;); for (User user : userList) &#123; System.out.println(user.getName() + &quot;&quot; + user.getName() + user.getPwd()); &#125; sqlSession.close(); &#125; @Test public void getUserById() &#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); //获得接口 UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.getUserById(1); System.out.println(user); sqlSession.close(); &#125; //增删改要提交事务 @Test public void addUser() &#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); //调用方法 int res = mapper.addUser(new User(4, &quot;dj&quot;, &quot;12233&quot;)); if (res &gt; 0) &#123; System.out.println(&quot;插入成功&quot;); //插入事务 sqlSession.commit(); &#125; sqlSession.close(); &#125; @Test public void updateUser() &#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); //更新 if (mapper.updateUser(new User(4, &quot;呵呵&quot;, &quot;12344&quot;)) &gt; 0) &#123; sqlSession.commit(); &#125; sqlSession.close(); &#125; @Test public void deleteUser() &#123; SqlSession sqlSession=MybatisUtils.getSqlSession(); UserMapper mapper=sqlSession.getMapper(UserMapper.class); mapper.deleteUser(4); sqlSession.commit(); sqlSession.close(); &#125;&#125; 注意：增删改一定要提交事务： 1sqlSession.commit(); 3. update(返回都是int) 123&lt;update id=&quot;updateUser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt; update mybatis.user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id=#&#123;id&#125;&lt;/update&gt; 4. Insert 5. Delete 6. 万能Map 假设，我们的实体类，或者数据库中的表，字段或者参数过多，我们应该考虑使用Map! UserMapper接口 12//用万能Map插入用户public void addUser2(Map&lt;String,Object&gt; map); UserMapper.xml 1234&lt;!--对象中的属性可以直接取出来 传递map的key--&gt;&lt;insert id=&quot;addUser2&quot; parameterType=&quot;map&quot;&gt; insert into user (id,name,password) values (#&#123;userid&#125;,#&#123;username&#125;,#&#123;userpassword&#125;)&lt;/insert&gt; 测试 1234567891011121314@Testpublic void test3()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;userid&quot;,4); map.put(&quot;username&quot;,&quot;王虎&quot;); map.put(&quot;userpassword&quot;,789); //一一对应 mapper.addUser2(map); //提交事务 sqlSession.commit(); //关闭资源 sqlSession.close();&#125; Map传递参数，直接在sql中取出key即可！ 【parameter=“map”】 对象传递参数，直接在sql中取出对象的属性即可！ 【parameter=“Object”】对象 只有一个基本类型参数的情况下，可以直接在sql中取到 多个参数用Map , 或者注解！ 7. 模糊查询 模糊查询这么写？ Java代码执行的时候，传递通配符% 1List&lt;User&gt; userList = mapper.getUserLike(&quot;%李%&quot;); 在sql拼接中使用通配符 123select * from user where name like &quot;%&quot;#&#123;value&#125;&quot;%&quot;--尽量采用 #的方式，#将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号--尽量避免采用$的方式，$会导致SQL注入， LIKE &#x27;%$institutionName$%&#x27; 和 LIKE concat( &#x27;%&#x27;,$institutionName$,&#x27;%&#x27;) 都会导致SQL注入 ； 4、配置解析 1. 核心配置文件 mybatis-config.xml Mybatis的配置文件包含了会深深影响MyBatis行为的设置和属性信息。 有顺序，比如properties要在最上面 12345678910111213configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） 2. 环境配置 environments MyBatis 可以配置成适应多种环境 不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境 1234567891011121314151617&lt;!--环境，可以有多套默认选中了development--&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;amp; serverTimezone=Hongkong&amp;amp; characterEncoding=utf-8&amp;amp; autoReconnect=true&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;!-- 第二套环境--&gt; &lt;environment id=&quot;test&quot;&gt; &lt;transactionManager type=&quot;&quot;&gt;&lt;/transactionManager&gt; &lt;dataSource type=&quot;&quot;&gt;&lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; 学会使用配置多套运行环境！ MyBatis默认的事务管理器就是JDBC ，还有MANAGED 数据源：(dbcp c3p0 druid)连接数据库 默认连接池（连接用完不关）：POOLED UNPOOLED(没有数据池) 3. 属性 properties 我们可以通过properties属性来实现引用配置文件 这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。【db.poperties】 resourse下面编写一个配置文件 db.properties 1234driver=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/mybatis?userSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTCusername=rootpassword=root 在核心配置文件中引入 12345&lt;!--引用外部配置文件--&gt;&lt;properties resource=&quot;db.properties&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;&lt;/properties&gt; 可以直接引入外部文件 可以在其中增加一些属性配置 如果两个文件有同一个字段，优先使用外部配置文件的 4. 类型别名 typeAliases 类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置. 意在降低冗余的全限定类名书写。 1234&lt;!--可以给实体类起别名--&gt;&lt;typeAliases&gt; &lt;typeAlias type=&quot;com.kuang.pojo.User&quot; alias=&quot;User&quot;/&gt;&lt;/typeAliases&gt; 也可以指定一个包，每一个在包 domain.blog 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 domain.blog.Author 的别名为 author,；若有注解，则别名为其注解值。见下面的例子： 123&lt;typeAliases&gt; &lt;package name=&quot;com.kuang.pojo&quot;/&gt;&lt;/typeAliases&gt; 在实体类比较少的时候，使用第一种方式。 如果实体类十分多，建议用第二种扫描包的方式。 第一种可以DIY别名，第二种不行，如果非要改，需要在实体上增加注解。 1234@Alias(&quot;author&quot;)public class Author &#123; ...&#125; 5. 设置 Settings 这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。 mapUnderscoreToCamelCase 是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。 last_name --&gt;lastName true | false False logImpl 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING 未设置 6. 其他配置 typeHandlers（类型处理器） objectFactory（对象工厂） plugins 插件 mybatis-generator-core mybatis-plus 通用mapper 7. 映射器 mappers MapperRegistry：注册绑定我们的Mapper文件； 方式一：资源路径【推荐使用】 12345&lt;!--每一个Mapper.xml都需要在MyBatis核心配置文件中注册--&gt;&lt;mappers&gt; &lt;mapper resource=&quot;com/kuang/dao/UserMapper.xml&quot;/&gt; &lt;mapper resource=&quot;com/kuang/dao/*.xml&quot;&gt; 通配，慎用可能不行&lt;/mappers&gt; 方式二：使用class文件绑定注册 1234&lt;!--每一个Mapper.xml都需要在MyBatis核心配置文件中注册--&gt;&lt;mappers&gt; &lt;mapper class=&quot;com.kuang.dao.UserMapper&quot;/&gt;&lt;/mappers&gt; 方式三：使用包扫描进行注入 123&lt;mappers&gt; &lt;package name=&quot;com.kuang.dao&quot;/&gt;&lt;/mappers&gt; 使用class和package的注意点： 接口和他的Mapper配置文件必须同名 接口和他的Mapper配置文件必须在同一个包下（resourse随便放） 8. 作用域和生命周期 声明周期和作用域是至关重要的，因为错误的使用会导致非常严重的并发问题。 SqlSessionFactoryBuilder: 一旦创建了SqlSessionFactory，就不再需要它了 局部变量 SqlSessionFactory: 说白了就可以想象为：数据库连接池 SqlSessionFactory一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建一个实例。 因此SqlSessionFactory的最佳作用域是应用作用域（ApplocationContext）。 最简单的就是使用单例模式或静态单例模式。 SqlSession： 连接到连接池的一个请求 SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 用完之后需要赶紧关闭，否则资源被占用！ 5、解决属性名和字段名不一致的问题 1. 问题 数据库中的字段 新建一个项目，拷贝之前的，测试实体类字段不一致的情况 测试出现问题 password返回null,因为和数据库内部的东西不一致 123// select * from user where id = #&#123;id&#125;// 类型处理器// select id,name,pwd from user where id = #&#123;id&#125; select和Insert不一样 解决方法： 起别名 .xml配置sql文件 123&lt;select id=&quot;getUserById&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt; select id,name,pwd as password from USER where id = #&#123;id&#125;&lt;/select&gt; 用resultMap 2. resultMap 结果集映射 id name pwd 转为 id name password 使得结果变为 12345678910111213141516171819202122&lt;!--结果集映射--&gt;&lt;!--resultMap id对应resultMap type对应结果集--&gt;&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt; &lt;!--column数据库中的字段，property实体类中的属性--&gt; &lt;result column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/result&gt; &lt;!--可以不用显示的配置--&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;&gt;&lt;/result&gt; &lt;result column=&quot;pwd&quot; property=&quot;password&quot;&gt;&lt;/result&gt;&lt;/resultMap&gt;&lt;select id=&quot;getUserList&quot; resultMap=&quot;UserMap&quot;&gt; select * from USER&lt;/select&gt;&lt;select id=&quot;getTeacher&quot; resultMap=&quot;StudentTeacher&quot;&gt; SELECT s.id sid, s.name sname,t.name tname,t.id tid FROM student s, teacher t WHERE s.tid = t.id AND tid = #&#123;tid&#125;&lt;/select&gt;&lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Teacher&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;tid&quot;/&gt; 有别名其情况的结果集 &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt;&lt;/resultMap&gt; resultMap 元素是 MyBatis 中最重要最强大的元素。 ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。 ResultMap 的优秀之处——你完全可以不用显式地配置它们。 如果这个世界总是这么简单就好了。一对多多对多 6、日志 6.1 日志工厂 如果一个数据库操作，出现了异常，我们需要排错，日志就是最好的助手！ 曾经：sout、debug 现在：日志工厂 SLF4J LOG4J 【掌握】 LOG4J2 JDK_LOGGING COMMONS_LOGGING STDOUT_LOGGING 【掌握】 NO_LOGGING 在MyBatis中具体使用哪一个日志实现，在设置中设定 标准日志工厂 STDOUT_LOGGING 123&lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;&lt;/settings&gt; 6.2 Log4j 什么是Log4j？ Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件； 我们也可以控制每一条日志的输出格式； 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程； 最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 先导入log4j的包 12345&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; log4j.properties 1234567891011121314151617181920212223242526#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码log4j.rootLogger=DEBUG,console,file#控制台输出的相关设置log4j.appender.console = org.apache.log4j.ConsoleAppenderlog4j.appender.console.Target = System.outlog4j.appender.console.Threshold=DEBUGlog4j.appender.console.layout = org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=[%c]-%m%n #格式可以改变#文件输出的相关设置log4j.appender.file = org.apache.log4j.RollingFileAppenderlog4j.appender.file.File=./log/rzp.loglog4j.appender.file.MaxFileSize=10mblog4j.appender.file.Threshold=DEBUGlog4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n #格式log4j.appender.file.layout=org.apache.log4j.PatternLayout#日志输出级别log4j.logger.org.mybatis=DEBUGlog4j.logger.java.sql=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.ResultSet=DEBUGlog4j.logger.java.sq1.PreparedStatement=DEBUG 配置settings为log4j实现 123&lt;settings&gt;&lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;&lt;/settings&gt; 测试运行 6.3Log4j简单使用 在要使用Log4j的类中，导入包 import org.apache.log4j.Logger;（默认导入util的包） 日志对象，参数为当前类的class对象 1static Logger logger = Logger.getLogger(UserDaoTest.class); //载入测试的类对象 日志级别 123logger.info(&quot;info: 测试log4j&quot;);logger.debug(&quot;debug: 测试log4j&quot;);logger.error(&quot;error:测试log4j&quot;); info 普通信息单纯的info《==》sout debug 大多数配置都是debug error try catch里面使用 7、分页 思考：为什么分页？ 减少数据的处理量 7.1 使用Limit分页 1SELECT * from user limit startIndex,pageSize 使用MyBatis实现分页，核心SQL 接口 12//分页List&lt;User&gt; getUserByLimit(Map&lt;String,Integer&gt; map); Mapper.xml 1234&lt;!--分页查询--&gt;&lt;select id=&quot;getUserByLimit&quot; parameterType=&quot;map&quot; resultMap=&quot;UserMap&quot;&gt; select * from user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;&lt;/select&gt; 测试 123456789101112@Testpublic void getUserByLimit()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); HashMap&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(); map.put(&quot;startIndex&quot;,1); map.put(&quot;pageSize&quot;,2); List&lt;User&gt; list = mapper.getUserByLimit(map); for (User user : list) &#123; System.out.println(user); &#125;&#125; 7.2 RowBounds分页 不再使用SQL实现分页，面向对象 接口 12//分页2List&lt;User&gt; getUserByRowBounds(); mapper.xml 1234&lt;!--分页查询2--&gt;&lt;select id=&quot;getUserByRowBounds&quot;&gt; select * from user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;&lt;/select&gt; 测试 1234567891011public void getUserByRowBounds()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); //RowBounds实现 RowBounds rowBounds = new RowBounds(1, 2); //通过Java代码层面实现分页 List&lt;User&gt; userList = sqlSession.selectList(&quot;com.kaung.dao.UserMapper.getUserByRowBounds&quot;, null, rowBounds); for (User user : userList) &#123; System.out.println(user); &#125; sqlSession.close();&#125; 7.3 分页插件、 了解即可https://pagehelper.github.io/ 8、使用注解开发（-05） 8.1 面向接口开发 定义与实现的分离，解耦 三个面向区别 面向对象是指，我们考虑问题时，以对象为单位，考虑它的属性和方法； 面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现； 接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题，更多的体现就是对系统整体的架构； 8.2 使用注解开发 注解在接口上实现 12@Select(&quot;select * from user&quot;)List&lt;User&gt; getUsers(); 需要在核心配置文件中绑定接口 123&lt;mappers&gt; &lt;mapper class=&quot;com.kuang.dao.UserMapper&quot;/&gt;&lt;/mappers&gt; 测试 注：可以在简单的情况下运用但是对属性名字段名不一致的情况力不从心 本质：反射机制实现 底层：动态代理 MyBatis详细执行流程（重要） 8.3 注解CURD增删改查 在工具类设置自动提交 12345//既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例.// SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。public static SqlSession getSqlSession()&#123; return sqlSessionFactory.openSession(true);&#125; Mapper.java 123//方法存在多个参数，所有的参数前面必须加上@Param(&quot;id&quot;)注解@Delete(&quot;delete from user where id = $&#123;uid&#125;&quot;)int deleteUser(@Param(&quot;uid&quot;) int id); 关于@Param( )注解 基本类型的参数或者String类型，需要加上 引用类型不需要加 如果只有一个基本类型的话，可以忽略，但是建议大家都加上 我们在SQL中引用的就是我们这里的@Param()中设定的属性名 #{} 和 ${} #{}防止sql注入 9、Lombok Lombok项目是一个Java库，它会自动插入编辑器和构建工具中，Lombok**提供了一组有用的注释，用来消除Java类中的大量样板代码。**仅五个字符(@Data)就可以替换数百行代码从而产生干净，简洁且易于维护的Java类。 使用步骤： 在IDEA中安装Lombok插件 在项目中导入lombok的jar包 12345&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.10&lt;/version&gt;&lt;/dependency&gt; 在程序上加注解 1234567891011121314151617@Getter and @Setter@FieldNameConstants@ToString@EqualsAndHashCode@AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor@Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger, @CustomLog@Data@Builder@SuperBuilder@Singular@Delegate@Value@Accessors@Wither@With@SneakyThrows@val 说明： 123456789101112@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private int id; @Setter private String name; private String password;&#125;//类上生产类的字段上生产字段的@Setterprivate String i; 10、多对一处理 多个学生一个老师； 1alter table student ADD CONSTRAINT fk_tid foreign key (tid) references teacher(id) 1. 测试环境搭建 导入lombok 新建实体类Teacher,Student 建立Mapper接口 建立Mapper.xml文件 在核心配置文件中绑定注册我们的Mapper接口或者文件 【方式很多，随心选】 测试查询是否能够成功 2. 按照查询嵌套处理 子查询： 问题引入： 直接用select语句 123&lt;!-- &lt;select id=&quot;getStudent&quot; resultType=&quot;Student&quot;&gt;--&gt;&lt;!-- select s.id,s.name,t.name from student s,teacher t where s.tid=t.id--&gt;&lt;!-- &lt;/select&gt;--&gt; 解决teacher=null的问题 12345678910111213141516171819202122&lt;!-- 思路： 1. 查询所有的学生信息 2. 根据查询出来的学生的tid寻找特定的老师 (子查询) --&gt;&lt;select id=&quot;getStudent&quot; resultMap=&quot;StudentTeacher&quot;&gt; select * from student&lt;/select&gt;&lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;!--不能直接写teacher 复杂的属性，我们需要单独出来 对象：association 集合：collection--&gt; &lt;!--property :注入给实体类的某个属性 column:在上次查询结果集中，哪些列作为下一条Sql语句 javaType:把sql语句查询的结果集，封装给某个类对象， select:下一条要执行的sql语句 --&gt; &lt;collection property=&quot;teacher&quot; column=&quot;tid&quot; javaType=&quot;teacher&quot; select=&quot;getTeacher&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getTeacher&quot; resultType=&quot;teacher&quot;&gt; select * from teacher where id = #&#123;id&#125;&lt;/select&gt; 3.按照结果嵌套处理 123456789101112131415&lt;!--按照结果进行查询--&gt;&lt;select id=&quot;getStudent2&quot; resultMap=&quot;StudentTeacher2&quot;&gt; select s.id sid , s.name sname, t.name tname from student s,teacher t where s.tid=t.id&lt;/select&gt;&lt;!--结果封装，将查询出来的列封装到对象属性中--&gt;&lt;resultMap id=&quot;StudentTeacher2&quot; type=&quot;student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt; &lt;association property=&quot;teacher&quot; javaType=&quot;teacher&quot;&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;result property=&quot;id&quot; column=&quot;tid&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt; 回顾Mysql多对一查询方式: 子查询 （按照查询嵌套） 联表查询 （按照结果嵌套） 11、一对多处理(集合) 一个老师多个学生； 对于老师而言，就是一对多的关系； 1. 环境搭建 实体类 12345678910111213@Datapublic class Student &#123; private int id; private String name; private int tid;&#125;@Datapublic class Teacher &#123; private int id; private String name; //一个老师拥有多个学生 private List&lt;Student&gt; students;&#125; 2,按照查询嵌套处理 3… **按照结果嵌套嵌套处理 ** 123456789101112131415161718192021&lt;!--按结果嵌套查询--&gt;&lt;select id=&quot;getTeacher&quot; resultMap=&quot;StudentTeacher&quot;&gt; SELECT s.id sid, s.name sname,t.name tname,t.id tid FROM student s, teacher t WHERE s.tid = t.id AND tid = #&#123;tid&#125; &lt;!--要和接口的@Param(&quot;tid&quot;)对应--&gt;&lt;/select&gt;&lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Teacher&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;tid&quot;/&gt; 有别名 &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;!-- 复杂的属性，我们需要单独处理 对象：association 集合：collection javaType=&quot;&quot;指定属性的类型！ 集合中的泛型信息，我们使用ofType获取，小区别 --&gt; &lt;collection property=&quot;students&quot; ofType=&quot;Student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt; &lt;result property=&quot;tid&quot; column=&quot;tid&quot;/&gt; &lt;/collection&gt;&lt;/resultMap&gt; 小结 关联 - association 【多对一】 集合 - collection 【一对多】 javaType &amp; ofType JavaType用来指定实体类中的类型 把sql语句查询的结果集，封装给某个类对象， 12345&lt;resultMap id=&quot;TeacherStudent&quot; type=&quot;teacher&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;collection property=&quot;students&quot; javaType=&quot;ArrayList&quot; ofType=&quot;student&quot; select=&quot;getStudentByteacherId&quot; column=&quot;id&quot;/&gt;&lt;/resultMap&gt; ofType用来指定映射到List或者集合中的pojo类型，泛型中的约束类型 注意点： 保证SQL的可读性，尽量保证通俗易懂 注意一对多和多对一，属性名和字段的问题 1.两者对应起来 .java接口 .xml文件 2.各个属性详解 ​ property :注入给实体类的某个属性 ​ column:在上次查询结果集中，哪些列作为下一条Sql语句 ​ javaType:把sql语句查询的结果集，封装给某个类对象， ​ select:下一条要执行的sql语句 如果问题不好排查错误，可以使用日志，建议使用Log4j Mysql面试高频 Mysql引擎 InnoDB底层原理 索引 索引优化 12、动态SQL 什么是动态SQL：动态SQL就是根据不同的条件生成不同的SQL语句 所谓的动态SQL，本质上还是SQL语句，只是我们可以在SQL层面，去执行一个逻辑代码 动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不**同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，**还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。 搭建环境 12345678CREATE TABLE `mybatis`.`blog` ( `id` int(10) NOT NULL AUTO_INCREMENT COMMENT &#x27;博客id&#x27;, `title` varchar(30) NOT NULL COMMENT &#x27;博客标题&#x27;, `author` varchar(30) NOT NULL COMMENT &#x27;博客作者&#x27;, `create_time` datetime(0) NOT NULL COMMENT &#x27;创建时间&#x27;, `views` int(30) NOT NULL COMMENT &#x27;浏览量&#x27;, PRIMARY KEY (`id`)) 创建一个基础工程 导包 编写配置文件 编写实体类 1234567891011121314@Datapublic class Blog &#123; private int id; private String title; private String author; private Date createTime;// 属性名和字段名不一致，数据库是下划线 //config.xml &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;开启动态命名 private int views;&#125;//小技巧获取随机ID utils.IDutils类下面public static String getId()&#123; return UUID.randomUUID().toString().replace(&quot;-&quot;,&quot;&quot;);&#125; 编写实体类对应Mapper接口和Mapper.xml文件 1.IF–避免重载 1234567891011&lt;select id=&quot;queryBlogIF&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from blog &lt;where&gt; &lt;if test=&quot;title!=null&quot;&gt; and title = #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author!=null&quot;&gt; and author = #&#123;author&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 相当于and操作select * from mybatis.blog where 1=1 [and title=#{title}][and author=#{author}] 是重载的简化不用根据不同的查询写不同的参数 2.choose (when, otherwise)–Switch-case语句 12345678910&lt;select id=&quot;queryBlogChoose&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from blog &lt;where&gt; &lt;choose&gt; &lt;when test=&quot;title!=null&quot;&gt;and title=#&#123;title&#125;&lt;/when&gt; &lt;when test=&quot;author!=null&quot;&gt;and author=#&#123;author&#125;&lt;/when&gt; &lt;otherwise&gt;and views=#&#123;views&#125;&lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; 3.Trim、where、Set Trim 123456789101112&lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND&quot;&gt; &lt;if test=&quot;state != null&quot;&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;if test=&quot;title != null&quot;&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt;&lt;/trim&gt; where 1234567891011121314151617&lt;where&gt; &lt;if test=&quot;title!=null&quot;&gt; title=#&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author!=null&quot;&gt; and author=#&#123;author&#125; &lt;/if&gt;&lt;/where&gt;等价于 where 1=1&lt;if test=&quot;title!=null&quot;&gt; title=#&#123;title&#125;&lt;/if&gt;&lt;if test=&quot;author!=null&quot;&gt; and author=#&#123;author&#125;&lt;/if&gt; 避免where and test=#{test}的情况出现 ,智能去掉and Set 动态前置**（拼接）set关键字，删除无关的逗号**（记得加逗号），update专用 12345678910update blog&lt;set&gt; &lt;if test=&quot;title!=null&quot;&gt; title=#&#123;title&#125;, &lt;/if&gt; &lt;if test=&quot;author !=null&quot;&gt; author=#&#123;author&#125; &lt;/if&gt;&lt;/set&gt;where id=#&#123;id&#125; 4.SQL片段 有的时候，我们可能会将一些功能的部分抽取出来，方便服用！ 使用SQL标签抽取公共部分可 12345678&lt;sql id=&quot;if-title-author&quot;&gt; &lt;if test=&quot;title!=null&quot;&gt; title = #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author!=null&quot;&gt; and author = #&#123;author&#125; &lt;/if&gt;&lt;/sql&gt; 在需要使用的地方使用Include标签引用即可 123456&lt;select id=&quot;queryBlogIF&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from blog &lt;where&gt; &lt;include refid=&quot;if-title-author&quot;&gt;&lt;/include&gt; &lt;/where&gt;&lt;/select&gt; 注意： ①、最好基于 单表来定义 sql 片段，提高片段的可重用性 ②、在 sql 片段中不要包括 where 5.Foreach select * from blog where 1=1 and (id=1 or id=2 or id=3) 将数据库中前三个数据的id修改为1,2,3； 需求：我们需要查询 blog 表中 id 分别为1,2,3的博客信息 1、编写接口 1List&lt;Blog&gt; queryBlogForeach(Map map); 2、编写SQL语句 12345678910111213141516&lt;select id=&quot;queryBlogForeach&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from blog &lt;where&gt; &lt;!-- collection:指定输入对象中的集合属性 map里的ids属性是集合 item:每次遍历生成的对象 open:开始遍历时的拼接字符串 close:结束时拼接的字符串 separator:遍历对象之间需要拼接的字符串 select * from blog where 1=1 and (id=1 or id=2 or id=3) --&gt; &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;and (&quot; close=&quot;)&quot; separator=&quot;or&quot;&gt; id=#&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 3、测试 123456789101112131415@Testpublic void testQueryBlogForeach()&#123; SqlSession session = MybatisUtils.getSession(); BlogMapper mapper = session.getMapper(BlogMapper.class); HashMap map = new HashMap(); List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;(); ids.add(1); ids.add(2); ids.add(3); map.put(&quot;ids&quot;,ids); List&lt;Blog&gt; blogs = mapper.queryBlogForeach(map); System.out.println(blogs); session.close();&#125; 动态SQL就是在拼接SQL语句，我们只要保证SQL的正确性，按照SQL的格式，去排列组合就可以了 建议： 先在Mysql中写出完整的SQL，再对应的去修改成我们的动态SQL实现通用即可 if是拼接多个语句，Choose动态的break只匹配合适的第一条语句 13、缓存 13.1 简介 查询 ： 连接数据库，耗资源 一次查询的结果，给他暂存一个可以直接取到的地方 --&gt; 内存：缓存 我们再次查询的相同数据的时候，直接走缓存，不走数据库了 什么是缓存[Cache]？ 存在内存中的临时数据 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上（关系型数据库文件）查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题 为什么使用缓存？ 减少和数据库的交互次数，减少系统开销，提高系统效率 什么样的数据可以使用缓存？ 经常查询并且不经常改变的数据 【可以使用缓存】 13.2 MyBatis缓存 MyBatis包含一个非常强大的查询缓存特性，它可以非常方便的定制和配置缓存，缓存可以极大的提高查询效率。 MyBatis系统中默认定义了两级缓存： 一级缓存和二级缓存 默认情况下，只有一级缓存开启（SqlSession级别的缓存，也称为本地缓存） 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。 为了提高可扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来定义二级缓存。 13.3 一级缓存 一级缓存也叫本地缓存：SqlSession 与数据库同一次会话期间查询到的数据会放在本地缓存中 以后如果需要获取相同的数据，直接从缓存中拿，没必要再去查询数据库 测试步骤： 开启日志 测试在一个Session中查询两次记录 123456789101112@Testpublic void test1() &#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.getUserById(1); System.out.println(user); System.out.println(&quot;=====================================&quot;); User user2 = mapper.getUserById(1); System.out.println(user2 == user);&#125; 查看日志输出 缓存失效的情况： 查询不同的东西 增删改操作，可能会改变原来的数据，所以必定会刷新缓存 查询不同的Mapper.xml 手动清理缓存 1sqlSession.clearCache(); 13.4 使用步骤 使用步骤 1、开启全局缓存 【mybatis-config.xml】 1&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; 2、去每个mapper.xml中配置使用二级缓存，这个配置非常简单；【xxxMapper.xml】 1&lt;cache/&gt; 官方示例=====&gt;查看官方文档 12345&lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; size=&quot;512&quot; readOnly=&quot;true&quot;/&gt; 这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。 3、代码测试 所有的实体类先实现序列化接口 123456@Datapublic class User implements Serializable &#123; private int id; private String name; private String pwd;&#125; 测试代码 123456789101112131415161718@Testpublic void testQueryUserById()&#123; SqlSession session = MybatisUtils.getSession(); SqlSession session2 = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); UserMapper mapper2 = session2.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); session.close(); User user2 = mapper2.queryUserById(1); System.out.println(user2); System.out.println(user==user2); session2.close();&#125; 13.5 结论 结论 只要开启了二级缓存，我们在同一个Mapper中的查询，可以在二级缓存中拿到数据 查出的数据都会被默认先放在一级缓存中 只有会话提交或者关闭以后，一级缓存中的数据才会转到二级缓存中 小技巧：在增删的时候不刷新缓存 1&lt;update id=&quot;&quot; flushCache=&quot;false&quot;&gt;&lt;/update&gt; 13.6缓存原理 缓存原理图 13.10 EhCache 第三方缓存实现–EhCache: 查看百度百科 Ehcache是一种广泛使用的java分布式缓存，用于通用缓存； 要在应用程序中使用Ehcache，需要引入依赖的jar包 123456&lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.1.0&lt;/version&gt;&lt;/dependency&gt; 在UserMapper.xml中使用对应的缓存即可 123&lt;mapper namespace = “org.acme.FooMapper” &gt; &lt;cache type = “org.mybatis.caches.ehcache.EhcacheCache” /&gt; &lt;/mapper&gt; 编写ehcache.xml文件，如果在加载时未找到/ehcache.xml资源或出现问题，则将使用默认配置。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot; updateCheck=&quot;false&quot;&gt; &lt;!-- diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下： user.home – 用户主目录 user.dir – 用户当前工作目录 java.io.tmpdir – 默认临时文件路径 --&gt; &lt;diskStore path=&quot;./tmpdir/Tmp_EhCache&quot;/&gt; &lt;defaultCache eternal=&quot;false&quot; maxElementsInMemory=&quot;10000&quot; overflowToDisk=&quot;false&quot; diskPersistent=&quot;false&quot; timeToIdleSeconds=&quot;1800&quot; timeToLiveSeconds=&quot;259200&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt; &lt;cache name=&quot;cloud_user&quot; eternal=&quot;false&quot; maxElementsInMemory=&quot;5000&quot; overflowToDisk=&quot;false&quot; diskPersistent=&quot;false&quot; timeToIdleSeconds=&quot;1800&quot; timeToLiveSeconds=&quot;1800&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt; &lt;!-- defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。 --&gt; &lt;!-- name:缓存名称。 maxElementsInMemory:缓存最大数目 maxElementsOnDisk：硬盘最大缓存个数。 eternal:对象是否永久有效，一但设置了，timeout将不起作用。 overflowToDisk:是否保存到磁盘，当系统当机时 timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。 timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。 diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false. diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。 diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。 memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。 clearOnFlush：内存数量最大时是否清除。 memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。 FIFO，first in first out，这个是大家最熟的，先进先出。 LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。 LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。 --&gt;&lt;/ehcache&gt; 合理的使用缓存，可以让我们程序的性能大大提升！ 14、Mybatis总结 14.1 参考文章 狂神说MyBatis01：第一个程序 狂神说MyBatis02：CRUD操作及配置解析 狂神说MyBatis03：ResultMap及分页 狂神说MyBatis04：使用注解开发 狂神说MyBatis05：一对多和多对一处理 狂神说MyBatis06：动态SQL 狂神说MyBatis07：缓存 14.2 所有代码 代码已经上传至码云 15、Mybatis–24道练习题 24道练习题","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"后端学习","slug":"后端学习","permalink":"http://example.com/tags/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"狂神说ajax","slug":"狂神说ajax","date":"2021-03-30T03:05:47.000Z","updated":"2021-04-23T13:19:47.129Z","comments":true,"path":"2021/03/30/狂神说ajax/","link":"","permalink":"http://example.com/2021/03/30/%E7%8B%82%E7%A5%9E%E8%AF%B4ajax/","excerpt":"","text":"9、Ajax研究(主动权交给了前端) 9.1、简介 AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。 在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。Google Suggest能够自动帮你完成搜索单词。 Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：当您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。就和国内百度的搜索框一样! 传统的网页(即不用ajax技术的网页)，想要更新内容或者提交一个表单，都需要重新加载整个网页。 使用ajax技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。(弹窗等) 使用Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的Web用户界面。 9.2、伪造Ajax 我们可以使用前端的一个标签来伪造一个ajax的样子。iframe标签 新建一个module ：sspringmvc-06-ajax ， 导入web支持！ 编写一个 ajax-frame.html 使用 iframe 测试，感受下效果 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;kuangshen&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; var myDate = new Date(); document.getElementById(&#x27;currentTime&#x27;).innerText = myDate.getTime(); &#125;; function LoadPage()&#123; var targetUrl = document.getElementById(&#x27;url&#x27;).value; console.log(targetUrl); document.getElementById(&quot;iframePosition&quot;).src = targetUrl; &#125;&lt;/script&gt;&lt;div&gt; &lt;p&gt;请输入要加载的地址：&lt;span id=&quot;currentTime&quot;&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt; &lt;input id=&quot;url&quot; type=&quot;text&quot; value=&quot;https://www.baidu.com/&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;提交&quot; onclick=&quot;LoadPage()&quot;&gt; &lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;h3&gt;加载页面位置：&lt;/h3&gt; &lt;iframe id=&quot;iframePosition&quot; style=&quot;width: 100%;height: 500px;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 使用IDEA开浏览器测试一下！ 利用AJAX可以做： 注册时，输入用户名自动检测用户是否已经存在。 登陆时，提示用户名密码错误 删除数据行时，将行ID发送到后台，后台在数据库中删除，数据库删除成功后，在页面DOM中将数据行也删除。 …等等 9.3、jQuery.ajax（前后端交互） 纯JS原生实现Ajax我们不去讲解这里，直接使用jquery提供的，方便学习和使用，避免重复造轮子，有兴趣的同学可以去了解下JS原生XMLHttpRequest ！ Ajax的核心是XMLHttpRequest对象(XHR)。XHR为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。 jQuery 提供多个与 AJAX 有关的方法。 通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON – 同时您能够把这些外部数据直接载入网页的被选元素中。 jQuery 不是生产者，而是大自然搬运工。 jQuery Ajax本质就是 XMLHttpRequest，对他进行了封装，方便调用！ 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;ifram体验AJAX&lt;/title&gt; &lt;script&gt; function go() &#123; var url=document.getElementById(&quot;url&quot;).value; document.getElementById(&quot;iframel&quot;).src=url; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;p&gt;请输入地址：&lt;/p&gt; &lt;p&gt; &lt;input type=&quot;text&quot; id=&quot;url&quot; value=&quot;https://www.csdn.net/?spm=1001.2101.3001.4476&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;提交&quot; onclick=&quot;go()&quot;&gt; &lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;iframe id=&quot;iframel&quot; style=&quot;width:100% ;height:500px&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 先去官网拷贝Jquery代码 url data sucess和error参数 123456789101112131415161718192021jQuery.ajax(...) 公用方法 部分参数： --url：请求地址 type：请求方式，GET、POST（1.9.0之后用method） headers：请求头 --data：要发送的数据 contentType：即将发送信息至服务器的内容编码类型(默认: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;) async：是否异步 timeout：设置请求超时时间（毫秒） beforeSend：发送请求前执行的函数(全局) complete：完成之后执行的回调函数(全局) --success：成功之后执行的回调函数(全局) error：失败之后执行的回调函数(全局) accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型 dataType：将服务器端返回的数据转换成指定类型 &quot;xml&quot;: 将服务器端返回的内容转换成xml格式 &quot;text&quot;: 将服务器端返回的内容转换成普通文本格式 &quot;html&quot;: 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。 &quot;script&quot;: 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式 &quot;json&quot;: 将服务器端返回的内容转换成相应的JavaScript对象 &quot;jsonp&quot;: JSONP 格式使用 JSONP 形式调用函数时，如 &quot;myurl?callback=?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数 我们来个简单的测试，使用最原始的HttpServletResponse处理 , .最简单 , 最通用 配置web.xml 和 springmvc的配置文件【记得静态资源过滤和注解驱动配置上】 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt; &lt;context:component-scan base-package=&quot;com.kuang.controller&quot;/&gt; &lt;!--静态资源过滤，可以找到JQuery--&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!--注解驱动配--&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;!-- 后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 编写一个AjaxController 123456789101112@Controllerpublic class AjaxController &#123; @RequestMapping(&quot;/a1&quot;) public void ajax1(String name , HttpServletResponse response) throws IOException &#123; if (&quot;admin&quot;.equals(name))&#123; response.getWriter().print(&quot;true&quot;); &#125;else&#123; response.getWriter().print(&quot;false&quot;); &#125; &#125;&#125; 导入jquery ， 可以使用在线的CDN ， 也可以下载导入 12&lt;script src=&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt; 编写index.jsp测试 12345678910111213141516171819202122232425262728&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;%--&lt;script src=&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;--%&gt; //$&#123;pageContext.request.contextPath&#125;是web的原始地址0 &lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; function a1()&#123; $.post(&#123; url:&quot;$&#123;pageContext.request.contextPath&#125;/a1&quot;, data:&#123;&#x27;name&#x27;:$(&quot;#txtName&quot;).val()&#125;, success:function (data,status) &#123; alert(data); alert(status); &#125; //error:function()&#123;&#125; &#125;); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;%--onblur：失去焦点触发事件--%&gt;用户名:&lt;input type=&quot;text&quot; id=&quot;txtName&quot; onblur=&quot;a1()&quot;/&gt; &lt;/body&gt;&lt;/html&gt; 启动tomcat测试！打开浏览器的控制台，当我们鼠标离开输入框的时候，可以看到发出了一个ajax的请求！是后台返回给我们的结果！测试成功！ 9.4、Springmvc实现 实体类user（使用了lombok插件，可以自己写实现类方法） 12345678910@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private String name; private int age; private String sex;&#125; 我们来获取一个集合对象，展示到前端页面 12345678@RequestMapping(&quot;/a2&quot;)public List&lt;User&gt; ajax2()&#123; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(new User(&quot;秦疆1号&quot;,3,&quot;男&quot;)); list.add(new User(&quot;秦疆2号&quot;,3,&quot;男&quot;)); list.add(new User(&quot;秦疆3号&quot;,3,&quot;男&quot;)); return list; //由于@RestController注解，将list转成json格式返回&#125; 前端接受用户 Jquery的固定写法记忆 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/static/js/jquery-3.4.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $(&quot;#btn&quot;).click(function () &#123; // console.log(&#x27;点击事件成功&#x27;) // $.post(url,param,[可以省略],success) $.post(&quot;$&#123;pageContext.request.contextPath&#125;/a2&quot;,function (data) &#123; console.log(data[0].name); let html = &quot;&quot;; for (let i = 0; i &lt; data.length; i++) &#123; html += `&lt;tr&gt; &lt;td&gt;$&#123;&quot;$&#123;data[i].name&#125;&quot;&#125;&lt;/td&gt; &lt;td&gt;$&#123;&quot;$&#123;data[i].age&#125;&quot;&#125;&lt;/td&gt; &lt;td&gt;$&#123;&quot;$&#123;data[i].sex&#125;&quot;&#125;&lt;/td&gt; &lt;/tr&gt;` &#125; $(&quot;#content&quot;).html(html) console.log(html) &#125;) &#125;) &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; value=&quot;加载数据&quot; id=&quot;btn&quot;&gt;&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;性别&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody id=&quot;content&quot;&gt; &lt;%--数据：后台--%&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 几种js代码对比 上面的代码也正确 ${}占位符也是为某一个数据结构占据位置。 1234let job=&quot;web前端开发工程师&quot;;let str2=`我是$&#123;job&#125;，工作5年了`;//注意有坑：这里不是单引号，是esc下面的点符号console.log(str2);上面代码很自然的利用占位符将变量插入到字符串中。 成功实现了数据回显！可以体会一下Ajax的好处，注意版本！ 9.5、注册提示效果 我们写一个Controller 1234567891011121314151617181920@RequestMapping(&quot;/a3&quot;)public String ajax3(String name,String pwd)&#123; String msg = &quot;&quot;; //模拟数据库中存在数据 if (name!=null)&#123; if (&quot;admin&quot;.equals(name))&#123; msg = &quot;OK&quot;; &#125;else &#123; msg = &quot;用户名输入错误&quot;; &#125; &#125; if (pwd!=null)&#123; if (&quot;123456&quot;.equals(pwd))&#123; msg = &quot;OK&quot;; &#125;else &#123; msg = &quot;密码输入有误&quot;; &#125; &#125; return msg; //由于@RestController注解，将msg转成json格式返回&#125; 前端页面 login.jsp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;ajax&lt;/title&gt; &lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery.js&quot;&gt;&lt;/script&gt; &lt;script&gt; function a1()&#123; $.post(&#123; url:&quot;$&#123;pageContext.request.contextPath&#125;/a3&quot;, data:&#123;&#x27;name&#x27;:$(&quot;#name&quot;).val()&#125;, success:function (data) &#123; if (data.toString()==&#x27;OK&#x27;)&#123; $(&quot;#userInfo&quot;).css(&quot;color&quot;,&quot;green&quot;); &#125;else &#123; $(&quot;#userInfo&quot;).css(&quot;color&quot;,&quot;red&quot;); &#125; $(&quot;#userInfo&quot;).html(data); &#125; &#125;); &#125; function a2()&#123; $.post(&#123; url:&quot;$&#123;pageContext.request.contextPath&#125;/a3&quot;, data:&#123;&#x27;pwd&#x27;:$(&quot;#pwd&quot;).val()&#125;, success:function (data) &#123; if (data.toString()==&#x27;OK&#x27;)&#123; $(&quot;#pwdInfo&quot;).css(&quot;color&quot;,&quot;green&quot;); &#125;else &#123; $(&quot;#pwdInfo&quot;).css(&quot;color&quot;,&quot;red&quot;); &#125; $(&quot;#pwdInfo&quot;).html(data); &#125; &#125;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt; 用户名:&lt;input type=&quot;text&quot; id=&quot;name&quot; onblur=&quot;a1()&quot;/&gt; &lt;span id=&quot;userInfo&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt; 密码:&lt;input type=&quot;text&quot; id=&quot;pwd&quot; onblur=&quot;a2()&quot;/&gt; &lt;span id=&quot;pwdInfo&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 记得处理json乱码问题 123456789101112131415&lt;!--JSON乱码问题配置--&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;constructor-arg value=&quot;UTF-8&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt; &lt;property name=&quot;objectMapper&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt; &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; 测试一下效果，动态请求响应，局部刷新，就是如此！ 9.6、获取baidu接口Demo JSONP.html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;JSONP百度搜索&lt;/title&gt; &lt;style&gt; #q&#123; width: 500px; height: 30px; border:1px solid #ddd; line-height: 30px; display: block; margin: 0 auto; padding: 0 10px; font-size: 14px; &#125; #ul&#123; width: 520px; list-style: none; margin: 0 auto; padding: 0; border:1px solid #ddd; margin-top: -1px; display: none; &#125; #ul li&#123; line-height: 30px; padding: 0 10px; &#125; #ul li:hover&#123; background-color: #f60; color: #fff; &#125; &lt;/style&gt; &lt;script&gt; // 2.步骤二 // 定义demo函数 (分析接口、数据) function demo(data)&#123; var Ul = document.getElementById(&#x27;ul&#x27;); var html = &#x27;&#x27;; // 如果搜索数据存在 把内容添加进去 if (data.s.length) &#123; // 隐藏掉的ul显示出来 Ul.style.display = &#x27;block&#x27;; // 搜索到的数据循环追加到li里 for(var i = 0;i&lt;data.s.length;i++)&#123; html += &#x27;&lt;li&gt;&#x27;+data.s[i]+&#x27;&lt;/li&gt;&#x27;; &#125; // 循环的li写入ul Ul.innerHTML = html; &#125; &#125; // 1.步骤一 window.onload = function()&#123; // 获取输入框和ul var Q = document.getElementById(&#x27;q&#x27;); var Ul = document.getElementById(&#x27;ul&#x27;); // 事件鼠标抬起时候 Q.onkeyup = function()&#123; // 如果输入框不等于空 if (this.value != &#x27;&#x27;) &#123; // ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆JSONPz重点☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆ // 创建标签 var script = document.createElement(&#x27;script&#x27;); //给定要跨域的地址 赋值给src //这里是要请求的跨域的地址 我写的是百度搜索的跨域地址 script.src = &#x27;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=&#x27;+this.value+&#x27;&amp;cb=demo&#x27;; // 将组合好的带src的script标签追加到body里 document.body.appendChild(script); &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;text&quot; id=&quot;q&quot; /&gt;&lt;ul id=&quot;ul&quot;&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 测试","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端开发","slug":"前端开发","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"狂神说json","slug":"狂神说json","date":"2021-03-30T03:05:37.000Z","updated":"2021-04-23T13:20:03.602Z","comments":true,"path":"2021/03/30/狂神说json/","link":"","permalink":"http://example.com/2021/03/30/%E7%8B%82%E7%A5%9E%E8%AF%B4json/","excerpt":"","text":"8、Json交互处理（From SpringMVC） 8.1、什么是JSON？ JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。 采用完全独立于编程语言的文本格式来存储和表示数据。 简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式： 对象表示为键值对，数据由逗号分隔 花括号保存对象 方括号保存数组 JSON 键值对是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值： 1&#123;&quot;name&quot;:&quot;江志健&quot;,&quot;age&quot;:20,&quot;sex&quot;:&quot;男&quot;&#125; 很多人搞不清楚 JSON 和 JavaScript 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解： JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。 12var obj = &#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125;; //这是一个对象，注意键名也是可以使用引号包裹的var json = &#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;; //这是一个 JSON 字符串，本质是一个字符串 8.2、JSON 和 JavaScript 对象互转 要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法： 12var obj = JSON.parse(&#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;);//结果是 &#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125; 要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法： 12var json = JSON.stringify(&#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125;);//结果是 &#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27; 代码测试 新建一个module ，springmvc-05-json ， 添加web的支持 在web目录下新建一个 json-1.html ， 编写测试内容 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JSON_秦疆&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt; //编写一个js的对象 var user = &#123; name:&quot;秦疆&quot;, age:3, sex:&quot;男&quot; &#125;; //将js对象转换成json字符串 var str = JSON.stringify(user); console.log(str); //将json字符串转换为js对象 var user2 = JSON.parse(str); console.log(user2.age,user2.name,user2.sex);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在IDEA中使用浏览器打开，查看控制台输出！ 8.3、Controller返回JSON数据 Jackson应该是目前比较好的json解析工具了 当然工具不止这一个，比如还有阿里巴巴的 fastjson 等等。 我们这里使用Jackson，使用它需要导入它的jar包； 12345678&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置SpringMVC需要的配置 （web.xml） 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--1.注册servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动顺序，数字越小，启动越早 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--所有请求都会被springmvc拦截 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; springmvc-servlet.xml 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt; &lt;context:component-scan base-package=&quot;com.kuang.controller&quot;/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;!-- 后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 我们随便编写一个User的实体类，然后我们去编写我们的测试Controller； 12345678@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private int id; private String name; private int age;&#125; 这里我们需要两个新东西，一个是@ResponseBody，一个是ObjectMapper对象，我们看下具体的用法 编写一个Controller； 12345678910111213@Controllerpublic class UserController &#123;@RequestMapping(&quot;/j1&quot;) @ResponseBody//他就不会走视图解析器，会直接返回一个字符串 public String json1() throws JsonProcessingException &#123; //jackson.ObjectMapper ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(1, &quot;秦疆一号&quot;, 12); //System.out.println(user); String str = mapper.writeValueAsString(user); return str; &#125; 此时输入中文会产生乱码 12//produces:指定响应体返回类型和编码@RequestMapping(value = &quot;/j1&quot;,produces = &quot;application/json;charset=utf-8&quot;) 配置Tomcat ， 启动测试一下！http://localhost:8080/j1 【注意：使用json记得处理乱码问题】 8.4代码优化 json乱码统一解决 上一种方法比较麻烦，如果项目中有许多请求则每一个都要添加，可以通过Spring配置统一指定，这样就不用每次都去处理了！ 我们可以在springmvc的配置文件上添加一段消息StringHttpMessageConverter转换配置！ 1234567891011121314&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;constructor-arg value=&quot;UTF-8&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt; &lt;property name=&quot;objectMapper&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt; &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; 返回json字符串统一解决 @ResponseBody解决（**每个方法都得加，**不建议使用） 12345678910111213141516@Controllerpublic class UserController &#123; //produces:指定响应体返回类型和编码 @RequestMapping(value = &quot;/json1&quot;) @ResponseBody public String json1() throws JsonProcessingException &#123; //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(1, &quot;秦疆一号&quot;, 12); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便 return str; &#125;&#125; @RestController（直接加到类上即可） 12345678910111213@RestControllerpublic class UserController &#123; @RequestMapping(value = &quot;/j1&quot;) public String json1() throws JsonProcessingException &#123; //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(1, &quot;秦疆一号&quot;, 12); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); return str; &#125;&#125; 8.5、测试集合输出 增加一个新的方法 123456789101112131415161718192021@RequestMapping(&quot;/j2&quot;)public String json2() throws JsonProcessingException &#123; //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user1 = new User(1, &quot;秦疆1号&quot;, 12); User user2 = new User(2, &quot;秦疆2号&quot;, 12); User user3 = new User(3, &quot;秦疆3号&quot;, 12); User user4 = new User(4, &quot;秦疆4号&quot;, 12); User user5 = new User(5, &quot;秦疆5号&quot;, 12); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); list.add(user5); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(list); return str;&#125; 运行结果 : 十分完美，没有任何问题！ 8.6、输出时间对象 增加一个新的方法 1234567891011@RequestMapping(&quot;/j3&quot;)public String json3() throws JsonProcessingException &#123; ObjectMapper mapper = new ObjectMapper(); //创建时间一个对象，java.util.Date Date date = new Date(); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(date); return str;&#125; 运行结果 : 默认日期格式会变成一个数字，是1970年1月1日到当前日期的毫秒数！ Jackson 默认是会把时间转成timestamps形式 解决方案：取消timestamps形式 ， 自定义时间格式 1234567891011121314151617@RequestMapping(&quot;/j3&quot;)public String json4() throws JsonProcessingException &#123; ObjectMapper mapper = new ObjectMapper(); //不使用时间戳的方式 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义日期格式对象 SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); //指定日期格式 mapper.setDateFormat(sdf); Date date = new Date(); String str = mapper.writeValueAsString(date); return str;&#125; 运行结果 : 成功的输出了时间！ 抽取为工具类 如果要经常使用的话，这样是比较麻烦的，我们可以将这些代码封装到一个工具类中；我们去编写下 12345678910111213141516171819202122public class JsonUtils &#123; public static String getJson(Object object) &#123; return getJson(object,&quot;yyyy-MM-dd HH:mm:ss&quot;); //重载，代码复用 &#125; public static String getJson(Object object, String dateFormat) &#123; ObjectMapper mapper = new ObjectMapper(); //java自定义日期格式 SimpleDateFormat sdf = new SimpleDateFormat(dateFormat); //sdf.format(date) // 使用ObjectMapper 来格式化输出 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS,false); mapper.setDateFormat(sdf); try &#123; //ObjectMapper,时间解析后的默认格式为：TImestamp.时间戳 return mapper.writeValueAsString(object); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 我们使用工具类，代码就更加简洁了！ 123456@RequestMapping(&quot;/j3&quot;) public String json3()&#123; Date date = new Date(); return JsonUtils.getJson(date,&quot;yyyy-MM-dd HH:mm:ss&quot;); &#125;&#125; 大功告成！完美！ 8.7、FastJson fastjson.jar是阿里开发的一款专门用于Java开发的包， 实现json对象与JavaBean对象的转换， 实现JavaBean对象与json字符串的转换， 实现json对象与json字符串的转换。 实现json的转换方法很多，最后的实现结果都是一样的。 fastjson 的 pom依赖！ 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.60&lt;/version&gt;&lt;/dependency&gt; fastjson 三个主要的类： JSONObject 代表 json 对象 JSONObject实现了Map接口, 猜想 JSONObject底层操作是由Map实现的。 JSONObject对应json对象，通过各种形式的get()方法可以获取json对象中的数据，也可利用诸如size()，isEmpty()等方法获取&quot;键：值&quot;对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。 JSONArray 代表 json 对象数组 内部是有List接口中的方法来完成操作的。 JSON代表 JSONObject和JSONArray的转化 JSON类源码分析与使用 仔细观察这些方法，主要是实现json对象，json对象数组，javabean对象，json字符串之间的相互转化。 代码测试，我们新建一个FastJsonDemo 类 12345678910111213141516171819202122232425262728293031323334353637@RequestMapping(&quot;/j4&quot;) //@ResponseBody//他就不会走视图解析器，会直接返回一个 字符串 public String json4()&#123; User user1 = new User(1, &quot;秦疆1号&quot;, 12); User user2 = new User(2, &quot;秦疆2号&quot;, 12); User user3 = new User(3, &quot;秦疆3号&quot;, 12); User user4 = new User(4, &quot;秦疆4号&quot;, 12); User user5 = new User(5, &quot;秦疆5号&quot;, 12); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); list.add(user5); System.out.println(&quot;*******Java对象 转 JSON字符串*******&quot;); String str1 = JSON.toJSONString(list); System.out.println(&quot;JSON.toJSONString(list)==&gt;&quot;+str1); String str2 = JSON.toJSONString(user1); System.out.println(&quot;JSON.toJSONString(user1)==&gt;&quot;+str2); System.out.println(&quot;\\n****** JSON字符串 转 Java对象*******&quot;); User jp_user1=JSON.parseObject(str2,User.class); System.out.println(&quot;JSON.parseObject(str2,User.class)==&gt;&quot;+jp_user1); System.out.println(&quot;\\n****** Java对象 转 JSON对象 ******&quot;); JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2); System.out.println(&quot;(JSONObject) JSON.toJSON(user2)==&gt;&quot;+jsonObject1.getString(&quot;name&quot;)); System.out.println(&quot;\\n****** JSON对象 转 Java对象 ******&quot;); User to_java_user = JSON.toJavaObject(jsonObject1, User.class); System.out.println(&quot;JSON.toJavaObject(jsonObject1, User.class)==&gt;&quot;+to_java_user); return JSON.toJSONString(list); &#125; 这种工具类，我们只需要掌握使用就好了，在使用的时候在根据具体的业务去找对应的实现。和以前的commons-io那种工具包一样，拿来用就好了！","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端开发","slug":"前端开发","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"狂神说JS","slug":"狂神说JS","date":"2021-03-30T03:04:35.000Z","updated":"2021-04-23T13:19:02.049Z","comments":true,"path":"2021/03/30/狂神说JS/","link":"","permalink":"http://example.com/2021/03/30/%E7%8B%82%E7%A5%9E%E8%AF%B4JS/","excerpt":"","text":"1、什么是 JavaScript 1.1、概述 JavaScript是一门世界上最流行的脚本语言 一个合格的后端人员,必须要精通 JavaScript ### 1.2、历史 JavaScript的起源故事 https://blog.csdn.net/kese7952/article/details/79357868 ECMsiAScript它可以理解为是Javascript的一个标准 最新版本已经到es6版本- 但是大部分浏览器还只停留在支持es5代码上! 开发环境一线上环境,版本不一致 2、快速入门 2.1、引入JavaSciprt 1、 内部标签 123&lt;script&gt;//...&lt;/script&gt; 2、外部引入 abs.js 1//... test.html 1&lt;script src=&quot;abc.js&quot;&gt;&lt;/script&gt; 测试代码 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--script标签内,写Javascript代码--&gt; &lt;!--&lt;script&gt;--&gt; &lt;!--alert( &#x27;hello,world&#x27;);--&gt; &lt;!--&lt;/script&gt;--&gt; &lt;!--外部引入--&gt; &lt;!--注意：script标签必须成对出现--&gt; &lt;script src=&quot;js/qj.js&quot;&gt;&lt;/script&gt; &lt;!--不用显示定义type，也默认就是 javascript--&gt; &lt;script type=&quot;text/javascript&quot;&gt; &lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;!--这里也可以存放--&gt; &lt;/body&gt; &lt;/html&gt; 2.2、基本语法入门 1234567891011121314151617&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!-- JavaScript严格区分大小写 --&gt;&lt;script&gt; //1.定义变量 变量类型 变量名 var score = 71; // alert(num); // 2.条件控制 if (score&gt;60 &amp;&amp; score&lt;70)&#123; alert(&quot;60~70&quot;) &#125;else if(score&gt;70 &amp;&amp; score&lt;80)&#123; alert(&quot;70~80&quot;) &#125;else&#123; alert(&quot;other&quot;) &#125;&lt;/script&gt; 浏览器调试必备须知 2.3、数据类型 数值，文本，图形，音频，视频。。。 ===符号 浮点数问题 null和undefined 区别 JS数组 对象是大括号，数组是中括号~~ 每个属性之间使用逗号隔开，最后一个不需要添加 123456//Person person = new Person(1,2,3,4,5); var person = &#123; name:&quot;qinjiang&quot;, age: 3, tags: [&#x27;js&#x27;,&#x27;java&#x27;,&#x27;web&#x27;,&#x27;...&#x27;] &#125; 在浏览器调试 1234person.name &gt; &quot;qinjiang&quot; person.age &gt; 3 2.4、严格检查格式 12345678910111213141516&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;！--前提：IEDA需要设置支持ES6语法&#x27;use strict&#x27;；严格险查模式，预防JavaScript的随意性导致产生的一些问题,必须写在Javascript的第一行！局演变量建议都使用 let 去定义~--&gt;&lt;script&gt; &#x27;use strict&#x27; ; //全局变量 let = 1; //ES6 let&lt;/script&gt;&lt;/head&gt; 3、数据类型详解 3.1、字符串 console.log(&quot;\\x41&quot;) ==&gt; a var msg=`fhdjd sadjjdsa`// 3.糖字符串 console.log(msg) ==&gt; ‘你好呀，qinjiang’ 6.变与不变 虽然赋值了但是值不变 12345678console.logƒ log() &#123; [native code] &#125;let student=&#x27;fjlsd&#x27;undefinedstudent[2]=88console.log(student)fjlsd 3.2、数组 Array可以包含任意的数据类型 12345var arr = [1,2,3,4,5,6]; //通过下标取值和赋值arr[0]arr[0] = 1123console.log(arr)//打印所有信息 1、长度（新特性） 12arr.length1 注意：加入给arr.ength赋值，数组大小就会发生变化-，如果赋值过小，元素就会丢失 2、indexOf，通过元素获得下标索引 12arr.indexof(2)1 字符串的“1”和数字 1 是不同的 arr = [0,1,1]; 3、slice()截取Array的一部分 返回一个新数组，类似于String中的substring 4、push()，pop()尾部 12push（&#x27;a&#x27;,&#x27;b&#x27;）：压入到尾部pop：弹出尾部的一个元素 5、unshiift()，shiit()头部 12unshift：压入到头部shift：弹出头部的一个元素 6.排序 反转 concat join连接 常用的方法slice（截取），push（压入），pop（弹出），shift（压入首部），unshift（弹出首部），concat（拼接） 3.3、对象 JavaScript中的所有的键都是字符串，值都是任意对象 1.赋值 动态新建对象 2.in方法 对象.hasOwnProperty()判断是否有元素 3.4、流程控制 if 判断 12345678var age = 3; if(age&gt;3)&#123; //第一个判断 alert(&#x27;haha&quot;); &#125;else if(age&lt;5) &#123; //第二个判断 alert(&quot;kuwa~&quot;); &#125;else &#123; //否则, alert(&quot;kuwa~&quot;); &#125; while循环,避免程序死循环 12345678while(age&lt;100)&#123; age = age + 1; console.log(age) &#125; do&#123; age = age + 1; console.log(age) &#125;while(age&lt;100) for循环 123for (let i = 0;i&lt; 100;i++)&#123; console.Log(i) &#125; forEach 循环 内部是函数 12345var age = [12,3,12,3,12,3,12,31,23,123]; //函数 age. ForEach(function (value) &#123; console.Log(value) &#125;) forEach是ES5.1引入的 for…in 返回索引 1234567//for(var index in object) &#123; &#125;for(var num in age)&#123; if(age.hasownProperty(num))&#123; console.log(&quot;存在&quot;) console.log(age[num]) &#125; &#125; for of 语句 1234var arr=[3,4,5]for(var x of arr)&#123; console.log(x)&#125; 3.5、map和set（字典和集合） ES6的新特性~ map.set(‘adimsm’,132)//设置 map.get(‘tom’) 3.6、iterator ES6的新特性~ 使用iterator来迭代Map和Set 1234var map=new Map([[&quot;jd&quot;,11],[&quot;jack&quot;,12],[&quot;dj&quot;,24]]);for(let x of map)&#123; console.log(x)&#125; 4、函数 4.1、定义函数 方式一和方式二等价 function(x){…}这是一个匿名函数，但是可以把结果赋值给abs，通过abs就可以调用函数！ 判断是否为目标类型 argument关键词，多个关键词 arguments是一个数组代表传递进来的所有参数 问题：arguments包含所有的参数，我们有时候想使用多余的参数来进行附加操作，需要排除已有参数~ rest参数只能卸载最后面，必须用…标识（rest是自定义名称可以是别的） function aaa(a,b,…like){ console.log(like); } 4.2、变量的作用域 假设在JavaScript中，函数查找变量从自身函数开始。由“内”向“外”查找。 假设外部存在这个同名的函数变量。则内部函数会屏蔽外部函数的变量。 这个是在JavaScript建立之初就存在的特性，养成规范，所有的变量定义都放在函数的头部，不要乱放，便于代码维护。 全局变量window JavaScript实际上只有一个全局作用域，任何变量（函数也可以视为变量），假设没有在函数作用范围内找到，就会向外查找，如果在全局作用域都没有找到，报错 RefernceError 规范 我们所有的全局变量都会绑定到我们的windows上。如果不同的js文件。使用了相同的全局变量。冲突 ~ &gt;如果能够减少冲突? 把自己的代码全部放入自己定义的唯一空间名字中 ,上面。啊降低全局命名冲突的问题. （jQuery库） 常量const 在ES6之前，怎么定义常量：只有用最全部大写字母命名的变量就是常量，建议不要修改这样的值。 4.3、方法 5、内部对象 5.1、基本语法 5.2、JSON 在JavaScript一切皆为对象，任何js支持的类型都可以用JSON来表示：number，String… 5.3、Ajax 6、面向对象编程 原型： 以前的继承 现在的继承 2、继承 本质：查看对象原型 原型链 7、操作BOM对象(重点) window全局 8、操作DOM对象（重点） 获得DOM节点 这种都是原生代码，往后尽量用jQuery(); 删除节点 注意，删除多个节点的时刻，children是在时刻变化的，删除节点的时候一定要注意。 插入节点 获得了某个DOM节点，假设这个DOM节点是空的，通过innerHTML就可以增加一个元素了，但是这个DOM节点已经存在元素了，就会产生覆盖。 效果： 创建一个新的标签，实现插入 9、操作表单（验证） 获取要提交的信息 提交表单，md5密码加密，表单优化（高级玩法 - hidden） 123456789101112131415161718192021222324252627282930&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- MD5工具类 --&gt; &lt;script src=&quot;https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 表单绑定提交事件οnsubmit= 绑定一个提交检测的函数，true，false将这个结果返回给表单，使用onsubmit接受 --&gt; &lt;form action=&quot;&quot; method=&quot;POST&quot; onsubmit=&quot;return aaa()&quot;&gt; 用户：&lt;input type=&quot;text&quot; id=&quot;uname&quot; name=&quot;username&quot; placeholder=&quot;用户名&quot;/&gt;&lt;br/&gt; 密码：&lt;input type=&quot;password&quot; id=&quot;pname&quot; name=&quot;userpassword&quot; placeholder=&quot;密码&quot;/&gt;&lt;br/&gt; &lt;input type=&quot;hidden&quot; id=&quot;md5pwd&quot; name=&quot;epassword&quot;/&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;/form&gt;&lt;/body&gt;&lt;script&gt; function aaa()&#123; var u = document.getElementById(&#x27;uname&#x27;); var p = document.getElementById(&#x27;pname&#x27;); var md5pwd = document.getElementById(&#x27;md5pwd&#x27;); md5pwd.value = md5(p.value); //可以校验判断表单内容，true就是通过提交，false是阻止提交 return true; &#125;&lt;/script&gt;12345678910111213141516171819202122232425262728不用按钮提交，一般都用表单级别的提交 ← ← ← 刮刮乐 10、jQuery 获取jQuery - 公式：$(selector).action() 公式：$(选择器).事件(事件函数) 1234567891011121314151617181920&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- jQuery的cdn加速地址 --&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;&quot; id=&quot;test-jquery&quot;&gt;点我&lt;/a&gt; &lt;script&gt; //选择器就是css的选择器 $(&#x27;#test-jquery&#x27;).click( function()&#123; alert(&#x27;holle，world&#x27;); &#125; ) &lt;/script&gt;&lt;/body&gt;12345678910111213141516171819 选择器 文档工具站：https://jquery.cuishifeng.cn/ 事件 鼠标事件，键盘事件，其他事件 比如获取鼠标坐标： 12345678910111213141516171819202122232425262728&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #divMove&#123; width: 500px; height: 500px; border: 1px solid red; &#125; &lt;/style&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 要求：获取鼠标当前的一个坐标 --&gt; mouse: &lt;span id=&quot;mouseMove&quot;&gt;&lt;/span&gt; &lt;div id=&quot;divMove&quot;&gt; 在这里移动试试： &lt;/div&gt; &lt;script&gt; // 在网页加载完毕之后，响应事件 $(function()&#123; $(&#x27;#divMove&#x27;).mousemove(function(e)&#123; $(&#x27;#mouseMove&#x27;).text(&#x27;x:&#x27;+e.pageX+&#x27;y:&#x27;+e.pageY) &#125;) &#125;); &lt;/script&gt;&lt;/body&gt;123456789101112131415161718192021222324252627 操作DOM &gt; 小技巧 1、巩固JS 看jQuery源码 看游戏源码 2、巩固HTML CSS —&gt; 扒网站，全部下载下来，修改对应位置的样式，看效果 11.解析Promise和async 11.1箭头函数 es6中出现的函数形式 开发时根据实际情况可以省略一些东西 单条处理可以省略return和{大括号} 单个参数可以省略(小括号) 12345let fun = function(params)&#123;&#125;//可以缩写成如下 箭头函数会改变this的指向let fun= params =&gt;&#123;&#125;//当参数有两个及以上时,如下：let fun= (params1,params2,,,)=&gt;&#123;&#125; 11.2语法糖举例 计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。 通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。 箭头函数，引用 123456789101112131415161718// 新建一个util.js 文件夹let formatTime = date=&gt;&#123; ....&#125;let endTime = date=&gt;&#123; ....&#125;module.exports = &#123; formatTime, endTime,&#125;//可以用import &#123;名称&#125; from &#x27;模块&#x27; //然后再同级目录创建一个js文件 引入 util.js//import &#123;endTime&#125; from &#x27;util&#x27;//或者全部引入//import util from &#x27;util&#x27; 11.3Promise和fetch()解析 12345678910//fetch是全局量window的一个方法，第一个参数为URL。//使用fetch方法请求数据更加的简单，语法简洁，数据处理过程更加的清晰，基于Promise实现。fetch(&#x27;/some/url&#x27;, &#123; method: &#x27;get&#x27;, &#125;) // 第一个then 设置请求的格式 .then(e =&gt; e.json()) // 第二个then 处理回调 .then((data) =&gt; &#123; &lt;!-- data为真正数据 --&gt; &#125;).catch(e =&gt; console.log(&quot;Oops, error&quot;, e)) 123456789101112//普通调用$.get(&#x27;/&#x27;,function(data)&#123;console.log(data.length)&#125;)//fetchfetch(&#x27;/&#x27;).then(res=&gt;res.text()).then(data=&gt;console.log(data.length))//promise --new Promise时里面的内容会立即执行，为了能实现调用时执行，一般Promise都作为函数的返回值//resolve接受正确结果，导入then ,reject接受cuow导入catchnew Promise((res,rej)=&gt;&#123; setTimeout(function()&#123;res(123)&#125;,1000)&#125;).then(res=&gt;console.log(res)).catch(e=&gt;console.log(e))new Promise((res,rej)=&gt;&#123; setTimeout(function()&#123;rej(123)&#125;,1000)&#125;).then(res=&gt;console.log(res)).catch(e=&gt;console.log(e)) 1 then的传递性：promise().then(x=&gt;y).then(z=&gt;z) 这里第二个then的输入参数z就是上一个then返回值传递过来的y。 2 then传递时的变化： 如果上面y是个promise，则z是promise执行完只有的结果(resolve中的结果)！！！！ 上面解释了fetch().then(res=&gt;res.text()).then(data=&gt;console.log(data))。这里面res.text()得到的是个promise，所以传到下一个then中的data会被’偷偷’解析成运行完的结果。 11.4Promise和async 1234567891011var p1= () =&gt; new Promise((res,rej)=&gt;setTimeout(()=&gt; res(12345),1000)) //定义箭头函数p1，不传参返回Promise对象，//async 和 await联合使用，await会拿到resolve结果是then函数的语法糖async function q1()&#123; var res=await p1(); //可以同步编程避免回调地狱 console.log(res)&#125;//等价的promise then形式function q2()&#123; p1().then(res=&gt;console.log(res))&#125; 同时打印await是promise和asyn的简写 11.5await解决回调 12345678910async function main()&#123; try&#123;//统一的try catch //async 和 await联合使用，await会拿到resolve结果是then函数的语法糖 var data1=await query(sql1) var data2=await query(sql2) var data3=await query(sql3) &#125;catch(e)&#123; console.log(e) &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端开发","slug":"前端开发","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"狂神说CSS","slug":"狂神说CSS","date":"2021-03-30T03:03:45.000Z","updated":"2021-04-23T13:13:27.734Z","comments":true,"path":"2021/03/30/狂神说CSS/","link":"","permalink":"http://example.com/2021/03/30/%E7%8B%82%E7%A5%9E%E8%AF%B4CSS/","excerpt":"","text":"CSS3学习 1.什么是CSS 1.1、什么是CSS Cascading Style Sheet 层叠样式表 CSS：表现（美化网页） 字体，颜色，边距，高度，宽度，背景图片，网页定位，网页浮动 1.2、发展史 CSS1.0 CSS2.0：DIV（块）+CSS，HTML与CSS结构分离的思想，网页变得简单，SEO CSS2.1：浮动，定位 CSS3.0：圆角、阴影、动画…浏览器兼容性~ 2、快速入门 2.1.1、练习格式： 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--规范，&lt;style&gt;可以编写CSS的代码，每一个声明最好以“;”结尾 语法： 选择器&#123; 声明1; 声明2; 声明3; &#125; --&gt; &lt;style&gt; h1&#123; color: crimson; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;CSS测试&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 建议使用这种规范（单独写一个css文件，用link标签引入css文件效果）： 2.1.2、CSS的优势： 1、内容和表现分离； 2、网页结构表现统一，可以实现复用 3、样式十分的丰富 4、建议使用独立于html的css文件 5、利用SEO，容易被搜索引擎收录！ 2.1.3、CSS的3种常用导入方式 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt;&lt;!--内部样式--&gt; h1&#123; color: green; &#125; &lt;/style&gt; &lt;!--外部样式--&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot; /&gt;&lt;/head&gt;&lt;body&gt;&lt;!--优先级：就近原则 行内样式 &gt; 内部样式 &gt; 外部样式--&gt;&lt;!--行内样式：在标签元素中，编写一个style属性，编写样式即可--&gt;&lt;h1 style=&quot;color: red&quot;&gt;这是标签&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 拓展：外部样式两种方法 链接式 html 根路径下开始 12&lt;!--外部样式--&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot; /&gt; 导入式 @import是CSS2.1特有的！ 1234&lt;!--导入式--&gt;&lt;style&gt; @import url(&quot;css/style.css&quot;);&lt;/style&gt; 2.2选择器 作用：选择页面上的某一个后者某一类元素 2.2.1、基本选择器 1、标签选择器 选择一类标签 格式： 标签 { } 123456789101112131415161718192021222324&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; h1&#123; color: orange; background: blue; border-radius: 10px; &#125; h3&#123; color: orange; background: blue; border-radius: 10px; &#125; p&#123; font-size: 80px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;标签选择器&lt;/h1&gt;&lt;p&gt;我爱学习&lt;/p&gt;&lt;h3&gt;学习JAVA&lt;/h3&gt;&lt;/body&gt; 2、类选择器class 选择所有class一致的标签，跨标签 格式： .类名{} 1234567891011121314151617181920212223&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; /*类选择器的格式 .class的名称&#123;&#125; 好处：可以多个标签归类，是同一个class，可以复用*/ .demo1&#123; color: blue; &#125; .demo2&#123; color: red; &#125; .demo3&#123; color: aqua; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 class = &quot;demo1&quot;&gt;类选择器：demo1&lt;/h1&gt;&lt;h1 class=&quot;demo2&quot;&gt;类选择器：demo2&lt;/h1&gt;&lt;h1 class=&quot;demo3&quot;&gt;类选择器：demo3&lt;/h1&gt;&lt;p class=&quot;demo3&quot;&gt;p标签&lt;/p&gt;&lt;/body&gt; 3、id 选择器 全局唯一 格式： #id名{} 123456789101112131415161718192021222324252627282930&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; /*id选择器：id必须保证全局唯一 #id名称&#123;&#125; 不遵循就近原则，优先级是固定的 id选择器 &gt; class类选择器 &gt; 标签选择器 */ #demo1&#123; color: red; &#125; .demo2&#123; color: green; &#125; #demo2&#123; color: orange; &#125; h1&#123; color: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 id=&quot;demo1&quot; class=&quot;demo2&quot;&gt;id选择器：demo1&lt;/h1&gt; &lt;h1 class=&quot;demo2&quot; id = &quot;demo2&quot;&gt;id选择器：demo2&lt;/h1&gt; &lt;h1 class=&quot;demo2&quot;&gt;id选择器：demo3&lt;/h1&gt; &lt;h1 &gt;id选择器：demo4&lt;/h1&gt; &lt;h1&gt;id选择器：demo5&lt;/h1&gt;&lt;/body&gt; 优先级：id &gt; class &gt; 标签 2.2.2、高级选择器 1. 层次选择器 后代选择器：在某个元素的后面 123456/*后代选择器*/&lt;style&gt;body p&#123; background:red;&#125;&lt;/style&gt; 子选择器，一代 123456/*子选择器*/&lt;style&gt;body&gt;p&#123; background:orange;&#125;&lt;/style&gt; 相邻的兄弟选择器 同辈 12345678910/*相邻兄弟选择器：只选择一个，相邻（向下）*/&lt;style&gt;.active+p&#123;background: red&#125;&lt;/style&gt;&lt;body&gt; &lt;p class=&quot;active&quot;&gt;p1&lt;p&gt; &lt;p&gt;p2&lt;/p&gt;&lt;/body&gt; 通用选择器 12345678910&lt;style&gt;/*通用兄弟选择器，当前选中元素的向下的所有兄弟元素*/ .active~p&#123; background:red;&#125;&lt;/style&gt;&lt;body&gt; &lt;p class=&quot;active&quot;&gt;p1&lt;p&gt; &lt;p&gt;p2&lt;/p&gt;&lt;/body&gt; 2.结构伪类选择器 伪类 1234567891011121314151617181920212223242526272829303132333435363738 &lt;style&gt; ul li:first-child&#123;/*ul的第一个子元素*/ background: aqua; &#125; ul li:last-child&#123;/*ul的最后一个子元素*/ background: blue; &#125; /*选中p1：定位到父元素，选择当前的第一个元素 选择当前p元素 的父级元素，选中父级元素的第一个，并且是当前元素才生效！*/ p:nth-child(1)&#123; background: orange; &#125; p:nth-of-type(2)&#123;/*选中父元素下的，第2个p元素*/ background: red; &#125; a:hover&#123; color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;&quot;&gt;123&lt;/a&gt; &lt;p&gt;p1&lt;/p&gt; &lt;p&gt;p2&lt;/p&gt; &lt;p&gt;p3&lt;/p&gt; &lt;h3&gt;h3&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;1li1&lt;/li&gt; &lt;li&gt;1li2&lt;/li&gt; &lt;li&gt;1li3&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li&gt;2li1&lt;/li&gt; &lt;li&gt;2li2&lt;/li&gt; &lt;li&gt;2li3&lt;/li&gt; &lt;/ul&gt; &lt;a href=&quot;www.baidu.com&quot;&gt;百度&lt;/a&gt;&lt;/body&gt; 3.属性选择器（常用） id + class结合 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .demo a&#123; float: left; display: block; height: 50px; width: 50px; border-radius: 10px; background: aquamarine; text-align: center; color: gray; text-decoration: none; margin-right: 5px; /*line-height:50px;*/ font: bold 20px/50px Arial; &#125; /*属性名，属性名=属性值（正则） = 表示绝对等于 *= 表示包含 ^= 表示以...开头 $= 表示以...结尾 存在id属性的元素 a[]&#123;&#125; */ a[id]&#123; background: yellow; &#125; a[id=first]&#123;/*id=first的元素*/ background: green; &#125; a[class*=&quot;links&quot;]&#123;/*class 中有links的元素*/ background: bisque; &#125; a[href^=http]&#123;/*选中href中以http开头的元素*/ background: aquamarine; &#125; a[href$=pdf]&#123;/*选中href中以http开头的元素*/ background: aquamarine; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=&quot;demo&quot;&gt; &lt;a href=&quot;http:www.baidu.com&quot; class=&quot;links item first&quot; id=&quot;first&quot;&gt;1&lt;/a&gt; &lt;a href=&quot;&quot; class=&quot;links item active&quot; target=&quot;_blank &quot; title=&quot;test&quot;&gt;2&lt;/a&gt; &lt;a href=&quot;images/123.html&quot; class=&quot;links item&quot;&gt;3&lt;/a&gt; &lt;a href=&quot;images/1.png&quot; class=&quot;links item&quot;&gt;4&lt;/a&gt; &lt;a href=&quot;images/1.jpg&quot; class=&quot;links item&quot;&gt;5&lt;/a&gt; &lt;a href=&quot;abc&quot; class=&quot;links item&quot;&gt;6&lt;/a&gt; &lt;a href=&quot;/a.pdf&quot; class=&quot;links item&quot;&gt;7&lt;/a&gt; &lt;a href=&quot;/abc.pdf&quot; class=&quot;links item&quot;&gt;8&lt;/a&gt; &lt;a href=&quot;abc.doc&quot; class=&quot;links item&quot;&gt;9&lt;/a&gt; &lt;a href=&quot;abcd.doc&quot; class=&quot;links item last&quot;&gt;10&lt;/a&gt; &lt;/p&gt;&lt;/body&gt; 效果： 3、美化网页元素 3.1、为什么要美化网页 有效的传递页面信息 美化网页，页面漂亮才能吸引客户 凸显页面的主题 提高用户的体验 span标签：重点要突出的字，使用span标签套起来 123456789101112&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; #title1&#123; font-size: 50px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;学习语言&lt;span id=&quot;title1&quot;&gt;JAVA&lt;/span&gt;&lt;/body&gt; 3.2、字体样式 font-family：字体 font-size：字体大小 font-weight：字体粗细 color：字体颜色 1234567891011121314151617181920212223&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; body&#123; font-family:&quot;Arial Black&quot;,楷体; color: red; &#125; h1&#123; font-size: 50px; &#125; .p1&#123; font-weight: 600; color: gray; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;标题&lt;/h1&gt; &lt;p&gt;正文11111&lt;/p&gt; &lt;p class=&quot;p1&quot;&gt;正文2222222&lt;/p&gt; &lt;p&gt;i love study java&lt;/p&gt;&lt;/body&gt; 常用写法： 123font-weight:bolder;/*也可以填px，但不能超过900,相当于bloder*//*常用写法：*/font:oblique bloder 12px &quot;楷体&quot; 3.3、文本样式 颜色–&gt;color:agb / rgba() 文本对齐方式–&gt;text-align：center 首行缩进–&gt;text-indent：2em 行高–&gt;line-height：300px； 下划线–&gt;text-decoration 1234text-decoration:underline/*下划线*/text-decoration:line-through/*中划线*/text-decoration:overline/*上划线*/text-decoration:none/*超链接去下划线*/ 图片、文字水平对齐 1img,span&#123;vetical-align:middle&#125; 3.4、文本，阴影和超链接伪类 123456789101112131415161718&lt;style&gt; a&#123;/*超链接有默认的颜色*/ text-decoration:none; color:#000000; &#125; a:hover&#123;/*鼠标悬浮的状态*/ color:orange; &#125; a:active&#123;/*鼠标按住未释放的状态*/ color:green &#125; a:visited&#123;/*点击之后的状态*/ color:red &#125; a:link&#123; background: bisque; &#125;&lt;/style&gt; 阴影： 123456/* 第一个参数：表示水平偏移 第二个参数：表示垂直偏移 第三个参数：表示模糊半径 第四个参数：表示颜色*/text-shadow:5px 5px 5px 颜色 3.6、列表ul li 主页index.html代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link href=&quot;css/style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;nav&quot;&gt; &lt;h2 class=&quot;title&quot;&gt;全部商品分类&lt;/h2&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;图书&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;音像&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;数字商品&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;家用电器&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;手机&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;数码&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;电脑&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;办公&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;家居&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;家装&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;厨具&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;服饰鞋帽&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;个性化妆&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;礼品箱包&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;钟表&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;珠宝&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;食品饮料&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;保健食品&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;彩票&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;旅行&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;充值&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;票务&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; css代码： 1234567891011121314151617181920212223242526272829303132333435#nav&#123; width: 300px; background: antiquewhite;&#125;.title&#123; font-size: 18px; font-weight: bold; text-indent: 1em;/*缩进*/ line-height: 35px; background: red;&#125;/*ul li*//*list-style: non 去掉实心圆 circle 空心圆 square 正方形*//*ul&#123;!*nav替换效果*! background: antiquewhite;&#125;*/ul li&#123; height: 30px; list-style: none; text-indent: 1em;&#125;a&#123; text-decoration: none; font-size: 14px; color: black; &#125;a:hover&#123; color: burlywood; text-decoration: underline;&#125; 3.7、背景 背景颜色：background 背景图片 12345background-image:url(&quot;&quot;);/*默认是全部平铺的*/background-repeat:repeat-x/*水平平铺*/background-repeat:repeat-y/*垂直平铺*/background-repeat:no-repeat/*不平铺*/1234 3.8、渐变 渐变背景网址：https://www.grabient.com 径向渐变、圆形渐变 1234body&#123; background-color: #4158D0; background-image: linear-gradient(43deg, #4158D0 0%, #C850C0 46%, #FFCC70 100%); &#125; 4、盒子模型 4.1什么是盒子模型 margin：外边距 padding：内边距 border：边框 4.2、边框 border：粗细 样式 颜色 边框的粗细 边框的样式 边框的颜色 4.3、外边距----妙用：居中 margin-left/right/top/bottom–&gt;表示四边，可分别设置，也可以同时设置如下 1234567margin:0 0 0 0/*分别表示上、右、下、左；从上开始顺时针*//*例1：居中*/margin:0 auto /*auto表示左右自动*//*例2：*/margin:4px/*表示上、右、下、左都为4px*//*例3*/margin:10px 20px 30px/*表示上为10px，左右为20px，下为30px*/ 盒子的计算方式： margin+border+padding+内容的大小 总结： body总有一个默认的外边距 margin:0 常见操作：初始化 4.4、圆角边框----border-radius 123456789&lt;style&gt; div&#123; width: 100px; height: 100px; border: 10px solid red; /*一个border-radius只管一个圆的1/4*/ border-radius: 50px 20px 20px 30px;/*左上 右上 右下 左下 ,顺时针方向*/ &#125;&lt;/style&gt; 4.5、盒子阴影 1box-shadow: 10px 10px 1px black; 5、浮动 5.1标准文档流 块级元素：独占一行 h1~h6 、p、div、 列表… 行内元素：不独占一行 span、a、img、strong 注： 行内元素可以包含在块级元素中，反之则不可以 5.2、display（重要） block：块元素 inline：行内元素 inline-block：是块元素，但是可以内联，在一行 这也是一种实现行内元素排列的方式，但是我们很多情况用float none：消失 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--block 块元素 inline 行内元素 inline-block 是块元素，但是可以内联 ，在一行 --&gt; &lt;style&gt; div&#123; width: 100px; height: 100px; border: 1px solid red; display: inline-block; &#125; span&#123; width: 100px; height: 100px; border: 1px solid red; display: inline-block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;div块元素&lt;/div&gt;&lt;span&gt;span行内元素&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 5.3、float：left/right左右浮动 clear：both 5.4、overflow及父级边框塌陷问题 clear： right：右侧不允许有浮动元素 left：左侧不允许有浮动元素 both：两侧不允许有浮动元素 none： 解决塌陷问题方案： 方案一：增加父级元素的高度； 方案二：增加一个空的div标签，清除浮动 12345678&lt;div class = &quot;clear&quot;&gt;&lt;/div&gt;&lt;style&gt; .clear&#123; clear:both; margin:0; padding:0;&#125;&lt;/style&gt; 方案三：在父级元素中增加一个overflow属性 12overflow:hidden/*隐藏超出部分*/overflow：scoll/*滚动*/ 方案四：父类添加一个伪类:after 12345#father:after&#123; content:&#x27;&#x27;; display:block; clear:both;&#125; 小结： 浮动元素增加空div----&gt; 简单、代码尽量避免空div 设置父元素的高度-----&gt; 简单，但是元素假设有了固定的高度，可能就会超出范围 overflow----&gt; 简单，下拉的一些场景避免使用 父类添加一个伪类:after（推荐）----&gt; 写法稍微复杂，但是没有副作用，推荐使用 display与float对比 display：方向不可以控制 float：浮动起来的话会脱离标准文档流，所以要解决父级边框塌陷的问题。 6、定位 6.1、相对定位 相对定位：positon：relstive； 相对于原来的位置，进行指定的偏移，相对定位的话，它仍然在标准文档流中！原来的位置会被保留 1234top:-20px;/*向上偏移20px*/left:20px;/*向右偏移20px*/bottom:10px;/*向上偏移10px*/right:20px;/*向左偏移20px*/ 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;相对定位&lt;/title&gt; &lt;!--相对定位 相对于自己原来的位置进行偏移 --&gt; &lt;style&gt; body&#123; padding: 20px; &#125; div&#123; margin: 10px; padding: 5px; font-size: 12px; line-height: 25px; &#125; #father&#123; border: #ffa538 1px solid; padding: 0; &#125; #first&#123; border: #b3ff38 1px solid; background-color: #ffa538; position: relative;/*相对定位：上下左右*/ top: -20px;/*向上偏移20px*/ left: 20px;/*向右偏移20px*/ &#125; #second&#123; border: #427b11 1px solid; background-color: #66c77f; &#125; #third&#123; background-color: #b3ff38; border: #38d7ff 1px solid; position: relative; bottom: 10px;/*向上偏移10px*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;father&quot;&gt; &lt;div id=&quot;first&quot;&gt;第一个盒子&lt;/div&gt; &lt;div id=&quot;second&quot;&gt;第二个盒子&lt;/div&gt; &lt;div id=&quot;third&quot;&gt;第三个盒子&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 练习： 实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;style&gt; #box&#123; height: 300px; width: 300px; border: 2px red solid; padding: 10px; &#125; a&#123; height: 100px; width: 100px; background-color: #ee73b7; color: white; text-align: center; text-decoration: none; line-height: 100px;/*设置行距100px*/ display: block;/*设置方块*/ &#125; a:hover&#123; background: #4158D0; &#125; .a2&#123; position: relative; left: 200px; top: -100px; &#125; .a4&#123; position: relative; left: 200px; top: -100px; &#125; .a5&#123; position: relative; left: 100px; top: -300px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;box&quot;&gt; &lt;div class=&quot;a1&quot;&gt;&lt;a href=&quot;&quot; &gt;连接1&lt;/a&gt;&lt;/div&gt; &lt;div class=&quot;a2&quot;&gt;&lt;a href=&quot;&quot; &gt;连接2&lt;/a&gt;&lt;/div&gt; &lt;div class=&quot;a3&quot;&gt;&lt;a href=&quot;&quot; &gt;连接3&lt;/a&gt;&lt;/div&gt; &lt;div class=&quot;a4&quot;&gt;&lt;a href=&quot;&quot; &gt;连接4&lt;/a&gt;&lt;/div&gt; &lt;div class=&quot;a5&quot;&gt;&lt;a href=&quot;&quot; &gt;连接5&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt; 6.2、绝对定位-absolute 和固定定位-fixed 定位：基于xxx定位，上下左右~ 1、没有父级元素定位的前提下，相对于浏览器定位 2、假设父级元素存在定位，我们通常会相对于父级元素进行偏移 3、在父级元素范围内移动 总结：相对一父级或浏览器的位置，进行指定的偏移，绝对定位的话，它不在标准文档流中，原来的位置不会被保留 1234567891011121314151617181920212223242526272829&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; body&#123; height: 1000px; &#125; div:nth-of-type(1)&#123; width: 100px; height: 100px; background-color: red; position: absolute;/*absolute 绝对定位*/ right: 0; bottom: 0; &#125; div:nth-of-type(2)&#123; width: 50px; height: 50px; background-color: #b3ff38; position: fixed;/*fixed 固定定位*/ right: 0; bottom: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;div1&lt;/div&gt;&lt;div&gt;div2&lt;/div&gt;&lt;/body&gt; 6.3、z-index 图层-z-index：默认是0，最高无限~999 index.html代码： 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot; type=&quot;text/css&quot;&gt; &lt;style&gt;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;content&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=&quot;images/2020.jpg&quot; alt=&quot;&quot;/&gt;&lt;/li&gt; &lt;li class=&quot;tipText&quot;&gt;学习微服务，找狂神&lt;/li&gt; &lt;li class=&quot;tipBg&quot;&gt;&lt;/li&gt; &lt;li&gt;时间：2099-01-01&lt;/li&gt; &lt;li&gt;地点：月球一号基地&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; css代码： 123456789101112131415161718192021222324252627282930313233#content&#123; width: 380px; padding: 0px; margin: 0px; overflow: hidden; font-size: 12px; line-height: 25px; border: 1px solid yellow;&#125;ul,li&#123; padding: 0px; margin: 0px; list-style: none;&#125;/*父级元素相对定位*/#content ul&#123; position: relative;&#125;.tipText,.tipBg&#123; position: absolute; width: 380px; height: 25px; top:216px&#125;.tipText&#123; color: white; z-index: 999;&#125;.tipBg&#123; background: orange; opacity: 0.5;/*背景透明度*/ filter: alpha(opacity=50);&#125; 7、动画及视野拓展 css做动画过于繁琐，已有很多工具间接性做出 百度搜索canvas动画、卡巴斯基监控站（仅作了解） 8、总结","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端开发","slug":"前端开发","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"狂神说html","slug":"狂神说html","date":"2021-03-30T03:03:23.000Z","updated":"2021-04-23T13:14:11.335Z","comments":true,"path":"2021/03/30/狂神说html/","link":"","permalink":"http://example.com/2021/03/30/%E7%8B%82%E7%A5%9E%E8%AF%B4html/","excerpt":"","text":"HTML笔记 1、初识HTML HyperTextMarkupLanguage（超文本标记语言） &lt; body &gt;、&lt; /body&gt;等成对的标签，分别叫做开放标签和闭合标签， 单独呈现的标签（空元素），如&lt; hr/ &gt;;意为用/来关闭空元素。 html注释：&lt; !–注释内容–&gt; 12345678910111213141516171819&lt;!--DOCTYPE：告诉浏览器使用什么规范（默认是html）--&gt;&lt;!DOCTYPE html&gt;&lt;!--语言 zh中文 en英文--&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;!--head标签代表网页头部--&gt;&lt;head&gt;&lt;!-- meta 描述性标签，表示用来描述网站的一些信息--&gt;&lt;!-- 一般用来做SEO--&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;keywords&quot; content=&quot;hyx的java学习&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;一起来学习java&quot;&gt; &lt;!--网站标题--&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;!--body代表主体--&gt;&lt;body&gt;Hello World！&lt;/body&gt;&lt;/html&gt; 2、网页基本标签 标题标签 段落标签 换行标签 水平线标签 字体样式标签 注释和特殊符号 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;基本标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;一级标签&lt;/h1&gt;&lt;!--标题标签--&gt;&lt;h2&gt;二级标签&lt;/h2&gt;&lt;h3&gt;三级标签&lt;/h3&gt;&lt;h4&gt;四级标签&lt;/h4&gt;&lt;h5&gt;五级标签&lt;/h5&gt;&lt;h6&gt;六级标签&lt;/h6&gt; &lt;!--段落标签--&gt;&lt;p&gt;p换行1&lt;/p&gt;&lt;p&gt;p换行2&lt;/p&gt;&lt;hr/&gt;&lt;!--水平线标签--&gt;换行1 &lt;br/&gt;&lt;!--换行标签--&gt;换行2 &lt;br/&gt;&lt;!--换行标签比较紧凑，段落标签有明显段间距--&gt;&lt;!--粗体 斜体--&gt;&lt;h1&gt;字体样式标签&lt;/h1&gt;粗体：&lt;strong&gt;I love you &lt;/strong&gt;&lt;br/&gt;斜体：&lt;em&gt;I love you &lt;/em&gt;&lt;br/&gt;&lt;!--特殊符号--&gt;空格：1&amp;nbsp;2&amp;nbsp;&amp;nbsp;3&amp;nbsp;&amp;nbsp;&amp;nbsp;4&lt;br/&gt;空格：1 2 3 4&lt;br/&gt;大于号&amp;gt;&lt;br/&gt;小于号&amp;rt;&lt;br/&gt;版权符号&amp;copy;&lt;br/&gt;&lt;!--特殊符号记忆：&amp;开头;结尾，只要在idea中&amp;敲出后就有提示--&gt;&lt;/body&gt;&lt;/html&gt; 图像标签 链接标签 href： 必填，表示要跳转到那个页面 target：表示窗口在那里打开 _blank：在新标签中打开 _self： 在自己的网页中打开 &gt; &copy; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;图像和链接标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--src:资源地址 相对地址，绝对地址 ../上级地址 alt：在图片加载失败的时候，就会用文字代替 title:鼠标悬停在图片上时，所显示的名字 width height 图片的高和宽--&gt;&lt;img src=&quot;../xxx.jpg&quot; alt=&quot;oops!图像不见了&quot; title=&quot;123&quot;&gt;&lt;br/&gt;&lt;!--href：跳转页面的地址 a标签内文字：即显示的文字 可以把图片放在a标签内，点击图片跳转网页 target:表示在哪打开新网页_self:当前标签打开 _blank:新的页面中打开--&gt;&lt;a href=&quot;https://www.baidu.com&quot; target=&quot;_blank&quot; title=&quot;123&quot;&gt;你xxxx不会百度吗&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.baidu.com&quot;&gt;&lt;img src=&quot;../xxx.jpg&quot; alt=&quot;oops!图像不见了&quot;&gt;&lt;/a&gt; &lt;!--锚链接 1.需要一个标记锚 2.跳转到标记 #页面内跳转--&gt;&lt;a name=&quot;top&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#top&quot;&gt;回到顶部&lt;/a&gt;&lt;br/&gt;&lt;!--也可以在网址后添加#号跳到对应网站的对应位置--&gt;&lt;a href=&quot;https://www.baidu.com#down&quot;&gt;百度底部&lt;/a&gt; &lt;br/&gt; &lt;!--功能性链接邮箱链接：mailtoqq链接--&gt;&lt;a href=&quot;mailto:xxxxxxqq.com&quot;&gt;点击联系我&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://wpa.qq.com/msgrd?v=xxx&amp;uin=&amp;site=qq&amp;menu=yes&quot;/&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://wpa.qq.com/msgrd?v=xxx&amp;uin=&amp;site=qq&amp;menu=yes&quot;&gt; &lt;img border=&quot;0&quot; src=&quot;http://wpa.qq.com/pa?p=2::52&quot; alt=&quot;点击这里加我领取小电影&quot; title=&quot;点击这里加我领取小电影&quot;/&gt;&lt;/body&gt;&lt;/html&gt; 行内元素和块元素 块元素 无论内容多少，该元素独占一行 1例如：&lt;p&gt;&lt;/p&gt;&lt;hr/&gt; &lt;h1&gt;...&lt;h6&gt; 行内元素：内容撑开宽度，左右都是行内元素的可以排在一行 1例如：&lt;a&gt;&lt;strong&gt;&lt;em&gt; 3、列表标签 什么是列表 列表就是信息资源的一种展示形式。它可以使信息结构化和条理化，并以列表的样式显示出来，以便浏览者能更快捷地获得相应的信息。 列表的分类： 无序列表 12345&lt;ol&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt;&lt;/ol&gt; 有序列表 1234567891011&lt;ul&gt;&lt;!--无序列表--&gt; &lt;li&gt;123 &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt;&lt;/ul&gt; 定义列表 1234567891011121314&lt;!--自定义列表dl：标签dt：列表名称dd：列表内容--&gt;&lt;dl&gt; &lt;dt&gt;学科&lt;/dt&gt; &lt;dd&gt;语文&lt;/dd&gt; &lt;dd&gt;数学&lt;/dd&gt; &lt;dd&gt;英语&lt;/dd&gt; &lt;dt&gt;语言&lt;/dt&gt; &lt;dd&gt;中文&lt;/dd&gt; &lt;dd&gt;英语&lt;/dd&gt; &lt;dd&gt;日语&lt;/dd&gt;&lt;/dl&gt; 4、表格 表格的基本结构： 单元格 行 列 跨行 跨列 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;表格&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--表格table 行 tr 列 td --&gt;&lt;table border=&quot;1px&quot;&gt; &lt;tr&gt;&lt;!--跨列--&gt; &lt;td colspan=&quot;3&quot;&gt;1-1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;&lt;!--跨行--&gt; &lt;td rowspan=&quot;2&quot;&gt;2-1&lt;/td&gt; &lt;td&gt;2-2&lt;/td&gt; &lt;td&gt;2-3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3-2&lt;/td&gt; &lt;td&gt;3-3&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 5、视频和音频 video audio 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;媒体元素&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--视频 src 资源路径 controls 控制面板 autoplay 自动播放--&gt;&lt;video src=&quot;xxx/xxx/xxx&quot; controls autoplay&gt;&lt;/video&gt;&lt;!--音频--&gt;&lt;audio src=&quot;xxx/xxx/xxx&quot; controls autoplay&gt;&lt;/audio&gt;&lt;/body&gt;&lt;/html&gt; 6、页面结构 元素名 描述 header 标题头部区域的内容（用于页面或者页面中的一块区域） footer 标记脚部区域的内容（用于整个页面或页面的一块区域） section Web页面中的一块独立区域 article 独立的文章内容 aside 相关内容或应用 nav 导航类辅助内容 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;页面结构&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--页面头部--&gt;&lt;header&gt; &lt;h2&gt;网页头部&lt;/h2&gt;&lt;/header&gt;&lt;section&gt; &lt;h2&gt;网页主体&lt;/h2&gt;&lt;/section&gt;&lt;footer&gt; &lt;h2&gt;网页脚部&lt;/h2&gt;&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; 7、iframe内联框架 1&lt;iframe src=&quot;path&quot; name=&quot;mainFrame&quot; &gt;&lt;/iframe&gt; ifram标签，必须要有src属性即引用页面的地址 给标签加上name属性后，可以做a标签的target属性，即在内联窗口中打开链接 8、表单(登录)语法(重点) from标签，action属性为所提交的目的地址，method选择提交方式 可以选择使用post或者get方式提交 get效率高，但在url中可以看到提交的内容，不安全，不能提交大文件 post比较安全且可以提交大文件 标签 说明 input标签 大部分表单元素对应的标签有text、password、checkbox、radio、submit、reset、file、hidden、image和button，默认为text，可以提交用户名、密码等等 select标签 下拉选择框 textarea标签 文本域 属性 说明 type 指定元素的类型。text、password、checkbox、radio、submit、reset、file、hidden、image和button，默认为text name 指定表单元素的名称（提交时所对应的key） value 元素的初始值，radio必须提供 size 指定表单元素的初始宽度。当type为text或者password时，以字符为单位；其他type以像素为单位 maxlength type为text或者password时，输入的最大字符数 checked 一些其他的属性 属性 说明 readonly 只读，不可更改 disable 禁用 hidden 隐藏，虽然不可见但是会提交 id 标识符，可以配合label的for属性增加鼠标的可用性 placehoder text 文字域等输入框内的提示信息 required 不能为空 patten 正则表达式验证 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;登录注册&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;注册&lt;/h1&gt;&lt;!--表单from action：表单提交的动作，可以是交给一个网址，也可以是交给一个请求处理地址 method：post get请求方式--&gt;&lt;form action=&quot;xxx/xxx&quot; method=&quot;get&quot;&gt; &lt;!--文本输入框：input type=&quot;text&quot;--&gt; &lt;p&gt;用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;请输入用户名&quot; maxlength=&quot;10&quot; size=&quot;20&quot;&gt;&lt;/p&gt; &lt;p&gt;密&amp;nbsp;&amp;nbsp;&amp;nbsp;码：&lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;请输入密码&quot; required=&quot;required&quot;&gt;&lt;/p&gt; &lt;!-- submit提交表单，reset清空--&gt; &lt;p&gt;&lt;input type=&quot;submit&quot;&gt; &lt;input type=&quot;reset&quot;&gt;&lt;/p&gt; &lt;!--单选框标签 type=&quot;radio&quot;：单选框的值 value：单选框的值 name：表示组 ,同一组要相同 --&gt; &lt;p&gt; &lt;input type=&quot;radio&quot; value=&quot;boy&quot; name=&quot;sex&quot;/&gt;男 &lt;input type=&quot;radio&quot; value=&quot;girl&quot; name=&quot;sex&quot; checked/&gt;女 &lt;/p&gt; &lt;p&gt;爱好： &lt;input type=&quot;checkbox&quot; value=&quot;b&quot; name=&quot;hobby&quot;&gt;打篮球 &lt;input type=&quot;checkbox&quot; value=&quot;s&quot; name=&quot;hobby&quot;&gt;唱rap &lt;input type=&quot;checkbox&quot; value=&quot;d&quot; name=&quot;hobby&quot;&gt;跳舞 &lt;/p&gt; &lt;p&gt;&lt;input type=&quot;button&quot; name=&quot;btn1&quot; value=&quot;按钮上文字&quot;&gt;&lt;!--按钮--&gt; &lt;input type=&quot;image&quot; src=&quot;xxx/xxx&quot;&gt;&lt;!--图片按钮默认是提交：和submit类似--&gt; &lt;/p&gt; &lt;p&gt;&lt;!--下拉框：selected:默认选项--&gt; 你来自： &lt;select name=&quot;location&quot;&gt; &lt;option value=&quot;china&quot;&gt;中国&lt;/option&gt; &lt;option value=&quot;us&quot; selected&gt;美国&lt;/option&gt; &lt;option value=&quot;japan&quot;&gt;日本&lt;/option&gt; &lt;/select&gt; &lt;/p&gt; &lt;p&gt;&lt;!--文本域--&gt; 反馈： &lt;textarea name=&quot;text&quot; id=&quot;10&quot; cols=&quot;30&quot; rows=&quot;10&quot; &gt;文本内容&lt;/textarea&gt; &lt;/p&gt; &lt;p&gt;&lt;!--文件域--&gt; &lt;input type=&quot;file&quot; name=&quot;files&quot;&gt; &lt;input type=&quot;button&quot; name=&quot;upload&quot; value=&quot;上传&quot;&gt; &lt;/p&gt; &lt;!--邮件：会简单验证是否是邮箱地址 url：会简单验证是否是网络地址 number：数字验证--&gt; &lt;p&gt;邮箱：&lt;input type=&quot;email&quot; name=&quot;email&quot;&gt; url：&lt;input type=&quot;url&quot;&gt;&lt;/p&gt; &lt;!--数字验证 max最大数量 min 最小数量 step 每次点击增加或减少的数量--&gt; &lt;p&gt;商品数量&lt;input type=&quot;number&quot; name=&quot;num&quot; max=&quot;100&quot; min=&quot;1&quot; step=&quot;1&quot;&gt;&lt;/p&gt; &lt;!--滑块--&gt; &lt;p&gt;音量：&lt;input type=&quot;range&quot; min=&quot;0&quot; max=&quot;100&quot; name=&quot;voice&quot; step=&quot;2&quot;&gt;&lt;/p&gt; &lt;!--搜索框--&gt; &lt;p&gt;搜索：&lt;input type=&quot;search&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;!--增强鼠标可用性--&gt; &lt;label for=&quot;mark&quot;&gt;你点我试试&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;mark&quot;&gt; &lt;/p&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端开发","slug":"前端开发","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"自动化Appium","slug":"自动化Appium","date":"2021-03-30T02:58:10.000Z","updated":"2021-04-23T13:21:45.138Z","comments":true,"path":"2021/03/30/自动化Appium/","link":"","permalink":"http://example.com/2021/03/30/%E8%87%AA%E5%8A%A8%E5%8C%96Appium/","excerpt":"","text":"资料来源:白月黑羽 自动化原理 我们先来看一下Appium自动化的原理图 这图是不是很眼熟？ 对啦，和Selenium 原理图很像。因为 Appium自动化架构就是借鉴的Selenium。 大家看看这幅图， 包含了 3个主体部分 ： 自动化程序、Appium Server、移动设备 自动化程序 自动化程序是由我们来开发的，实现具体的 手机自动化 功能。 要发出具体的指令控制手机，也需要使用 客户端库。 和Selenium一样，Appium 组织 也提供了多种编程语言的客户端库，包括 java，python，js， ruby等，方便不同编程语言的开发者使用。 我们需要安装好客户端库，调用这些库，就可以发出自动化指令给手机。 Appium Server Appium Server 是 Appium 组织开发的程序，它负责管理手机自动化环境，并且转发 自动化程序的控制指令 给 手机，并且转发 手机给 自动化程序的响应消息。 手机设备 我们这里说的手机设备，其实不仅仅是手机，包括所有 苹果、安卓的移动设备，比如：手机、平板、智能手表等。 为了直观方便的讲解，这里我们简称： 手机 当然手机上也包含了 我们要自动化控制的 手机应用APP。 手机设备为什么能 接收并且处理自动化指令呢？ 因为，Appium Server 会在手机上 安装一个 自动化代理程序， 代理程序会等待自动化指令，并且执行自动化指令 比如：要模拟用户点击界面按钮，Appium 自动化系统的流程是这样的： 自动化程序 调用客户端库相应的函数， 发送 点击元素 的指令（封装在HTTP消息里）给 Appium Server Appium Server 再转发这个指令给 手机上的自动化代理 手机上的自动化代理 接收到 指令后，调用手机平台的自动化库，执行点击操作，返回点击成功的结果给 Appium Server Appium Server 转发给 自动化程序 自动化程序了解到本操作成功后，继续后面的自动化流程 其中，自动化代理控制，使用的什么库来实现自动化的呢？ 如果测试的是苹果手机， 用的是苹果的 XCUITest 框架 （IOS9.3版本以后） 如果测试的是安卓手机，用的是安卓的 UIAutomator 框架 (Android4.2以后) 这些自动化框架提供了在手机设备上运行的库，可以让程序调用这些库，像人一样自动化操控设备和APP，比如：点击、滑动，模拟各种按键消息等。 自动化环境搭建 本教程主要讲解 安卓APP的自动化。 环境搭建需要下载安装不少软件，而且还有不少是国外网站下载的。 二.第一个程序 打开运行要Appium运行程序 1.联机后查看权限 adb devices -l 2.启动Appium 下面是一段使用 Appium 自动化的打开 B站 应用，搜索 白月黑羽 发布的教程视频，并且打印视频标题的示例。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from appium import webdriverfrom appium.webdriver.extensions.android.nativekey import AndroidKeydesired_caps = &#123; &#x27;platformName&#x27;: &#x27;Android&#x27;, # 被测手机是安卓 &#x27;platformVersion&#x27;: &#x27;8&#x27;, # 手机安卓版本 &#x27;deviceName&#x27;: &#x27;xxx&#x27;, # 设备名，安卓手机可以随意填写，苹果写具体的 &#x27;appPackage&#x27;: &#x27;tv.danmaku.bili&#x27;, # 启动APP Package名称 &#x27;appActivity&#x27;: &#x27;.ui.splash.SplashActivity&#x27;, # 启动Activity名称 #输入法有关 &#x27;unicodeKeyboard&#x27;: True, # 使用自带输入法，输入中文时填True &#x27;resetKeyboard&#x27;: True, # 执行完程序恢复原来输入法 &#x27;noReset&#x27;: True, # 不要重置App，申去登录等操作 &#x27;newCommandTimeout&#x27;: 6000, &#x27;automationName&#x27; : &#x27;UiAutomator2&#x27; # &#x27;app&#x27;: r&#x27;d:\\apk\\bili.apk&#x27;,&#125;# 连接Appium Server，初始化自动化环境webDriver对象用于控制手机；Appium Server是一个服务端，desired_caps是一个信息driver = webdriver.Remote(&#x27;http://localhost:4723/wd/hub&#x27;, desired_caps)# 设置缺省等待时间driver.implicitly_wait(5)# 如果有`青少年保护`界面，点击`我知道了`iknow = driver.find_elements_by_id(&quot;text3&quot;)if iknow: iknow.click()# 根据id定位搜索位置框，点击driver.find_element_by_id(&quot;expand_search&quot;).click()# 根据id定位搜索输入框，点击sbox = driver.find_element_by_id(&#x27;search_src_text&#x27;)sbox.send_keys(&#x27;白月黑羽&#x27;)# 输入回车键，确定搜索driver.press_keycode(AndroidKey.ENTER)# 选择（定位）所有视频标题eles = driver.find_elements_by_id(&quot;title&quot;)for ele in eles: # 打印标题 print(ele.text)input(&#x27;**** Press to quit..&#x27;)driver.quit() 运行代码前，要先 `运行 Appium Desktop 上面的代码只是抓取一页视频标题，要自动化滚动抓取所有的视频标题，实战班学员 ，请联系老师获取参考代码。 游客 也可以 分享课程 领取参考代码，点击这里查看 查找 应用 Package 和 Activity 没有apk 如果你应用已经安装在手机上了，可以直接打开手机上该应用，进入到你要操作的界面 然后执行 都是第一行 1adb shell dumpsys activity recents | find &quot;intent=&#123;&quot; 会显示如下，最近的 几个 activity 信息， 1234intent=&#123;act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=tv.danmaku.bili/.ui.splash.SplashActivity&#125;intent=&#123;act=android.intent.action.MAIN cat=[android.intent.category.HOME] flg=0x10000300cmp=com.huawei.android.launcher/.unihome.UniHomeLauncher&#125;intent=&#123;flg=0x10804000 cmp=com.android.systemui/.recents.RecentsActivity bnds=[48,1378][10322746]&#125;intent=&#123;flg=0x10000000 cmp=com.tencent.mm/.ui.LauncherUI&#125; 其中第一行就是当前的应用，我们特别关注最后 1cmp=tv.danmaku.bili/.ui.splash.SplashActivity 应用的package名称就是 tv.danmaku.bili 应用的启动Activity就是 .ui.splash.SplashActivity 有apk 安装电脑端程序 如果你已经获取到了 apk，在命令行窗口执行 1d:\\tools\\androidsdk\\build-tools\\29.0.3\\aapt.exe dump badging d:\\tools\\apk\\bili.apk | find &quot;package: name&#x3D;&quot; 输出信息中，就有应用的package名称 1package: name=&#x27;tv.danmaku.bili&#x27; versionCode=&#x27;5531000&#x27; versionName=&#x27;5.53.1&#x27; platformBuildVersionName=&#x27;5.53.1&#x27; compileSdkVersion=&#x27;28&#x27; compileSdkVersionCodename=&#x27;9&#x27; 在命令行窗口执行 1d:\\tools\\androidsdk\\build-tools\\29.0.3\\aapt.exe dump badging d:\\tools\\apk\\bili.apk | find &quot;launchable-activity&quot; 输出信息中，就有应用的启动Activity 1launchable-activity: name=&#x27;tv.danmaku.bili.ui.splash.SplashActivity&#x27; label=&#x27;&#x27; icon=&#x27;&#x27; 三.定位元素 页面变化后重新定位元素 代码规则 从示例代码，大家就可以发现，和Selenium Web自动化一样，要操作界面元素，必须先 定位（选择）元素。 Appium是基于Selenium的，所以 和 Selenium 代码 定位元素的 基本规则相同： find_element_by_XXX 方法，返回符合条件的第一个元素，找不到抛出异常 find_elements_by_XXX 方法，返回符合条件的所有元素的列表，找不到返回空列表 通过 WebDriver 对象调用这样的方法，查找范围是整个界面 通过 WebElement 对象调用这样的方法，查找范围是该节点的子节点 界面元素查看工具 做 Selenium Web 自动化的时候，要找到元素，我们是通过浏览器的开发者工具栏来查看元素的特性，根据这些特性（属性和位置），来定位元素 Appium 要自动化手机应用，同样需要工具查看界面元素的特征。 常用的查看工具是： Android Sdk包中的 uiautomateviewer 和 Appium Desktop 中的 Appium Inspector uiautomateviewer 安卓查看APP界面元素，最常用的就是 Android SDK 中的工具 uiautomateviewer ，它在SDK目录目录 的 tools\\bin 目录中 抓取界面信息 和Selenium一样，我们要定位选择元素，也是根据元素的特征，包括 元素的属性 id可以写上斜杠前面的 元素的相对位置（相对父元素、兄弟元素等） bounds左上角边界坐标 Appium Inspector Appium Desktop 中的 Appium Inspector 也可以查看元素。 一个个加参数保存 它的一个优点是可以直接验证 选择表达式是否能定位到元素 定位元素的方法 根据ID 在Selenium Web自动化教程里，我们说过，如果能根据ID选择定位元素，最好根据ID，因为通常来说ID是唯一的，所以根据ID选择 效率高。 在安卓应用自动化的时候，同样可以根据ID查找。 但是这个ID ，是安卓应用元素的 resource-id 属性一般不是唯一的和网页不一样 使用如下代码 12driver.find_element_by_id(&#x27;expand_search&#x27;)driver.find_elements_by_id(&#x27;expand_search&#x27;)#非唯一用find_elements 具体细节，参考视频里面的讲解。 根据CLASS NAME 安卓界面元素的 class属性 其实就是根据元素的类型，类似web里面的tagname， 所以通常不是唯一的。 通常，我们根据class 属性来选择元素， 是要选择多个而不是一个。 当然如果你确定 要查找的 界面元素的类型 在当前界面中只有一个，就可以根据class 来唯一选择。 使用如下代码 1driver.find_elements_by_class_name(&#x27;android.widget.TextView&#x27;) 根据ACCESSIBILITY ID 元素的 content-desc 属性是用来描述该元素的作用的。 如果要查询的界面元素有 content-desc属性，我们可以通过它来定位选择元素。 使用如下代码 1driver.find_element_by_accessibility_id(&#x27;找人&#x27;) Xpath Appium 也支持通过 Xpath选择元素。 但是其可靠性和性能不如 Selenium Web自动化。因为Web自动化对Xpath的支持是由浏览器实现的，而Appium Xpath的支持是 Appium Server实现的。 毕竟，浏览器产品的成熟度比Appium要高很多。 当然，Xpath是标准语法，所以这里表达式的语法规则和 以前学习的Selenium里面Xpath的语法是一样的，比如 1driver.find_element_by_xpath(&#x27;//ele1/ele2[@attr=&quot;value&quot;]&#x27;) 注意： selenium自动化中， xpath表达式中每个节点名是html的tagname。 但是在appium中， xpath表达式中 每个节点名 是元素的class属性值。 比如：要选择所有的文本节点(写全)，就使用如下代码 123driver.find_element_by_xpath(&#x27;//android.widget.TextView&#x27;)#按照属性来 *是任意的节点@属性名 /子元素 //后代元素driver.find_element_by_xpath(&quot;//*[@resource-id=&#x27;tv.danmaku.bili:id/title&#x27;]&quot;) 安卓 UIAutomator 根据id，classname， accessibilityid，xpath，这些方法选择元素，其实底层都是利用了安卓 uiautomator框架的API功能实现的。 参考 这里的谷歌安卓官方文档介绍： https://developer.android.google.cn/training/testing/ui-automator 也就是说，程序的这些定位请求，被Appium server转发给手机自动化代理程序，就转化为为uiautomator里面相应的定位函数调用。 其实，我们的自动化程序，可以直接告诉 手机上的自动化代理程序，让它 调用UI Automator API的java代码，实现最为直接的自动化控制。 主要是通过 UiSelector 这个类里面的方法实现元素定位的，比如 123code = &#x27;new UiSelector().text(&quot;热门&quot;).className(&quot;android.widget.TextView&quot;)&#x27;ele = driver.find_element_by_android_uiautomator(code)ele.click() 就是通过 text 属性 和 className的属性 两个条件 来定位元素。 UiSelector里面有些元素选择的方法 可以解决 前面解决不了的问题。 比如 text 方法 可以根据元素的文本属性查找元素 textContains 根据文本包含什么字符串 textStartsWith 根据文本以什么字符串开头 textmartch 方法 可以使用正则表达式 选择一些元素，如下 1code = &#x27;new UiSelector().textMatches(&quot;^我的.*&quot;)&#x27; UiSelector 的 instance 和 index 也可以用来定位元素，都是从0开始计数， 他们的区别： instance是匹配的结果所有元素里面 的第几个元素 index则是其父元素的几个节点，类似xpath 里面的*[n] UiSelector 的 childSelector 可以选择后代元素，比如 123code = &#x27;new UiSelector().resourceId(&quot;tv.danmaku.bili:id/recycler_view&quot;).childSelector(new UiSelector().className(&quot;android.widget.TextView&quot;))&#x27;ele = driver.find_element_by_android_uiautomator(code) 注意： childSelector后面的引号要框住整个 子 uiSelector 的表达式 目前有个bug：只能找到符合条件的第一个元素，参考appium 在github上的 issues： https://github.com/appium/java-client/issues/150 四.界面操作 和 adb 命令 界面操作 click点击 最常见的操作之一，使用 WebElement 对象的 click 方法， 示例代码就讲过，不再赘述，element元素才有的操作 tap点按 WebElement 对象的 tap 方法和 click 类似，都是点击界面。 但是最大的区别是， tap是 针对坐标 而不是针对找到的元素。 为了保证自动化代码在所有分辨率的手机上都能正常执行，我们通常应该使用click方法。 但有的时候，我们难以用通常的方法定位元素， 可以用这个tap方法，根据坐标来点击 既然tap是用坐标来点击界面的，我们怎么知道这个元素的坐标呢？ 大家还记得用inspect 查看该元素的属性中，有一个 bounds 属性吗？ 它就是表示元素的左上角，右下角坐标的 坐标。 我们还可以使用 UIAutomatorviewer 直接光标移动，看右边的属性提示。 tap 方法可以像这样进行调用 1234567891011121314driver.tap([(850,1080)],300)def __init__(self,driver): self.driver = driver # 获取屏幕的 size self.size = driver.get_window_size() # 获取屏幕宽度 width self.width = self.size[&#x27;width&#x27;] # 获取屏幕高度 height self.height = self.size[&#x27;height&#x27;] # 坐标定位、点击长按通用，调试机型屏幕分辩2280*1080,只适配全面屏、2K # 注意全面屏与有底部导航的分辨率不一样，要考虑Y轴的底部导航,[(x,y),z]，z：持续时间 def driverTap(self,x,y,z=None): self.driver.tap([((x/1080)*self.width,(y/2280)*self.height)],z) 它 有 两个参数： 第一个参数是个列表，表示点击的坐标。 注意最多可以有5个元素，代表5根手指点击5个坐标。所以是list类型。 如果我们只要模拟一根手指点击屏幕，list中只要一个元素就可以了 第二个参数 表示 tap点按屏幕后 停留的时间。 如果点按时间过长，就变成了长按操作了。 输入 最常见的操作之一， 使用 WebElement 对象的 send_keys 方法， 示例代码就讲过，不再赘述 获取界面文本信息 可以通过 WebElement 对象的 .text 属性获取该对象的文本信息，示例代码就讲过，不再赘述。 滑动 我们做移动app测试的时候，经常需要滑动界面。 怎么模拟滑动呢？ WebDriver对象的 swipe方法，就提供了这个功能 比如 1driver.swipe(start_x=x, start_y=y1, end_x=x, end_y=y2, duration=800) 前面4个参数 是 滑动起点 和 终点 的x、y坐标。 第5个参数 duration是滑动从起点到终点坐标所耗费的时间。 注意这个时间非常重要，在屏幕上滑动同样的距离，如果时间设置的很短，就是快速的滑动。 比如：一个翻动新闻的界面，快速的滑动，就会是扫动的动作，会导致内容 惯性 滚动很多。 按键 前面的示例代码中已经使用过 调用 press_keycode 方法，就能模拟 按键动作，包括安卓手机的实体按键和 键盘按钮。 如下代码所示 1234from appium.webdriver.extensions.android.nativekey import AndroidKey# 输入回车键，确定搜索driver.press_keycode(AndroidKey.ENTER) 按键的定义，可以参考这篇文档 https://github.com/appium/python-client/blob/master/appium/webdriver/extensions/android/nativekey.py 长按、双击、移动 Appium的 TouchAction 类提供了更多的手机操作方法，比如：长按、双击、移动 参考源代码中的注释 https://github.com/appium/python-client/blob/master/appium/webdriver/common/touch_action.py 比如，下面就是一个长按的例子 12345from appium.webdriver.common.touch_action import TouchAction# ...actions = TouchAction(driver)actions.long_press(element)actions.perform() 查看通知栏 打开通知栏 安卓手机， 查看通知栏的动作可以是从屏幕顶端下滑来查看通知。 我们刚刚学过滑动，感兴趣的朋友可以自己试试，关键是要找对滑动的起始点和滑动距离。 更方便的，我们可以使用如下代码，直接打开通知栏 1driver.open_notifications() 通知栏里面的元素，自动化的方法 和 前面介绍的App界面元素自动化是一样的。 收起通知栏 收起通知栏，可以使用前面介绍的模拟按键， 发出返回按键 的方法。 等待 Python里有三种等待的方式： 强制等待 1234567 from time import sleep sleep(10) # 表示强行等待10s在执行下一句代码 driver.findelementby(id)这种等待方式时间到了就会执行下个语句，但比较死板，不能保证在等待的时间内元素真正被加载了出来。 隐性等待 Implicitly_wait(xxx) 这个等待表示在规定的时间内页面的所有元素都加载完了就执行下一步，否则一直等到时间截止，然后再继续下一步。 driver.implicitly_wait(10)#等待10s driver.find_element_by_id(common_util.get_id_value(‘IMAGEID’)).click() 这个方法的缺点是你需要的元素已经加载出来了，但页面还没有加载完，再需要继续等待页面加载完才能执行下一步操作。 显性等待 WebDriverWait，配合该类的until()和until_not()方法，表示程序每隔x秒去判断一下指定的元素是否加载完，加载完了就执行下一步，否则继续每隔x秒去判断，指定时间截止。如果超时就会抛出异常。 需要导入的包 adb 命令 这里我们给大家 介绍一个android sdk里面的命令行工具 adb 。 adb 全程 Android Debug Bridge，这个adb 使用非常广泛。 它可以与 Android 手机设备进行通信，它可进行各种设备操作。 比如： 安装应用和调试应用，传输文件，甚至登录到手机设备上shell的进行访问，就像远程登录一样 这个adb 在 sdk的 platform-tools 目录下面， 请大家确保路径在path环境变量中。 Appium 对anroid的自动化就非常依赖这个adb工具。 执行自动化过程中，有很多内部操作，比如获取设备信息，传送文件到手机，安装apk，启动某些程序等，都是通常这个adb实现的。 大家想想我们学习了adb命令，对我们的自动化程序有什么用例呢？ 既然这是个命令，就可以使用 Python的 os.system() 或者 subprocess 来自动化调用它，完成我们的各种自动化需求。 比如，我们自动化过程中，可能需要截屏手机，并且下载到指定目录中，就可以在我们的Python程序中这样写 12import osos.system(&#x27;adb shell screencap /sdcard/screen3.png &amp;&amp; adb pull /sdcard/screen3.png&#x27;) 特别是，还可以通过adb 使用 am(activity manager) 和pm (package manager) 两个工具， 可以启动 Activity、强行停止进程、广播 intent、修改设备屏幕属性、列出应用、卸载应用等。 大家可以点击这里查看官方文档中介绍的adb命令 下面我们列出了一些场景的adb命令 查看连接的设备 adb shell dumpsys activity recents | find “intent={” 1adb devices -l 列出文件和传输文件 查看目录 1adb shell ls /sdcard 上传 1adb push wv.apk /sdcard/wv.apk 下载 1adb pull /sdcard/new.txt 截屏 1adb shell screencap /sdcard/screen.png 截屏后的文件存在手机上，可以使用 adb pull 下载下来 shell 登录到手机设备上shell的进行访问，就像远程登录一样，可用来在连接的设备上运行各种命令。 大家可以 执行一下 adb shell 然后执行各种 安卓支持的 Linux命令，比如 ps、netstat、netstat -an|grep 4724、 pwd、 ls 、cd 、rm 等。 执行quit退出 shell","categories":[{"name":"数据获取","slug":"数据获取","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"}],"keywords":[{"name":"数据获取","slug":"数据获取","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96/"}]},{"title":"尚硅谷Linux","slug":"尚硅谷Linux","date":"2021-03-30T02:58:10.000Z","updated":"2021-04-23T13:32:09.333Z","comments":true,"path":"2021/03/30/尚硅谷Linux/","link":"","permalink":"http://example.com/2021/03/30/%E5%B0%9A%E7%A1%85%E8%B0%B7Linux/","excerpt":"","text":"写在前面 学习链接：尚硅谷韩顺平Linux教程 C3 虚拟机 虚拟机的网络连接三种形式说明 桥连接：Linux可以和其他的系统通信。但是可能造成IP冲突。 NAT：网络地址转换方式：Linux可以访问外网，不会造成IP冲突。 主机模式：你的Linux是一个独立的主机，不能访问外网。 vmtools: 共享文件夹 共享剪贴板 C4 Linux目录结构(*) Linux世界里，一切皆文件。 /bin：是Binary的缩写，这个目录存放着最经常使用的命令。 /sbin：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。 /home：存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。 /root：该目录为系统管理员，也称作超级权限者的用户主目录。 /lib：系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。 /lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 /etc：所有的系统管理所需要的配置文件和子目录my.conf。 /usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录。 /boot：存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。 /proc：这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息。 /srv：service的缩写，该目录存放一些服务启动之后需要提供的数据。 /sys：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统sysfs。 /tmp：这个目录是用来存放一些临时文件的。 /dev：类似windows的设备管理器，把所有的硬件用文件的形式存储。 /media：linux系统会自动识别一些设备，例如U盘光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。 /mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt/上，然后进入该目录就可以查看里面的内容了。 /opt：这是给主机额外安装软件所摆放的目录，如安装ORACLE数据库就可放到该目录下。默认为空。 /usr/local：这是另一个给主机额外安装软件所安装的目录，一般是通过编译源码的方式安装的程序。 /var：这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下，包括各种日志文件。 /selinux：SELinux是一种安全子系统，它能控制程序只能访问特定文件。 总结： Linux的目录中有且只有一个根目录 /。 Linux的各个目录存放的内容是规划好，不用乱放文件。 Linux是以文件的形式管理我们的设备，因此linux系统，一切皆为文件。 Linux的各个文件目录下存放什么内容，必须有一个认识。 C5 远程登录Linux系统 远程登录：XShell5 远程上传下载文件：Xftp5 C6 vi和vim编辑器 三种常见模式： 正常模式 在正常模式下，我们可以使用快捷键。 插入模式/编辑模式 在这个模式下，程序猿可以输入内容。 命令行模式 在这个模式中，可以提供相关指令。:q! -&gt;表示强制不保存退出，不对文件进行保存 快捷键使用练习： yy：拷贝当前行（p 粘贴） 5yy：拷贝当前行下的5行 dd：删除当前行 5dd：删除当前行向下的5行 在文件中查找某个单词：命令行输入 /（查找内容），按n查找下一个 设置文件行号：set nu，取消文件行号：set nonu 编辑文件，正常模式下使用快捷键到达文档最末行：G，最首行：gg 撤销输入：在正常模式下输入u 编辑文件，光标移动到某行：shift+g 显示行号：set nu 输入行号这个数 输入shift+g C7 关机、重启和用户登录注销 shutdown -h now：表示立即关机 shutdown -h 1：表示1分钟后关机 shutdown -r now：立即重启 halt：直接使用，关机 reboot：重启 sync：把内存的数据同步到磁盘上，当我们关机或者重启时，都应该先执行一下sync，防止数据丢失。 logout：注销用户，在图形运行级别无效，在运行级别3有效。 C8 用户管理 ![在这里插入图片描述](file://D:/code%20file/markdown/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%8B%82%E7%A5%9E%E8%AF%B4Linux/20200630091157920.png?lastModify=1618148536) ![在这里插入图片描述](file://D:\\code file\\markdown\\images\\20200630091910216.png?lastModify=1618148567) 8.1基本结束 ​ 用户，组，家目录 说明：1.Linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。 2.Linux的用户需要至少要属于一个组。 8.2添加用户 8.2.1.添加用户：useradd [选项] 用户名。 当创建用户成功后，会自动的创建和用户同名的家目录。 8.2.2.也可以通过useradd -d 指定目录 新的用户名。 1useradd -d /home/xw xq 8.3指定/修改密码 passwd 用户名 8.4删除用户 8.4.1保留家目录：userdel 用户名， 一般保留家目录，因为干过的活要留着。 8.4.2删除用户以及家目录：userdel -r 用户名 8.5查询用户信息 id 用户名 8.6切换用户 8.6.1 su - 切换用户名，从权限高切换到权限低的用户不需要输密码。 8.6.2 返回切换前的用户：exit 查看当前用户/登录用户：who am i 8.7用户组 类似于角色，系统可以对有共性的多个用户进行统一的管理。 8.7.1增加组：groupadd 组名 8.7.2删除组：groupdel 组名 8.8增加用户时直接加上组 8.8.1useradd -g 用户组 用户名 8.9修改用户组 usermod -g 用户组 用户名 8.10相关文件配置 8.10.1 /etc/passwd 文件 用户（user）的配置文件，记录用户的各种信息。 每行的含义：用户名：口令：用户标识号：注释性描述：主目录：登录shell 8.10.2 /etc/shadow 文件 口令配置文件 每行的含义：登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志 8.10.3 /etc/group 文件 组（group）的配置文件，记录Linux包含的组的信息。 每行含义：组名：口令：组标识号：组内用户列表 C9实用指令 9.1指定运行级别（7个级别） 关机 单用户【找回丢失密码】 多用户状态有网络服务 （保留） 系统未使用保留给用户 图形界面 系统重启 系统的运行级别配置文件：/etc/inittab 切换到指定运行级别的指令：init [012356] 面试题：如何找回丢失的root密码？： ​ 进入到单用户模式，然后修改root密码。因为进入单用户模式，root不需要密码就可以登录。【开机-&gt;在引导时输入 回车键-&gt;看到一个界面输入 e-&gt;看到一个新的界面，选中第二行（编辑内核），再输入 e-&gt;在这行最后输入 1，再输入 回车键-&gt;再输入b，这时就会进入到单用户模式，使用passed来修改root密码。】 9.2帮助指令： man [命令或配置文件] help(内置命令的功能信息) 9.3文件目录类 pwd：Print Working Directory，显示当前工作目录的绝对路径。 ls：-a：显示当前目录所有的文件和目录，包括隐藏的；-l：以列表的方式显示信息。 cd：cd ~：回到自己的家目录；cd …：回到当前目录的上一级目录。 mkdir：创建目录；-p：创建多级目录。 rmdir：删除空目录。rmdir不能删除非空的目录。如果需要删除非空的目录，需要使用rm -rf。 touch：创建空文件。可以一次性创建多个文件 cp：拷贝文件到指定目录；-r：递归复制整个文件夹。强制覆盖不提示的方法：cp命令改为\\cp 12cp -r /home/test/ home/zwj/ %将/home/test整个目录拷贝到/home/zwj目录 rm：移除文件或目录；-r：递归删除整个文件夹；-f：强制删除不提示。 mv：移动文件与目录或重命名，两种功能！ 1234%重命名mv aaa.txt pig.txt%移动mv aaa.txt &#x2F;home&#x2F;text&#x2F; cat：查看文件内容。只能浏览文件，而不能修改文件。-n：显示行号。结尾加上 | more：分页显示，不会全部一下显示完。 more：是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more还内置了很多快捷键： 操作 功能说明 空白键（Space） 向下翻一页 Enter 向下翻一行 q 立刻离开more，不再显示该文件内容 Ctrl + F 向下滚动一屏 Ctrl + B 返回上一屏 = 输出当前行的行号 ：f 输出文件名和当前行的行号 less：用来分屏查看文件内容，与more相似，但是更强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容。对于显示大型文件具有较高的效率。 操作 功能说明 空白键（Space） 向下翻一页 Enter 向下翻一行 q 立刻离开more，不再显示该文件内容 /字串 向下查找字串 n:向下查找 N:向上查找 ?字串 向上查找字串 n:向下查找 N:向上查找 &gt;指令：输出重定向。如果不存在会创建文件，否则会将原来的文件内容覆盖。 &gt;&gt;指令：追加。如果不存在会创建文件，否则不会覆盖原来的文件内容，而是追加到文件的尾部。 1234ls -l&gt; 1.txt %将列表内容写入a.txt覆盖写ls -al &gt;&gt; 文件 %将列表内容追加到文件末尾cat 文件1 &gt; 文件2 %将文件1的内容覆盖到文件2echo 内容&gt;&gt;文件 %向文件追加内容 cat是查看，echo是写入，echo （内容） &gt;&gt; 文件 echo：输出内容到控制台。 1[root@localhost ~]# echo $PATH %输出当前路径 head：显示文件的开头部分。-n 5：看前面5行内容。 tail：输出文件中尾部的内容。-n 5：看后面5行内容。-f：时事追踪该文档的所有更新 history:查看已经执行过的历史命令，也可以执行历史命令 1234%先查看历史指令history%执行指定历史标号为5的指令！5 9.4时间日期类 date：显示当前日期和时间 date “+%Y”：显示当前年份 date “+%d”：显示当前月份 date “+%Y-%m-%d %H:%M:%S”：显示年-月-日 时：分：秒 设置日期：date -s 字符串时间 1date -s &quot;2021-04-06 21:15:50&quot; cal：查看日历指令；cal 年份：显示某一年一整年的日历 9.5搜索查找类 find：从指定目录向下递归的遍历其各个子目录，将满足条件的文件或者目录显示在终端。 find (搜索范围) -name (文件名)：按照指定的文件名查找模式查找文件。 12341.按文件名:根据名称查找/~目录下的1.txt文件[root@localhost ~]# find /root -name 1.txt/root/a/1.txt/root/1.txt find (搜索范围) -user (用户名)：按照指定的用户名查找模式查找文件。 find (搜索范围) -size (+多少/-多少/多少)：按照指定的文件大小查找模式查找文件（大于多少/小于多少/等于多少） 查询 /目录下所有.txt的文件：find / -name *.txt locate：locate (搜索文件) 可以快速定位文件路径。locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件。locate指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新locate时刻。 在第一次运行之前，必须使用updatedb指令创建locate数据库。 grep：过滤查找，表示将前一个命令的处理结果输出传递给后面的命令处理。经常跟管道|一起使用。 grep [选项] 查找内容 源文件 -n：显示匹配行及行号。 -i：忽略大小写字母。 在hello.txt文件中，查找”yes“所在行显示行号 cat hello.txt | grep -ni yes 12345678910111213141516171819202122232425262728293031323334353637 ### 9.6压缩和解压类- gzip&#x2F;gunzip：压缩文件&#x2F;解压 - gzip (文件)：压缩为.gz文件，原来文件不保留。 - gunzip (文件)：解压缩，同样也不保留源文件。- zip&#x2F;unzip：压缩文件&#x2F;解压 - zip [选项] (压缩后文件xxx.zip) (将要压缩的文件) - unzip [选项] (要解压的文件xxx.zip) - zip -r：递归压缩，即压缩目录 - unzip -d (目录)：指定解压后的文件的存放目录 ![image-20210406213405719](%E5%B0%9A%E7%A1%85%E8%B0%B7Linux&#x2F;image-20210406213405719-1617716145814.png)- tar：打包指令，最后打包后的文件是**.tar.gz的**文件 - tar [选项] xxx.tar.gz (打包的内容) - -c：产生.tar打包文件 - -v：显示详细信息 - -f：指定压缩后的文件名 - -z：打包同时压缩 - **-x：解压.tar文件** - 压缩：**tar -zcvf** (压缩后文件名) (要压缩的文件) - 解压：**tar -zxvf** (要解压的文件) - 解压到指定目录：tar -zxvf (要解压的文件) -C (指定目录)，指定解压到的目录要存在。 &#96;&#96;&#96;shell 1.将当前目录下的1.txt压缩成a.tar.gz tar -zcvf a.tar.gz 1.txt 2.解压 [root@localhost ~]# tar -zxvf a.tar.gz 1.txt C10组管理和权限管理 文件： 所有者 所在组 其他组 改变用户所在组 文件/目录所有者： 一般为文件的创建者，谁创建了该文件，就自然的称为该文件的所有者。 查看文件所有者：ls -ahl 修改文件所有者：chown (用户名) (文件名) 文件所在组不一定是文件所有者。 组的创建 groupadd (组名) 文件/目录所在组 修改文件所在组：chgrp (组名) (文件名) 其他组 除文件的所有者和所在组的用户外，系统的其他用户都是文件的其他组 改变用户所在组 在添加用户时，可以指定将该用户添加到哪个组中，同样的用root的管理权限可以改变某个用户所在的组 改变用户所在组：usermod -g 组名 用户名 改变用户登录的初始目录：usermod -d 目录名 用户名 权限的基本介绍 文件类型： -：普通类型 d：目录 l：软连接 c：字符设备【键盘、鼠标等】 b：块文件【硬盘】 ls -l 显示内容说明： rw-：表示文件所有者权限（rw，读写） r–：表示文件所在组的用户的权限（r，只有读的权限） r–：表示文件其他组的用户的权限（r，只有读的权限） 1：如果是文件，表示硬连接的数；如果是目录则表示该目录的子目录个数 tom：文件所有者 bandit：文件所在组 0：文件的大小，0个字节；如果是目录，则统一为4096 July 1 13：40：文件最后的修改时间 ok.txt：文件名 rwx权限详解 rwx作用到文件： r：read，可读。读取查看。 w：write，可以修改。但不代表可以删除该文件。删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件。 x：execute，可执行。可以被执行。 rwx作用到目录： r：可以读取，ls查看目录内容。 w：可以修改，目录内创建+删除+重命名目录。 x：可执行，可以进入该目录。 修改权限 chmod 修改文件或者目录的权限 u：所有者；g：所在组；o：其他人；a：所有人（u、g、o的总和） chmod u=rwx，g=rx，o=x 文件目录名：分别权限 chmod o+w 文件目录名：给其他人都增加写的权限 chmod a-x 文件目录名：给所有的用户都减掉执行权限 通过数字变更权限 规则：r=4 w=2 x=1 rwx=4+2+1=7 chmod u=rwx，g=rx，o=x 文件目录名 等价于 chmod 751 文件目录名 修改文件所有者 chown chown newowner file：改变文件的所有者 chown newowner：newgroup file：改变用户的所有者和所在组 -R：如果是目录，则使其下所有子文件或目录递归生效 修改文件所在组 chgrp chgrp newgroup file：改变文件的所有组 -R：如果是目录，则使其下所有子文件或目录递归生效 C11定时任务调度 11.1原理图 –用于如：mysql备份的个人用户工作和系统工作 11.2基本语法 crond任务调度：crontab进行定时任务调度 crontab [选项] -e：编辑crontab定时任务 -i：查询crontab任务 -r：删除当前用户所有的crontab任务，终止调度 -l：列出当前有哪些任务调度 service crond restart：重启任务调度 步骤 crone -e 进入vim */1 * * * * Is -l /etc &gt;&gt; /tmp/to.txt 当保存退出后就程序。 在每一分钟都会自动的调用Is _I /etc》/tmp/to.txt 11.3参数细节说明 项目 含义 范围 第一个“*” 一小时当中的第几分钟 0-59 第二个“*” 一天当中的第几小时 0-23 第三个“*” 一个月当中的第几天 1-31 第四个“*” 一年当中的第几月 1-12 第五个“*” 一周当中的星期几 0-7（0和7都代表星期日） 特殊符号说明 *：代表任何时间。比如第一个*就代表一小时中每分钟都执行一次的意思。 ,：代表不连续的时间。比如“0 8,12,16 * * *命令”，就代表在每天的8点0分，12点0分，16点0分都执行一次命令。 -：代表连续的时间范围。比如“0 5 * * 1-6命令”，代表在周一到周六的凌晨5点0分执行命令。 /n：代表每隔多久执行一次。比如“*/10 * * * * 命令”，代表每隔10分钟就执行一遍命令。 11.4案例 C12Linux磁盘分区、挂载 12.1分区的方式 mbr分区 最多支持四个主分区 系统只能安装在主分区 扩展分区要占一个主分区 MBR最大只支持2TB，但拥有最好的兼容性 gpt分区 支持无限多个主分区（但操作系统可能限制，比如windows下最多128个分区） 最大支持18EB的大容量（1EB=1024PB，PB=1024TB） windows7 64位以后支持gpt 12.2Linux分区 Linux来说无论有几个分区，分给哪一个目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构，Linux中每个分区都是用来组成整个文件系统的一部分。 Linux采用了一种叫做**“载入”的处理方法**，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。 直接看大小 硬盘说明 Linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘 lsblk -f：查看当前系统的分区和挂载情况。（list block老师不离开） 12.3挂载的经典案例 需求是给我们的Linux系统增加一个新的硬盘，并且挂载到/home/newdisk 虚拟机添加硬盘 分区：fdsk /dev/sdb 格式化：mkfs -t ext4 /dev/sdb1 挂载：新建目录：mkdir /home/newdisk；挂载：mount /dev/sdb1 /home/newdisk 设置可以自动挂载（永久挂载）：重启系统后，仍然可以挂载。vim etc/fstab 增加挂载信息。mount -a：生效 取消挂载：unmount /dev/sdb1 磁盘情况查询：df -h / df -l 查询指定目录的磁盘占用情况：du -h /目录，默认为当前目录 -s：指定目录占用大小汇总 -h：带计量单位 -a：含文件 –max-depth=1：子目录深度 -c：列出明细的同时，增加汇总值 磁盘情况-工作实用指令 统计/home文件夹下文件的个数：ls -l /home | grep &quot;^-&quot; | wc -l 统计/home文件夹下目录的个数：ls -l /home | grep &quot;^d&quot; | wc -l 统计/home文件夹下文件的个数，包括子文件夹里的：ls -lR /home | grep &quot;^-&quot; | wc -l 统计文件夹下目录的个数，包括子文件夹里的：ls -lR /home | grep &quot;^d&quot; | wc -l 以树状显示目录结构：首先安装tree指令：yum install tree，tree C13网络配置 指定固定IP：直接修改配置文件来指定IP，并可以连接到外网，编辑：vim /etc/sysconfig/network-scripts/ifcfg-eth0 重启网络服务：service network restart C14进程管理 14.1进程的介绍 在Linux中，每个执行的**程序（代码）**都称为一个进程。每个进程都分配一个ID号 每一个进程，都会对应一个父进程，而这个父进程可以复制多个子进程。例如www服务器。 每个进程都可能以两种方式存在。 前台和后台 前台进程：用户目前的屏幕上可以进行操作的。 后台进程：实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行。 一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中，直到关机才结束。 14.2显示系统执行的进程 ps：查看目前系统中，有哪些正在执行，以及它们执行的状况。可以不加任何参数。 ​ PID：进程识别号； ​ TTY：终端机号； ​ TIME：此进程所消耗的CPU时间； ​ CMD：正在执行的命令或进程名 ps -a：显示当前终端的所有进程信息。 ps -u：以用户的格式显示进程信息。 ps -x：显示后台进程运行的参数。 ps -axu | grep xxx：过滤得到xxx的信息。 ps -ef：以全格式显示当前所有的进程，查看进程的父进程。 1ps -ef| grep sshd -e：显示所有进程。 -f：全格式。 14.3终止进程 kill [选项] 进程号：通过进程号杀死进程 killall 进程名称：通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用 -9：表示强迫进程立刻停止 案例1：踢掉非法用户：kill 进程号 案例2：终止远程登录服务sshd，在适当时候再次重启sshd服务 案例3：终止多个gedit编辑器：killall 进程名称 案例4：强制杀掉一个终端：kill -9 进程号 14.4查看进程树：pstree [选项] -p：显示进程的PID -u：显示进程的所属用户 14.5服务（service）管理 service管理指令：service 服务名 [start | stop | restart | reload | status] 在CentOS7.0之后，不再使用service，而是systemctl 查看防火墙情况： service iptables status systemctl status firewalld（7.0之后的版本） 测试某个端口是否在监听：telnet 查看服务名： 方式1：使用setup-&gt;系统服务就可以看到 方式2：/etc/init.d/服务名称 服务的运行级别（runlevel）： 查看或修改默认级别：vim /etc/inittab 每个服务对应的每个运行级别都可以设置 如果不小心将默认的运行级别设置成0或者6，怎么处理？ 进入单用户模式，修改成正常的即可。 chkconfig：可以给每个服务的各个运行级别设置自启动/关闭 查看xxx服务：chkconfig –list | grep xxx 查看服务的状态：chkconfig 服务名 --list 给服务的运行级别设置自启动：chkconfig –level 5 服务名 on/off 要所有运行级别关闭或开启：chkconfig 服务名 on/off 动态监控进程 top [选项] top和ps命令很相似。它们都用来显示正在执行的进程。top和ps最大的不同之处在于top在执行一段时间可以更新正在运行的进程。 -d 秒数：指定top命令每隔几秒更新。默认是3秒。 -i：使top不显示任何闲置或者僵死进程。 -p：通过指定监控进程ID来仅仅监控某个进程的状态。 案例1：监控特定用户：top查看进程；u输入用户名。 案例2：终止指定的进程：top查看进程；k输入要结束的进程。 案例3：指定系统状态更新的时间（每隔10秒自动更新，默认是3秒）：top -d 10 交互操作说明： P：以CPU使用率排序，默认就是此项 M：以内存的使用率排序 N：以PID排序 q：退出top 监控网络状态 netstat [选项] -an：按一定顺序排列输出 -p：显示哪个进程在调用 C1 5RPM RPM：RedHat Package Manager，红帽软件包管理工具。 RPM查询已安装的rpm列表：rpm -qa | grep xx rpm包的其它查询指令： rpm -qa：查询所安装的所有rpm软件包 rpm -qa | more rpm -qa | grep xx rpm -q xx：查询xx软件包是否安装 rpm -qi xx：查询软件包信息 rpm -ql xx：查询软件包中的文件 rpm -qf 文件全路径名：查询文件所属的软件包 卸载rpm包：rpm -e 软件包名称 删除时可能会发生依赖错误，忽视依赖强制删除的方法：rpm -e --nodeps 软件包名称 安装rpm包：rpm -ivh 软件包全路径名称 i=install：安装 v=verbose：提示 h=hash：进度条 C16 YUM YUM：是一个shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包。使用yum的前提是联网。 yum list | grep xx：查询yum服务器是否有需要安装的软件 yum install xx：安装指定的yum包 yum -y remove xx：卸载指定的yum包 C17 搭建JAVAEE环境 将软件上传到/opt下 解压缩 配置环境变量的配置文件vim /etc/profile JAVA_HOME=/opt/jdk1.7.0_79 PATH=/opt/jdk1.7.0_79/bin:$PATH export JAVA_HOME PATH 保存然后source /etc/profile生效 安装Tomcat 解压缩到/opt：tar -zxvf apache-tomcat-7.0.70.tar.gz 进入tomcat的bin目录，启动tomcat ./startup.sh：./startup.sh 开放端口 vim /etc/sysconfig/iptables firewall-cmd --zone=public --add-port=8080/tcp --permanent（Centos7） systemctl restart firewalld.service firewall-cmd --reload 重启防火墙生效 测试是否安装成功：在windows和Linux下访问http://linuxip:8080 安装Eclipse 解压缩到/opt：tar -zxvf eclipse-jee-mars-2-linux-gtk-x86_64.tar.gz 启动eclipse，配置jre和server：./eclipse 编写Hello world程序并测试成功 编写jsp页面，并测试成功 安装mysql 查看是否有mysql：rpm -qa | grep mysql 删除旧mysql：rpm -e –nopdeps mysql（强制删除） 安装环境：yum -y install make gcc-c++ cmake bison-devel ncurses-devel 解压mysql：tar -zxvf mysql-5.6.14.tar.gz 进入mysql目录 编译安装： cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DMYSQL_DATADIR=/usr/local/mysql/data -DSYSCONFDIR=/etc -DWITH_MYISAM_STORAGE_ENGINE=1 -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITH_MEMORY_STORAGE_ENGINE=1 -DWITH_READLINE=1 -DMYSQL_UNIX_ADDR=/var/lib/mysql/mysql.sock -DMYSQL_TCP_PORT=3306 -DENABLED_LOCAL_INFILE=1 -DWITH_PARTITION_STORAGE_ENHINE=1 -DEXTRA_CHARSETS=all -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci 编译并安装：make &amp;&amp; make install 配置mysql，设置权限 查看是否有mysql用户和组：cat /etc/passwd，cat /etc/group 添加mysql组：groupadd mysql 添加mysql用户并放在mysql组中：useradd -g mysql mysql 修改/usr/local/mysql权限：chown -R mysql:mysql /usr/local/mysql/ 初始化mysql： scripts/mysql_install_db --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data –user=mysql 如果报错：Can't locate Data/Dumper.pm，则运行：yum install 'perl(Data::Dumper)'，参考链接：https://www.cnblogs.com/yanghongfei/p/7118072.html 删除之前mysql的配置文件：mv /etc/my.cnf /etc/my.cnf.bak 启动MySQL 添加服务，拷贝服务脚本到init.d目录，并设置开机启动 [注意在 /usr/local/mysql 下执行] cp support-files/mysql.server /etc/init.d/mysql chkconfig mysql on service mysql start 执行下面的命令修改root密码 cd /usr/local/mysql/bin ./mysql -u root -p set password = password(‘root’);（quit退出mysql） Shell编程 Shell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便裕兴程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至是编写一些程序。 Shell脚本的执行方式： 脚本格式要求： 脚本以#!/bin/bash 开头 脚本需要有可执行权限 脚本的常用执行方式： 方式1（输入脚本的绝对路径或相对路径） 首先要赋予xx.sh脚本的+x权限：chmod 744 myShell.sh 执行脚本：./myShell.sh 方式2（sh+脚本）： 说明：不用赋予+x权限，直接执行即可 sh ./myShell.sh shell的变量 shell变量的介绍 Linux Shell的变量分为，系统变量和用户自定义变量 系统变量：$HOME、$PWD、$SHELL、$USER等等 显示当前shell中所有变量：set shell变量的定义 基本语法 定义变量：变量=值，=两边不能有空格 撤销变量：unset 变量 声明静态变量：readonly 变量，注意：不能unset 定义变量的规则 变量名称可以由字母、数字和下划线组成，但是不能以数字开头 等号两侧不能有空格 变量名称一般习惯为大写 将命令的返回值赋给变量 A=ls -la这里有反引号（ESC下面），运行里面的命令，并把结果返回给变量A A=$(ls -la)等价于上面 设置环境变量 基本语法 export 变量名=变量值：将shell变量输出为环境变量 source 配置文件：让修改后的配置文件信息立即生效 echo $变量名：查询环境变量的值 多行注释： :&lt;&lt;! 需要注释的内容 ! 位置参数变量 当我们执行一个shell脚本时，如果希望获取到命令行的参数信息就可以使用到位置参数变量。比如： ./myshell.sh 100 200，这个就是一个执行shell的命令行，可以在myshell脚本中传参100，200。 基本语法： $n：n为数字，$0代表命令本身，$1-$9代表第一到第九个参数，10以上的参数需要用大括号包含，如$&#123;10&#125; $*：这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体 $@：这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待 $#：这个变量代表命令行中所有参数的个数 预定义变量 shell设计者事先已经定义好的变量，可以直接在shell脚本中使用 基本语法： $$：当前进程的进程号（PID） $!：后台运行的最后一个进程的进程号（PID） $?：最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确。 后台运行：./myShell.sh &amp; 运算符 在Shell中进行各种运算操作 “$((运算式))”或“$[运算时]” expr m + n，注意expr运算符间要有空格 expr m - n expr \\* / %，乘，除，取余 条件判断 基本语法：[ condition ]，注意condition前后有空格！ 非空返回true，可使用$?验证（0为true，&gt;1为false） 两个整数比较 =：字符串比较 -lt：小于 -le：小于等于 -eq：等于 -gt：大于 -ge：大于等于 -ne：不等于 按照文件权限进行判断 -r：有读的权限 -w：有写的权限 -x：有执行的权限 按照文件类型进行判断 -f：文件存在并且是一个常规的文件 -e：文件存在 -d：文件存在并且是一个目录 流程控制if语句 if判断基本语法： if [ 条件判断式 ];then 程序 fi 或者： if [ 条件判断式 ] then 程序 elif [ 条件判断式 ] then 程序 fi 流程控制case语句 case语句基本语法： case $变量名 in “值1”) 如果变量的值等于值1，则执行程序1 ;; “值2”) 如果变量的值等于值2，则执行程序2 ;; …省略其他分支… *) 如果变量的值都不是以上的值，则执行此程序 ;; esac 流程控制for循环 for循环基本语法1： for 变量 in 值1 值2 值3… do 程序 done for循环基本语法2 for ((初始值;循环控制条件;变量变化)) do 程序 done 流程控制while循环 while循环基本语法1： while [ 条件判断式 ] do 程序 done read读取控制台的输入 read [选项] (参数) -p：指定读取值时的提示符 -t：指定读取值时等待的时间（秒），如果没有在指定的时间内输入，就不再等待了。 参数：变量：指定读取值的变量名 函数 系统函数 basename：返回完整路径最后/的部分，常用于获取文件名 basename [pathname] [suffix] basename [string] [suffix] basename命令会删掉所有的前缀包括最后一个/ 选项：suffix为后缀，如果suffix被指定了，basename会将pathname或string中的suffix去掉 dirname：返回完整路径最后/的前面的部分，常用于返回路径部分 dirname 文件绝对路径：从给定的包含绝对路径的文件名中出去文件名（非目录部分），然后返回剩下的路径（目录部分） 反正两个系统函数都不要最后一个/ 自定义函数 基本语法： function funname() { Action; [return int;] } 调用直接写函数名：funname（不用写括号），然后在后面写参数 Shell编程综合案例 需求分析 每天凌晨2：10备份数据库atguiguDB到/data/backup/db 备份开始和备份结束能够给出相应的提示信息 备份后的文件要求以备份时间为文件名，并打包成.tar.gz的形式，比如：2018-03-12_230201.tar.gz 在备份的同时，检查是否有10天前备份的数据库文件，如果有就将其删除。 如果报错：mysqldump: command not found 解决方案： 先找到mysqldump的位置：find / -name mysqldump -print 然后建立一个链接：ln -fs /usr/local/mysql/bin/mysql /usr/bin crontab -e 10 2 * * * /usr/sbin/mysql_backup_db.sh C18 Python定制篇 Ubuntu 设置Ubuntu支持中文 lsb_release -a 查看版本信息 18.2 设置root密码 su root显示认证失败：是因为我们还没有对root用户设置密码 sudo是模拟用户指令，root下可以不用输入 给root用户设密码：sudo passwd 如果ubuntu没有vim：apt install vim 18.3 python开发 python3 +文件名运行python 18.4apt软件管理和远程登录 apt：Advanced Packaging Tool，是一款安装包管理工具。在Ubuntu下，我们可以使用apt命令进行软件包的安装、删除、清理等。 18.4.1常用命令： sudo apt-get update更新源 sudo apt-get install package 安装包 sudo apt-get remove package 删除包 sudo apt-cache search package 搜索软件包 sudo apt-cache show package获取包的相关信息,如说明、大小、版本等 sudo apt-get install package --reinstall重新安装包 sudo apt-get -f install 修复安装 sudo apt-get remove package --purge 删除包,包括配置文件等 sudo apt-get build-dep package 安装相关的编译环境 sudo apt-get upgrade 更新已安装的包 sudo apt-get dist-upgrade 升级系统 sudo apt-cache depends package 了解使用该包依赖那些包 sudo apt-cache rdepends package 查看该包被哪些包依赖 sudo apt-get source package 下载该包的源代码 18.4.2镜像软件下载地址(root下运行) 查看Ubuntu版本：cat /proc/version 需要修改的文件位置：/etc/apt/source.list 拷贝源文件 cp sources.list sources.list.bak 清空：echo ’ ’ &gt; sources.list 编辑内容vim sources.list sudo apt-get update 18.5 Windows使用SSH远程登录Ubuntu 安装SSH：sudo apt-get install openssh-server 启用SSH：service sshd start Linux使用SSH远程登录Ubuntu 同上 基本语法：ssh 用户名@IP 例如：ssh atguigu@192.168.188.130 使用shh访问，如访问出现错误。可查看是否有该文件 ~/.ssh/known_ssh，尝试删除该文件解决。 登出：exit或者logout","categories":[{"name":"服务器知识","slug":"服务器知识","permalink":"http://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"运维","slug":"运维","permalink":"http://example.com/tags/%E8%BF%90%E7%BB%B4/"}],"keywords":[{"name":"服务器知识","slug":"服务器知识","permalink":"http://example.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9F%A5%E8%AF%86/"}]},{"title":"Java复习","slug":"Java复习","date":"2021-03-05T06:26:31.000Z","updated":"2021-03-30T14:12:56.810Z","comments":true,"path":"2021/03/05/Java复习/","link":"","permalink":"http://example.com/2021/03/05/Java%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"1234567class HelloWorldApp&#123; public static void main (String &#123; System.out.println(“Hi, ”+args[0]); &#125;&#125; 编辑存盘：主类名 含有 main 方法 和文件名要 一致性 HelloWorldApp.java •编译程序 : javac HelloWorldApp.java •运行程序 : java HelloWorldApp “myjava” •运行结果 : Hi, myjava main()方法参数String[] args称为命令行参数。 javac: Java编译器 , 用来将 java 程序编译成Bytecode字节码 java: Java编译器 执行已经转换成 Bytecode 的java应用程序 C1语法（关键字） 语句 /** - - - */ 文档注释 标识符 Java标识符是用来表示类名、变量名、方法名、类型名、数组名、文件名等有效字符序列。一般都要在使用前进行声明。 命名规则： （1）字母（区分大小写）、下划线、美元符号和数字组成 （2）第一个字母不能是数字；不能包含空格。 （3）不能是关键字。 （4）不能是true，false，null（非关键字） 关键词 字符常量（不是） false true 访问控制 private 私有的 protected 受保护的 public 公共的 default 默认 类、方法和变量修饰符 abstract 声明抽象 class 类 extends 扩充,继承 final 最终值,不可改变的 implements 实现（接口） interface 接口 native 本地，原生方法（非 Java 实现） new 新,创建 static 静态 strictfp 严格,精准 synchronized 线程,同步 transient 短暂 volatile 易失 程序控制语句 break 跳出循环 case 定义一个值以供 switch 选择 continue 继续 default 默认 do 运行 else 否则 for 循环 if 如果 instanceof 实例 return 返回 switch 根据值选择执行 while 循环 错误处理 assert 断言表达式是否为真 catch 捕捉异常 finally 有没有异常都执行 throw 抛出一个异常对象 throws 声明一个异常可能被抛出 try 捕获异常 包相关 import 引入 package 包 基本类型 boolean 布尔型 byte 字节型 char 字符型 double 双精度浮点 float 单精度浮点 int 整型 long 长整型 short 短整型 变量引用 super 父类,超类 this 本类 void 无返回值 保留关键字 goto 是关键字，但不能使用 const 是关键字，但不能使用 null 空 不包括main bool （java中是boolean） args System.out.println 数据类型 基本类型： 整型 byte(8)-128 ~ 127, short(16)-32768 ~ 32767, int(32), long(64)long数值在超出 int 范围时必须加 l 或 L 浮点类型 float (32)（有后缀&quot;f&quot;或&quot;F&quot;没有默认double）, double(64) char (16) 注：Unicode码(String非基类) boolean (8) (true / false) 虽然编译后1和0只需占用1位空间，但计算机处理数据的最小单位是1个字节，1个字节等于8位，实际存储的空间是：用1个字节的最低位存储，其他7位用0填补，如果值是true的话则存储的二进制为：0000 0001，如果是false的话则存储的二进制为：0000 0000。 小技巧： String.charAt(index)（返回值为char）可以得到String中某一指定位置的char。 使用String.toCharArray()（返回值为char[]）可以得到将包含整个String的char数组 String s = String.valueOf(‘c’); //效率最高的方法 引用类型 名称 : 标识符 初始值 :为其赋值或者是保留缺省值 作用域 : 在不同程序块中的可用性及生命周期 常量： 整型常量 二进制：0b开头 一般常量：32bit 长整型常量：64bit (88L) 十进制数：非0开头的正负整数 105，-23 八进制数： 0开头的正负整数 017(15), -023(-19) 十六进制：0x开头的正负整数 0x2F(47),-0xa8(-168) long常量：超过int表示范围后，必须+后缀L 变量强转 int nx = (int)x; 表达式：短路 短路或||：如果第一个变量为真，就不判断第二个 短路与&amp;&amp;：如果第一个变量为假，就不判断第二个 Instanceof 运算符 if (t instanceof InstanceOfDemo) { System.out.println (“T是InstanceOfDemo 的实例”); } math类 random() : 返回类型为 double 且介于 0.0 和 1.0 之间的随机数 int i=(int)(Math.random()*100); //生成0-100的随机数，包括0不包括100 – [0,100) int j=rand.nextInt(100); // 这里是一个方法的重载，参数的内容是指定范围 random.nextInt(max-min+1)+min; pow(x,y): 返回双精度浮点数=x^y C3 程序控制结构 do while switch语句： 表达式必须为byte，short，int或或char 循环：loop label: statement 可以跳出多个循环 1234567First_Loop for( int i =2,k=0;i&lt;1000;i++)&#123;for( int j=2;j&lt;= Math.sqrt(i); j++)&#123; if(i%j ==0)continue First_Loop ;&#125;System.out.print（i+&quot;t&quot;); 程序中的错误： 语法编译错误：由语言的编译系统负责检测和报告由于所编写的程序存在语法问题，未能通过由源代码到目标代码的编译过程而产生的错误。 运行错误：在程序的运行过程中产生的错误。 严重错误：出现死机、死循环，内存溢出，递归无出口(只能在编程阶段解决） 非致命错误（异常）：被 0 除，读文件而文件不存在，网络中断等。 java异常处理： 处理错误的方法等内容。每**当 Java 程序运行过程中发生一个可识别的运行错误时，即该错误有一个异常类与之相对应时，系统都会产生一个相应的该异常类的对象，**即产生一个异常。一旦一个异常对象产生了，系统中就一定有相应的机制来处理 1.捕获异常，就地解决，并使程序继续执行 。 2.将异常向外转移，即将异常抛出方法之外，由调用该方法的环境去处理。 ​ 异常抛出方式： 自动抛出（系统定义异常） 用 throw 语句抛出（用户定义异常） 自定义异常： throws出现在方法函数头；而throw出现在函数体。 throws E1,E2,E3告诉程序这个方法可能会抛出这些异常，方法的调用者可能要处理这些异常，而这些异常可能是该函数体产生的。 throw则是明确了这个地方要抛出这个异常。 定义异常类：class MyExp extends Exception { //或继承其他异常类 用户自定义的异常要转移需要在方法头声明一下 {………………… throw new MyExp(“年龄超过规定”）； } 异常语句： 123456789101112131415try&#123;//接受监视的程序块 在此区域内发生//若 try 块中出现异常，则控制转向下面的异常处理部分，然后执行后续语句。//若 try 块中没有异常，则 try 块执行完，控制转向后续语句。 &#125;catch (要处理的异常种类和标识符 )&#123;//处理异常1//按先后顺序捕获 注意 catch 块书写时的 排列顺序 :先具体、后一般 ))，但只捕获一次。&#125;catch (要处理的异常种类和标识符 )&#123;//处理异常2&#125;&#125;finally&#123;………&#125; finally: 不论是否有异常抛出，均执行只有当 try 块中执行 System.exit() 时，会立即结束程序，return finally也执行。 处理过程： 123456789101112131415try &#123; //抛出例外 a=1/b; System.out.println(&quot;a=&quot;+ a); if(b==0) throw new Exception(“Here‘s my Exception”); //不执行 if(a==0) throw new Exception(&quot;Here&#x27;s my Exception&quot;);//当遇到关键字 throw 时就抛出一个异常&#125; catch(Exception e) &#123; //将控制转移到相关的 catch 块中处理之//捕获例外 //处理例外 System.out.println(&quot;Caught Exception&quot;); System.out.println(&quot;e.getMessage(): &quot; + e.getMessage()); System.out.println(&quot;e.toString(): &quot; + e.toString()); System.out.println(&quot;e.printStackTrace():&quot;); e.printStackTrace();&#125;//如果产生异常的方法本身没有相应 catch 语句 块，则应有 throws 语句声明例外//退出当前方法并转向上一级调用此方法的方法的 catch 语句块 C4 面向对象 类： Java 类由状态或属性 和 行为 两部分组成 。 用变量来描述类的状态用方法 来实现类的行为 。 类都派生自 Object 定义 [类的修饰符 class 类名 extends 父类名 ]][implement 接口名表 关系：包含 关联 继承 修饰 Ø一般类只能是public和非public，而内部类可以指 定为 private 和 protected。 对象： 对象 实例 instance 以类为模板创建的 方法 在方法体中可以访问所有的类属性，可以调用所有类中定义的方法。 返回值: 要指定方法返回值类型。如没有返回值，类型要写void。 修饰符 (Modifier) 访问控制符： public、 private 、 protected 、 protected static 静态方法，又称 类方法使用类名或对象名作为前缀，建议使用类名在方法体中只能使用 static 变量和 static 方法 abstract ：只有方法头，而没有具体的方法体和操作实现的方法， 要在子类中通过重新定义（ override ）来实现 final ：不能被重新定义 override 的方法 类方法 静态方法： static 方法名 (…){ 使用类方法不用创建类的对象。建议使用类名做前缀，而不是使用某一个具体的对象名。 main 方法要调用本类的其它方法： 1.将这些方法设计成静态方法 2.创建对象，使用对象方法（静态对象也适用） 抽象方法和抽象类 抽象类 包含抽象方法的类就是抽象类。通过abstract方法定义规范，然后要求子类必须定义具体实现。通过抽象类，我们就可以做到严格限制子类的设计，使子类之间更加通用。 不能放在一起的修饰符：final和abstract，private和abstract，static和abstract，因为abstract修饰的方法是必须在其子类中；用static声明方法表明这个方法在不生成类的实例时可直接被类调用，而abstract方法不能被调用，两者矛盾。 123456789101112131415161718192021//抽象类abstract class Animal &#123; abstract public void shout(); //抽象方法&#125;class Dog extends Animal &#123; //子类必须实现父类的抽象方法，否则编译错误 public void shout() &#123; System.out.println(&quot;汪汪汪！&quot;); &#125; public void seeDoor()&#123; System.out.println(&quot;看门中....&quot;); &#125;&#125;//测试抽象类public class TestAbstractClass &#123; public static void main(String[] args) &#123; Dog a = new Dog(); a.shout(); a.seeDoor(); &#125;&#125; 要点 \\1. 有抽象方法的类只能定义成抽象类或者接口 \\2. 抽象类不能实例化，即不能用new来实例化抽象类。 \\3. 抽象类可以包含属性、方法、构造方法。但是构造方法不能用来new实例，只能用来被子类调用。 \\4. 抽象类只能用来被继承。 \\5. 抽象方法必须被子类实现。 变量 [修饰符] 数据类型 变量名； 成员变量（实例变量） 其生命周期与对象存在的时间相同。 静态变量（类变量，对所有的实例一致） 位于类的内存区域中，为该类的各个对象共享 类变量的声明：要用上述修饰符 控制域 修饰符 访问控制符 public ：可被所有其他类引用 private ：仅可被该类自身引用和修改，不能被其他 任何类（包括该类的子类）引用，它提供了最高级 别的保护。 protected 该类自身、子类、同一包中的其他类 缺省：本包中的类 static: 类成员变量，对所有的实例一致，引用时前缀 可使用类名或对象名 final: 数值不变常量，定义同时应对其进行初始化 局部变量：要初始化没有赋初值 三大特性 面向对象的分析（OOA） 面向对象的设计（OOD） 封装： \\1. 提高代码的安全性。 \\2. 提高代码的复用性。 \\3. “高内聚”：封装细节，便于修改内部代码，提高可维护性。 \\4. “低耦合”：简化外部调用，便于调用者使用，便于扩展和协作。 技巧： \\1. 类中的数据使用private定义。 \\2. 使用public方法来操作数据。 \\3. 把逻辑上相关联的数据封装成新的类来使用，类似 结构体。 \\4. 不要定义太庞大的类，要把无关的功能适当分离。 \\5. 培养良好的编程风格 多态：（polymorphism） 用同一个名字调用实现不同操作的方法 方式1：不同的类之间的同名方法。 方式2：同一程序中同名的不同方法共存，参数不同的同名方 法 可以通过子类对父类方法的覆盖实现多态 可以利用重载(overload)在同一个类中定义多个同名的方法（用不同的参数列表(参数的个数, 类型, 顺序的不同)在一个类中，不可 以存在两个只有返 回值不同的方法） 向上转型 1234567891011121314151617181920212223242526272829303132333435public class Animal &#123; public void eat()&#123; System.out.println(&quot;animal eatting...&quot;); &#125;&#125;public class Cat extends Animal&#123; public void eat()&#123; System.out.println(&quot;我吃鱼&quot;); &#125;&#125;public class Dog extends Animal&#123; public void eat()&#123; System.out.println(&quot;我吃骨头&quot;); &#125; public void run()&#123; System.out.println(&quot;我会跑&quot;); &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Animal animal = new Cat(); //向上转型 animal.eat(); animal = new Dog(); animal.eat(); &#125; &#125;//结果://我吃鱼//我吃骨头这就是向上转型，Animal animal = new Cat(); 将子类对象 Cat 转化为父类对象 Animal。这个时候 animal 这个引用调用的方法是子类方法。 转型过程中需要注意的问题 向上转型时，子类单独定义的方法会丢失。比如上面Dog类中定义的run方法，当animal引用指向Dog类实例时是访问不到run方法的，animal.run()会报错。 子类引用不能指向父类对象。Cat c = (Cat)new Animal()这样是不行的。 向下转型： 123456789101112//还是上面的animal和cat dogAnimal a = new Cat();Cat c = ((Cat) a);c.eat();//输出 我吃鱼Dog d = ((Dog) a);d.eat();// 报错 ： java.lang.ClassCastException：com.chengfan.animal.Cat cannot be cast to com.chengfan.animal.DogAnimal a1 = new Animal();Cat c1 = ((Cat) a1);c1.eat();// 报错 ： java.lang.ClassCastException：com.chengfan.animal.Animal cannot be cast to com.chengfan.animal.Cat 向下转型的前提是父类对象指向的是子类对象（也就是说，在向下转型之前，它得先向上转型） 向下转型只能转型为本类对象（猫是不能变成狗的）。 重载： 一个类中，同名方法 方法名相同 方法的参数类型，参数个不一样 方法的返回类型可以不相同（注意此时参数不同，不然不知道调用哪个） 方法的修饰符可以不相同 main 方法也可以被重载 继承： 继承实际上是存在于面向对象程序中的两个类之间的一 种关系。Java要求每个类都有父类(隐含为java.lang包中的Object类)。 覆盖：extends 超类/父类名 子类继承父类，可以得到父类的全部属性和方法(除了父类的构造方法)，但不见得可以直接访问(比如，父类私有的属性和方法)。 重新定义父类中已有的方法：覆盖(override ) 子类中的方法应与父类中的被覆盖的方法有完全相同的：参数列表、返回值,访问权限不能缩小，抛出的例外要相同 Ø三个条件有一个不满足，就不是方法的覆盖，而是子类 自己定义与父类无关的方法，父类的方法未被覆盖，因 而仍然存在。 this引用和super引用 this表示的是当前对象本身，更确切地说，this 代表了当前对象的一个引用。 解决实例变量被局部变量屏蔽的问题 super 表示的是当前对象的直接父类对象，通过super来访问父类中被子类覆盖的方法或属性。 继承树追溯 属性/方法查找顺序 ​ \\1. 查找当前类中有没有属性h \\2. 依次上溯每个父类，查看每个父类中是否有h，直到Object \\3. 如果没找到，则出现编译错误。 \\4. 上面步骤，只要找到h变量，则这个过程终止。 构造方法调用顺序： 构造方法第一句总是:super(…)来调用父类对应的构造方法。所以，流程就是：**先向上追溯到Object，然后再依次向下执行类的初始化块和构造方法，直到当前子类为止。**注：**静态初始化块调用顺序，**与构造方法调用顺序一样，不再重复。 final: \\1. 修饰变量: 被他修饰的变量不可改变。一旦赋了初值，就不能被重新赋值。 1final` `int` `MAX_SPEED = ``120``; \\2. 修饰方法：该方法不可被子类重写。但是可以被重载! 1final` `void` `study()&#123;&#125; \\3. 修饰类: 修饰的类不能被继承。比如：Math、String等。 1final` `class` `A &#123;&#125; 构造函数 在创建每个新的类对象时自动执行，以保证新对象的各成员有合法、确定的数值。没有返回类型，当一个构造函数调用另一个构造函数时,要使用关键字 this,同时这个调用语句应该是整个构造函数的第一条可执行语句。 123456789101112A(String n,int a,float s)&#123; name = n ; if(a&gt;=18 &amp;&amp; a&lt;=60) age = a ; else &#123; System.out.println(&quot;illegal age&quot;); System.exit(1);&#125;salary = s ;&#125;A( String n , int a ) &#123; this(n , a , 300 ) ;&#125; 构造函数的继承： Ø子类没有定义构造函数时，自动继承父类不含参 数的构造函数，并在创建新子类对象时自动执行。 子类有自己的构造函数时，创建新子类对象时也要先执行父类不含参数的构造函数，再执行自己的构造函数。 Ø若子类的构造函数中没有super(…)语句，系统将隐含调用父类无参数构造函数。如要调用父类的含参数的构造函数，需用super关键字，且该调用语句必须是子类构造函数的第一个可执行语句。 原理： 类对象创建时，利用运算符new 在内存中开辟专用空间， 这时会自动执行类的构造函数,构造函数不是用来调用的，而是new算符的参数。 静态初始化器: 静态初始化器则是在它所属的类加载入内存时 由系统调用执行；比构造函数执行得更早 static { a=10; b=a+3; c=a+b; …… } 构造函数初始化： 为对象分配内存并初始化(0、 false、 null)。 如果没有为类中的某些成员赋初始值，Java系统会为类 的成员赋固定的初始值（数值变量的值为0，布尔变量的 值为false ，未初始化的引用为null ）。 执行每一层的类的显式初始化。 执行每一层的类的构造函数（由于显式或隐式调用）。 抽象类和最终类 Øfinal可以与abstract一起使用吗？ 不能同时修饰同一个方法，因为abstract和final修饰词是相对矛盾的，abstract必 须有子类来实现，而final则不能被子类所重载。 123456789abstract class PhoneCard &#123;……&#125;class Number_PhoneCard extends PhoneCard &#123;……&#125;final class D200_Card extends Number_PhoneCard&#123;…….&#125; 控制修饰符总结 1.protected方法和友好方法的区别。 如果子类和父类不在同一个包中，那么，子类继承了父类的protected、public成员变量做为子类的成员变量，并且继承了父类的protected、public方法为子类的方法。如果子类和父类不在同一个包里，子类不能继承父类的友好变量和友好方法。 Øfinal可以用于类名前，表示类不可被继承；final用于变量前， 表示它是只能一次赋值的变量，如果初始化了那就是常量。 Østatic可用于类内部的变量或方法前，表示这是整个类共享的变量和方法，与类对象无关。 Øabstract用于类名前表示一个抽象类，abstract用于成员方 法前表示抽象方法，而抽象类内部至少要有一个抽象方法。 跟final不能一起用，至于为什么，你一想就清楚了，抽象类本身必须有子类需要实现它的方法，但是final类又不 能有子类，这不矛盾了么，所以不能一起用。 Østatic final 用于修饰类的静态变量时表示一个常数，其实更 多的还是用在接口里，毕竟用在类里面可能会被子类隐藏 三种情况，四个范围 接口： 用关键字interface来定义，而不是用class 接口中定义的变量全是最终的静态变量。 没有自身的构造方法而且定义的其他方法全是抽象方法，即只提供方法的定义，而没有提供方法的实现语句。 采用多重继承机制 1234567接口定义public interface 接口名 [extends 父接口名列表]&#123; // 常量域声明public static final 域类型 域名 = 常量值；// 抽象方法声明public abstract 返回值类型 方法名( 参数列表 ) ；&#125; 实现接口： 当一个类声明 implements 某一 interface 时，必须具体实现该 interface 中定义的抽象方法**，实现接口的全部方法并把此方法定义为public的** 如果实现了某个接口的类是abstract的抽象类，则它可以不实现指定接口的所有抽象方法。 特点：可以实现 多继承 1234567891011121314151617181920212223interface Instrument&#123; int i =5 ; // static &amp; final// Cannot have method definitions: void play(); // Automatically public String what(); void adjust();&#125;class Wind implements Instrument &#123;// public cannot be omitted public void play() &#123;System.out.println(&quot;Wind.play()&quot;);&#125;public String what() &#123; return &quot;Wind&quot;; &#125;//注意&quot;adjust()&#123;&#125; &quot;与&quot;adjust();&quot;的区别 public void adjust() &#123;&#125;&#125;//系统接口代表了监听并处理动作事件的功能public interface ActionListener extends EventListener&#123;public abstract void actionPerformed(ActionEvent e);&#125; 内部类（了解） Ø在某个类的内部定义的类称之内部类。 设外层类名为Myclass，则该类的内部类名为： **Myclass$c1.class (c1 为 命 名 内 部 类 名 ）**Myclass$1.class (表示类中定义的第一个匿名内部类） Ø内部类拥有对在外层类中定义的所有属性和方法的访 问权，内部类可以随意使用外部类的成员变量（包括私有） 而不用生成外部类的对象，这也是内部类的唯一优点 12345678910111213141516//有名内部类class Button1Adapter implements ActionListener &#123;public void actionPerformed(ActionEvent e) &#123;…&#125;//匿名内部类也就是没有名字的内部类 //使用一次 必须继承一个父类或实现一个接口。Out.In in = new Out().new In();in.print();//或者采用下种方式访问/*Out out = new Out();Out.In in = out.new In();in.print();*/ C5 数组&amp;字符串 数组： 类型相同的元素组成的有顺序的数据集合有自身的方法，不是变量的集合 (step1)数组的声明(1) int intArray [ ];不是指长度可变 ​ 二维数组(可以) ​ int [ ] x [ ]; (step2）通过new运算符来动态创建 (step3)创建数组元素并初始化。 创建: 方法一：先声明后创建 int intArray [ ] ; intArray = new int [5] ; 方法二：在声明的同时创建 int intArray [ ] = new int [5] ; 方法三：直接赋值 int [ ] intArray = { 1, 2, 3, 4, 5 } ; 调用： 1.doubleArray(b); // 调用不加[] 2.void doubleArray(Integer c[ ] )；//方法参数表中要加[]表示数组 Bubble Sort 123456789101112131415161718class BubbleSort &#123;// sort the elements of an array with bubble sortpublic void bubbleSort( int b[] )&#123; for ( int pass = 1; pass &lt; b.length; pass++ ) // passes for ( int i = 0; i &lt; b.length - pass; i++ ) // one pass if ( b[ i ] &gt; b[ i + 1 ] ) // one comparison swap( b, i, i + 1 ); // one swap&#125;// swap two elements of an arraypublic void swap( int c[], int first, int second )&#123; int hold; // temporary holding area for swap hold = c[ first ]; c[ first ] = c[ second ]; c[ second ] = hold;&#125;&#125; 字符串： 转化为其它类型： toString()方法 Object类中定义有public String toString()方法， 其返回值是 String 类型。 默认会返回“类名+@+16进制的hashcode”。在打印输出或者用字符串连接对象时，会自动调用该对象的toString()方法。 一般都会重写Float.toString()方法就会转化为String 常见方法： int indexOf(String str) //返回str在当前串中开始位置 int indexOf(String str,int fromIndex) 字符串转换为数组 char[] toCharArray() byte[] getBytes() 比较内容是否相等： boolean equals(String str) boolean equalsIgnoreCase(String str) 不使用“==”号来比较字符串内容是否相等(常量池除外) 可变字符串（StringBuffer） StringBuffer类（线程安全的）对象是可变的字符串，有改变字符串的若干方法。 构造方法 1.StringBuffer() // 创建一个空的StringBuffer对象 2.StringBuffer(int length) //设置初始容量 3.StringBuffer(String s) //利用已有字符串String对象来初始化 方法 1.String toString() 将可变串变为不可变字符串 System.out.println()不接受可变字符串 2.append(char c) 正则： 12345String s = &quot;@Shang Hai Hong Qiao Fei Ji Chang&quot;;String regEx = &quot;a|F&quot;; // 表 示 a 或 F Pattern pat = Pattern.compile(regEx); Matcher mat = pat.matcher(s); boolean rs = mat.find(); C6界面 事件处理：引入java.awt.event包 （内容少，主要布局 borderlayout.NORTH\\EAST） Swing 、awt(空窗口、frame(窗口)、panle、JOptionPane) 第一代组件:Java.AWT(组件和容器) 第二代组件:Javax.Swing 布局： 组件的位置由容器的布局管理器（Layout Manager）决定 组件自身不能构成独立的图形界面，必须放到容器（ JContainer）对象中。 窗口： 框架（Frame）类是Window类的子类，它是一种带标题框并且可以改变大小的窗口。 JFrame =Frame + Container 面板: 面板（Panel）与框架类似，也是一种容器，可以容纳其他GUI组件。 showDialog对话框: showMessageDialog —— 信息对话框，显示信息，告知用户发生了什么情况 JOptionPane.showMessageDialog(frame, “File not found.”, “An error”, JOptionPane.ERROR_MESSAGE); 1.showMessageDialog()没有返回值 2.showConfirmDialog()和showOptionDialog()方法返回int型数值，代表用户选择按钮的序号 （JOptionPane中定义了YES_OPTION、NO_OPTION、CANCEL_OPTION、OK_OPTION和CLOSED_OPTION等常量，分别代表用户选择了YES、NO、CANCEL、OK按钮以及未选择而直接关闭了对话框） 3.showInputDialog()方法的返回值为String或Object，代表用户的输入或选项JOptionPane.showConfirmDialog(this,&quot;确定要退出吗？ 确认 &quot;, JOptionPane.OK_CANCEL_OPTION,JOptionPane.WARNING_MESSAGE); 布局管理器： BorderLayout（边框布局）：Window类、Dialog类和Frame类的默认布局管理器。 FlowLayout(流式布局)：Panel和Applet默认的 事件处理 actionlistener public ButtonAct() &#123; ... ... ... //为b1注册事件监听者B1 b1.addActionListener(new B1()); add(b1); ... ... ... &#125; //利用inner class结构定义监听者类 //每种Listener接口均定义了一套abstract方法 class B1 implements ActionListener &#123; //利用actionPerformed方法进行事件处理 public void actionPerformed(ActionEvent e)&#123; //ActionEvent类：属于动作事件，包括：点击按钮； 双击一个列表中的选项;选择菜单项；在文本框中 按回车。 who.setText(\"Button 1\"); &lt;!--code￼17--&gt; 文件类 FileReader和FileWriter File类主要用于命名文件、查询文件属性和处理文件目录。 File (String pathname) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 File src=new File(&quot;c.txt&quot;); File dest=new File(&quot;1.java&quot;); InputStream iStream=null; OutputStream oStream=null; try &#123; iStream=new FileInputStream(src); oStream=new FileOutputStream(dest); //3.操作 byte[] flush=new byte[1024]; //缓冲容器 int len=-1; while((len=iStream.read(flush))!=-1) &#123; oStream.write(flush,0,len); &#125; oStream.flush(); &#125; catch (FileNotFoundException e) &#123; // TODO: handle exception e.printStackTrace(); &#125;catch (IOException e) &#123; // TODO: handle exception e.printStackTrace(); &#125;finally &#123; try &#123; if(null!=oStream) &#123; oStream.close(); &#125; &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125; try &#123; if(null!=iStream) &#123; iStream.close(); &#125; &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125; &#125;inputStream = new FileReader(&quot;.jpg&quot;); //&quot;original.txt&quot;);outputStream = new FileWriter(&quot;.jpg&quot;); //characteroutput.txt&quot;);int c;while ((c = inputStream.read()) != -1) &#123; outputStream.write(c);&#125; 1234567891011121314151617BufferedReader fin =new BufferedReader(new FileReader(&quot;test.txt&quot;) );fin.readLine()//读文件 //输出 PrintWriter fout =new PrintWriter(new FileWriter(&quot;test.txt&quot;) , true) );//写文件 fout.println(…) flush() //System类的输入和输出System类包含三个I/O流成员用于系统标准输入/输出public static InputStream System.inpublic static PrintStream System.outpublic static PrintStream System.errBufferedReader stdin = new BufferedReader(new InputStreamReader(System.in) );stdin.read() 读一个字符String readLine() 读一行 C8多线程 –五种状态 在它的一个完整的生命周期中通常要经历如下的五种状态： 新建new： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态 就绪start()： 处于新建状态的线程被启动后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件 运行： 当就绪的线程被调度并获得处理器资源时,便进入运行状态， run()方法定义了线程的操作和功能 阻塞Blocked： 在某种特殊情况下，被人为挂起或执行输入输出操作时，让出CPU并临时中止自己的执行，进入阻塞状态 死亡：线程完成了它的全部工作或线程被提前强制性地中止 stop()或destroy() 两种实现方法(Runnable多) 12345678class P extends Thread&#123; &#125;(new P()),start();class P1 implements Runnable&#123; &#125;(new Thread(new P1())).start(); 警察抓小偷程序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596class CatchTest2 &#123; public static void main(String args[]) &#123; CatchTest2 x = new CatchTest2(); x.go(); &#125; public synchronized void go() &#123; Position startP = new Position(-20, -30); Policeman Pth = new Policeman(&quot;TomP&quot;, startP); Thief Tth = new Thief(&quot;hijackT&quot;, startP); Tth.start(); Pth.start(); &#125;&#125;class Position &#123; int p_x; int th_y; Position(int px, int ty) &#123; this.p_x = px; this.th_y = ty; &#125; public void show() &#123; System.out.println(&quot;Police at &quot; + p_x); System.out.println(&quot;Thief at &quot; + th_y); &#125; boolean isCatched() &#123; if (p_x &gt;= -20 &amp;&amp; p_x &lt;= 20 &amp;&amp; th_y &gt;= -20 &amp;&amp; th_y &lt;= 20) &#123; return true; &#125; else return false; &#125;&#125;class Thief extends Thread &#123; Position pos; Thief(String s, Position pos) &#123; super(s); this.pos = pos; &#125; public void run() &#123; try &#123; this.sleep(900); &#125; catch (Exception e) &#123; &#125; while (true) &#123; for (pos.th_y = -100; pos.th_y &lt;= 100; pos.th_y++) &#123; pos.show(); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;class Policeman extends Thread &#123; Position pos; Policeman(String s, Position pos) &#123; super(s); this.pos = pos; &#125; public void run() &#123; try &#123; this.sleep(10); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; while (true) &#123; for (pos.p_x = -100; pos.p_x &lt;= 100; pos.p_x++) &#123; pos.show(); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if (pos.isCatched()) &#123; System.out.println(&quot;police at &quot; + pos.p_x + &quot;have catched&quot; + &quot;the thief who is at&quot; + pos.th_y); System.exit(0); &#125; &#125; &#125; &#125;&#125; 加锁线程同步 1234567//加锁1 (临界区-方法）synchronized 方法名&#123; … &#125; 进入该方法时加锁 //加锁2（临界区-代码块）方法名&#123; synchronized(this)&#123;… &#125; //进入该代码段时加锁&#125; notify()唤醒正在排队等待资源管程的线程中优先级最高者，使之执行并拥有资源的管程 死锁： 不同的线程分别占用对方需要的同步资源不放弃， 都在等待对方放弃自己需要的同步资源，就形成了线程的死锁 •当两个线程相互调用Thread.join() •当两个线程使用嵌套的同步块，一个线程占用了另外 一个线程必需的锁，互相等待时被阻塞就有可能出现死 锁。 C9集合 set Set接口的特点 (1)无序不重复 (3)集合重元素是无序存储，不能按索引位置访问元素。 HashMap HashSet （Hash Table底层hash表） TreeSet（BalancedTree底层二叉树，已排序; TreeSet中含有一个&quot;NavigableMap类型的成员变量&quot;m，而m实际上是 “TreeMap的实例”。） List: 1LinkedList 底层数据结构是链表，查询慢， 增删快，线程不安全，效率高，可以存储重复元 素 2ArrayList：底层数据结构是数组，查询快， 增删慢，线程不安全，效率高，可以存储重复元 素 3Vector:底层数据结构是数组，查询快，增 删慢，线程安全，效率低，可以存储重复元素 Interator 123Iterator iter=c. iterator()while(iter. hasNext())&#123;Object obj=iter.next();&#125; C10网络 java.net.InetAddress类 （1） getLocalHost 作用：返回本机地址（机器名+IP） （2） getByName(String ) 作用：给定计算机名，返回IP地址 （3） String getHostAdress() 作用：返回本机IP地址 传输协议 TCP(Transport Control Protocol) 两主机之间有连接的、可靠的、端到端(end-to-end) 的数据流的传输 如http, ftp, telnet 的传输层均使用此协议 UDP(User Datagram Protocol) 从一台机器向另一台机器以无连接的、数据报的方 式进行通讯的协议 如：Email可以使用UDP socket：IP+Port 两台机器之间通讯的端点。分辨internet上运行各种服务程序 Port端口号：计算机根据端口号提供服务，0～65535之间的整数。Socket的连接需要一对套接字，一个运行于客户端称为Client Socket,一个运行于服务端称为ServerSocket。 Java的Socket通信模式 Ø创建socket Ø打开连接到socket的输入/输出流。 Ø按照一定的协议对socket进行读写操作，实现 所要完成的主要工作。 Ø关闭socket //服务器端 //创建一个ServerSocket对象(指定端口号). ServerSocket mSer = new ServerSocket(8010); //在该端口监听，当收到Client发出的请求时，创建一个Socket对象与此Client通讯: Socket socket = ss.accept(); //接收到Client请求之前，该语句处于阻塞状态。 //通过Socket类的I/O流对象与Client端通信。 OutputStream InputStream //结束通信，关闭输入输出流、关闭Socket对象。 //撤消服务时，关闭 ServerSocket对象: mServer.close()。 //客户端 new Socket (host,port);//试图建立与服务器的连接，如果连接成功返回一个Socket对象 OutputStream//获得输出流 InputStream//获得输入流 close(); //实例 PrintStream out = new PrintStream(s.getOutputStream()); BufferedReader in = new BufferedReader( new InputStreamReader(s.getInputStream())); String info=in.readLine(); System.out.println(\"now got \"+info); out.println(\"HTTP/1.0 200 OK\"); out.println(\"MIME_version:1.0\"); out.println(\"Content_Type:text/html\"); i++; String c=\"&lt;html&gt; &lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt; hi This is \"+i+\"&lt;/h1&gt;&lt;/Body&gt;&lt;/html&gt;\"; out.println(\"Content_Length:\"+c.length( )); out.println(\"\"); out.println(c); out.close(); s.close(); in.close( ); &lt;!--code￼24--&gt; ResultSet对象表示数据库结果集的数据表，通常通过执行查询数据库的语句生成。保持一个光标指向其当前的数据行。 最初，光标位于第一行之前。next方法将光标移动到下一行，并且由于在ResultSet对象中没有更多行时返回false ，因此可以在while循环中使用循环来遍历结果集。 Statement stmt = con.createStatement( ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE); ResultSet rs = stmt.executeQuery(\"SELECT a, b FROM TABLE2\"); // rs will be scrollable, will not show changes made by others, // and will be updatable 所述ResultSet接口提供getter方法（ getBoolean ， getLong ，用于从当前行检索列值，等等","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java后端","slug":"java后端","permalink":"http://example.com/tags/java%E5%90%8E%E7%AB%AF/"}],"keywords":[{"name":"编程基础","slug":"编程基础","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}]},{"title":"Hexoblog","slug":"Hexoblog","date":"2021-03-05T06:26:15.000Z","updated":"2021-03-30T13:53:51.684Z","comments":true,"path":"2021/03/05/Hexoblog/","link":"","permalink":"http://example.com/2021/03/05/Hexoblog/","excerpt":"","text":"第一篇博客 1.安装node.js 1234npm -v#查看是否安装成功npm install -g cnpm --registry=https://registry.npm.taobao.org#利用npm安装cnpm 淘宝镜像源 2.全局安装Heox博客框架 1cnpm install -g hexo-cli 3.搭建博客（widows再git操作） 123hexo inithexo generatehexo server 启动 1hexo server 2.断开 1ctrl+c断开 3.创建博客 1234567891011121314151617181920#创建博客江大师@LAPTOP-IL5P7NAD MINGW64 /d/code file/blog$ hexo new &quot;myFirstBlog&quot;INFO Validating configINFO Created: D:\\code file\\blog\\source\\_posts\\myFirstBlog.md江大师@LAPTOP-IL5P7NAD MINGW64 /d/code file/blog$ cd source/_posts #进入目录可以用vim写东西江大师@LAPTOP-IL5P7NAD MINGW64 /d/code file/blog/source/_posts$ cd ../..江大师@LAPTOP-IL5P7NAD MINGW64 /d/code file/blog$ hexo clear #清理目录江大师@LAPTOP-IL5P7NAD MINGW64 /d/code file/blog$ hexo generate #部署博客江大师@LAPTOP-IL5P7NAD MINGW64 /d/code file/blog$ hexo server #启动服务 完成搭建 4.部署到远端github 12345678cnpm install --save hexo-deployer-git #安装插件$ ls_config.landscape.yml db.json package.json public/ source/_config.yml #设置_config文件夹vim _config.yml#配置文件$ hexo d #部署到远端 _config.yml 1234#配置内容deploy: type: git repo: https://github.com/JiangZhijianZhejaing/JiangAI.io.git #配置仓库地址 5.完成部署加主题 将主题放入theme 修改config.yml的theme 12345678910重新clear一下江大师@LAPTOP-IL5P7NAD MINGW64 /d/code file/blog$ hexo clean #清理目录江大师@LAPTOP-IL5P7NAD MINGW64 /d/code file/blog$ hexo generate #部署博客江大师@LAPTOP-IL5P7NAD MINGW64 /d/code file/blog$ hexo server #启动服务$hexo d#推上去 详细配置查看文档","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"}],"keywords":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]}]}